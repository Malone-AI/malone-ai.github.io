<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GDB 调试</title>
      <link href="/2025/03/06/chores2/"/>
      <url>/2025/03/06/chores2/</url>
      
        <content type="html"><![CDATA[<p>GDB是Linux下非常好用且强大的调试工具。GDB可以调试C、C++等多种语言。</p><h1>1. 判断文件是否带有调试信息</h1><p>C/C++的编译文件有两种版本：</p><ul><li>release版本</li><li>debug版本</li></ul><p>gcc和g++默认编译生成的是release版本，release版本不带有调试信息，通常体积更小。</p><p>而如果在编译时带上&quot;-g&quot;参数，那么编译生成的就是debug版本。debug版本带有调试信息，体积通常会更大。</p><p>如果你想对一个C/C++的编译文件进行调试，那么它必须是debug版本，也就是编译时带了&quot;-g&quot;参数，带有调试信息的二进制可执行文件。</p><p>有一个编译好的二进制文件，你不确定是不是debug版本，是否带有调试信息，有两种方法可以确定。</p><ol><li>使用 gdb 命令</li></ol><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行gdb test命令后，如果其不是debug版本，不带有调试信息，那么就会显示：</p><pre><code>Reading symbols from test...(No debugging symbols found in test)</code></pre><p>（当然还有其他的一些信息会显示，如gdb版本等等。）</p><ul><li>带有调试信息（debug）</li></ul><p>如果带有调试信息，是debug版本，那么会显示：</p><pre><code>Reading symbols from test...</code></pre><p>也就是比不带有调试信息的少一行<code>(No debugging symbols found in test)</code>提示。</p><ol start="2"><li>使用 readelf 命令</li></ol><p>还可以使用命令readlef查看可执行文件是否带有调试功能。</p><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果其不是debug版本，不带有调试信息，那么不会显示任何内容。</p><ul><li>带有调试信息（debug）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果是debug版本，带有调试信息，那么类似于以下的内容：</p><pre><code>[28] .debug_aranges    PROGBITS         0000000000000000  0000303b[29] .debug_info       PROGBITS         0000000000000000  0000306b[30] .debug_abbrev     PROGBITS         0000000000000000  00005429[31] .debug_line       PROGBITS         0000000000000000  000059df[32] .debug_str        PROGBITS         0000000000000000  00005b41[33] .debug_line_str   PROGBITS         0000000000000000  00006cfb</code></pre><p>总之带调试信息的会显示内容，不带调试信息的不显示任何内容。</p><h1>2. GDB 命令汇总</h1><table><thead><tr><th>指令</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td><code>l</code></td><td><code>list</code></td><td>显示对应的代码，每次10行。可以指定行号或函数名。</td></tr><tr><td><code>r</code></td><td><code>run</code></td><td>无断点直接运行到底，有断点就运行到下一个断点然后停止。</td></tr><tr><td><code>b</code></td><td><code>breakpoint</code></td><td>在指定行号或函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:函数名</code></td><td><code>breakpoint</code></td><td>在该函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:行号</code></td><td><code>breakpoint</code></td><td>在该源文件中的指定行号打上断点。</td></tr><tr><td><code>info b</code></td><td><code>info breakpoints</code></td><td>查看断点的信息。</td></tr><tr><td><code>d</code></td><td><code>delete</code></td><td>删除指定编号的断点。</td></tr><tr><td><code>d breakpoints</code></td><td><code>delete breakpoints</code></td><td>删除所有的断点。</td></tr><tr><td><code>disable b</code></td><td><code>disable breakpoints</code></td><td>使所有断点无效。</td></tr><tr><td><code>disable b 编号</code></td><td><code>disable breakpoint</code></td><td>使指定编号的断点无效。</td></tr><tr><td><code>enable b</code></td><td><code>enable breakpoints</code></td><td>使所有断点有效。</td></tr><tr><td><code>enable b 编号</code></td><td><code>enable breakpoint</code></td><td>使指定编号的断点有效。</td></tr><tr><td><code>n</code></td><td><code>next</code></td><td>逐过程。</td></tr><tr><td><code>s</code></td><td><code>step</code></td><td>单步调试。</td></tr><tr><td><code>bt</code></td><td><code>backtrace</code></td><td>查看函数调用。</td></tr><tr><td><code>set var</code></td><td><code>set variable</code></td><td>修改变量的值。</td></tr><tr><td><code>p</code></td><td><code>print</code></td><td>打印变量的值。</td></tr><tr><td><code>display</code></td><td><code>display</code></td><td>追踪变量，每次停下来都显示它的值。</td></tr><tr><td><code>undisplay</code></td><td><code>undisplay</code></td><td>取消追踪。</td></tr><tr><td><code>until</code></td><td><code>until</code></td><td>继续执行，直至下一个断点处停止。</td></tr><tr><td><code>finish</code></td><td><code>finish</code></td><td>单步跳出，执行完当前所在函数后停止。</td></tr><tr><td><code>c</code></td><td><code>continue</code></td><td>从一个断点处，直接运行至下一个断点处。</td></tr></tbody></table><h1>3. GDB调试实践</h1><h2 id="3-1-编译出debug版本的二进制可执行文件">3.1 编译出debug版本的二进制可执行文件</h2><p>以下是将要用于调试的C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，用于计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，用于演示指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pointerDemo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *ptr = <span class="number">100</span>; <span class="comment">// 修改指针指向的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">factorial</span>(num); <span class="comment">// 计算阶乘</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Factorial of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;value;</span><br><span class="line">    <span class="built_in">pointerDemo</span>(ptr); <span class="comment">// 演示指针操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value after pointerDemo: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个简单的循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Loop iteration: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态内存分配</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放动态内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> test.cpp -g</span><br></pre></td></tr></table></figure><p>进行编译可得带调试信息的二进制可执行文件test。</p><h2 id="3-2-启动GDB">3.2 启动GDB</h2><p>可以使用gdb [要调试的二进制可执行文件名称]如gdb test来启动gdb调试，此时会进入gdb的命令行。也可以直接输入gdb回车进入gdb命令行后输入file test后回车来调试test。</p><h2 id="3-3-部分命令详解">3.3 部分命令详解</h2><h3 id="3-3-1-list">3.3.1 list</h3><p>简写为l（小写L），输入后便会展示10行代码，第一次使用会随机展示连续的10行代码。</p><p>如果输入<code>l [函数名]</code>，那么就会展示函数名所在的上面5行和包括函数名所在行在内的下面5行，至少10行。</p><p>如果输入<code>l [行号]</code>，那么就会展示那行代码所在的上面5行和包括那行行在内的下面5行，至少10行。</p><p>如果继续按住<code>Enter</code>，那么会展示接下来的几行代码。因为gdb会自动记忆你上次敲入的指令。</p><h3 id="3-3-2-breakpoint（插入断点）">3.3.2 breakpoint（插入断点）</h3><p>简写为b。</p><pre><code>b 行号 —— 在那一行打断点</code></pre><p>如<code>b 20</code>就是在第20行打上断点。</p><pre><code>b 源文件：函数名 —— 在该函数的第一行打上断点</code></pre><p>如<code>b test.cpp: main</code>就是在源文件的该函数的第一行打上断点。</p><pre><code>b 源文件：行号 —— 在该源文件中的这行加上一个断点</code></pre><p>如<code>b test.cpp: 20</code>就是在源文件的第20行打上断点。</p><h3 id="3-3-3-info">3.3.3 info</h3><p>直接执行info命令，就会显示所有的调试信息。</p><pre><code>info b —— 查看断点的信息</code></pre><p>info b会展示以下信息：</p><pre><code>Num —— 编号Type —— 类型Disp —— 状态Enb —— 是否可用Address —— 地址What —— 在此文件的哪个函数以及此文件的第几行</code></pre><h3 id="3-3-4-删除断点">3.3.4 删除断点</h3><pre><code>d 编号 —— 删除此编号的断点d —— 删除所有断点</code></pre><h3 id="3-3-5-开启-禁用断点">3.3.5 开启/禁用断点</h3><pre><code>disable b —— 使所有断点无效disable b 编号 —— 使此编号的断点无效enable b —— 使所有断点有效enable b 编号 —— 使此编号的断点有效</code></pre><h3 id="3-3-6-run">3.3.6 run</h3><p>简写为r，无断点直接运行到底，有断点就运行到下一个断点然后停止。</p><h3 id="3-3-7-逐过程-和-单步调试">3.3.7 逐过程 和 单步调试</h3><p>next简写为n，为逐过程，会一行一行地执行源文件中的代码。</p><p>step简写为s，为单步调试，也是一行一行地执行源文件中的代码，不同的是，它还会跳转库函数的代码。</p><h3 id="3-3-8-打印-和-追踪">3.3.8 打印 和 追踪</h3><p>print简写为p，为打印</p><pre><code>p 变量名 —— 打印变量值</code></pre><p>display，为追踪</p><pre><code>display 变量名 —— 追踪查看一个变量，每次停下来都显示它的值</code></pre><p>undisplay为取消追踪</p><pre><code>undisplay + 变量名编号 —— 取消对该编号变量的跟踪</code></pre><h3 id="3-3-9-bt">3.3.9 bt</h3><p>bt命令用于查看当前调用了哪些函数。</p><h3 id="3-3-10-修改变量的值">3.3.10 修改变量的值</h3><pre><code>set var —— 修改变量的值</code></pre><p>如<code>set var i = 0</code>就是将变量i的值设为0。</p><h3 id="3-3-11-until">3.3.11 until</h3><pre><code>until 行号 —— 继续执行当前代码，直到执行到该行号为止。</code></pre><h3 id="3-3-12-finish">3.3.12 finish</h3><pre><code>finish —— 执行完当前所在函数后停止。</code></pre><p>finish应该就是单步跳出了。</p><h3 id="3-3-13-continue">3.3.13 continue</h3><p>简写为c。</p><pre><code>c —— 继续执行，直至下一个断点处停止。</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ 那些事儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值引用 与 右值引用</title>
      <link href="/2025/03/05/cpp-interview3/"/>
      <url>/2025/03/05/cpp-interview3/</url>
      
        <content type="html"><![CDATA[<p>来复习总结一下左值引用与右值引用。</p><p>左值引用和右值引用是 C++ 中用于管理对象生命周期的两种引用类型，主要区别在于它们绑定的对象类型和使用场景</p><h1>左值引用（Lvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp; 声明的引用，只能绑定到 左值（有名字、有内存地址的对象）。</p><ol start="2"><li>特点</li></ol><ul><li>左值对象通常可以被修改（除非被 const 修饰）。</li><li>常用于函数参数传递（避免拷贝）或为现有对象起别名。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref_a = a;  <span class="comment">// 正确：左值引用绑定左值</span></span><br><span class="line"><span class="comment">// int&amp; ref_b = 10;  // 错误：不能绑定到右值（字面量）</span></span><br></pre></td></tr></table></figure><h1>右值引用（Rvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp;&amp; 声明的引用，只能绑定到 右值（临时对象、字面量、即将销毁的对象）。<br>2. 特点</p><ul><li>C++11 引入，用于实现<code>移动语义</code>和<code>完美转发</code>。</li><li>允许“窃取”右值的资源（如动态内存），避免不必要的拷贝。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span>;  <span class="comment">// 正确：右值引用绑定右值</span></span><br><span class="line"><span class="comment">// int&amp;&amp; rref2 = a;  // 错误：不能直接绑定左值</span></span><br></pre></td></tr></table></figure><h1>左值引用与右值引用的区别</h1><table><thead><tr><th>特性</th><th>左值引用 (&amp;)</th><th>右值引用 (&amp;&amp;)</th></tr></thead><tbody><tr><td>绑定对象类型</td><td>左值（持久对象）</td><td>右值（临时对象）</td></tr><tr><td>可修改性</td><td>允许修改（除非 const）</td><td>允许修改</td></tr><tr><td>主要用途</td><td>避免拷贝、别名</td><td>移动语义、完美转发</td></tr></tbody></table><h1>应用场景</h1><ol><li>移动语义（Move Semantics）</li></ol><p>右值引用允许将资源（如堆内存）从临时对象“移动”到新对象，避免深拷贝。</p><p>假设有一个管理动态数组的类 MyArray：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyArray</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当发生拷贝时（如 MyArray b = a），默认的拷贝构造函数会执行浅拷贝，导致两个对象共享同一块内存，引发双重释放等问题。为此，我们需要：</p><ul><li>深拷贝：显式实现拷贝构造函数，复制数据（安全但性能差）。</li><li>移动语义：直接“窃取”临时对象的资源（高效且安全）。</li></ul><p>移动语义的<code>核心机制</code><br>（1）右值引用（&amp;&amp;）<br>右值引用只能绑定到右值（临时对象、字面量、std::move 转换后的对象）。<br>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp;&amp; rref = <span class="built_in">MyArray</span>(<span class="number">100</span>);  <span class="comment">// 绑定到临时对象（右值）</span></span><br></pre></td></tr></table></figure><p>（2）移动构造函数和移动赋值运算符</p><ul><li>移动构造函数：接受右值引用参数，直接转移资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyArray</span>(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">    : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">    other.size_ = <span class="number">0</span>;        <span class="comment">// 原对象置空</span></span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;   <span class="comment">// 防止原对象析构时释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动赋值运算符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp; <span class="keyword">operator</span>=(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;      <span class="comment">// 释放当前资源</span></span><br><span class="line">        data_ = other.data_; <span class="comment">// 窃取资源</span></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么何时会触发移动语义？</p><p>场景 1：传递临时对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">createArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">arr</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> arr;  <span class="comment">// 返回时，arr 是右值，触发移动构造函数（而非拷贝）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray a = <span class="built_in">createArray</span>();  <span class="comment">// 移动构造</span></span><br></pre></td></tr></table></figure><p>场景 2：显式使用 std::move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);  <span class="comment">// 将左值 a 转为右值，触发移动构造</span></span><br><span class="line"><span class="comment">// 此时 a.data_ = nullptr，a 不可再使用！</span></span><br></pre></td></tr></table></figure><p>场景 3：标准库优化（如 vector::push_back）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;MyArray&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">MyArray</span>(<span class="number">1000</span>));  <span class="comment">// 传递右值，触发移动构造</span></span><br></pre></td></tr></table></figure><ol start="2"><li>完美转发（Perfect Forwarding）</li></ol><p>结合 std::forward 保持参数的值类别（左值/右值），是 C++ 中实现完美转发的核心机制，用于泛型编程。</p><p>假设你写了一个泛型包装函数 wrapper，它需要将参数传递给另一个函数 process：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);   <span class="comment">// 直接传递arg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里有一个问题：无论 arg 原始是左值还是右值，在 wrapper 内部，arg 始终是左值（因为它有名字，可以取地址）。因此，process 永远只能收到左值，无法触发右值重载的优化（如移动语义）。</p><p>使用std::forward可以解决这个问题。std::forward的作用是根据模板参数 T 的类型，有条件地将参数转换为左值或右值。修改后的 wrapper：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持 arg 的原始值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时：</p><ul><li>如果 arg 原始是左值，std::forward<T> 返回左值引用。</li><li>如果 arg 原始是右值，std::forward<T> 返回右值引用，从而允许移动语义。</li></ul><p>举个栗子：</p><p>定义两个 process 重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理左值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理右值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况 1：不使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);  <span class="comment">// arg 始终是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bad_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">bad_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理左值: 20 （但 20 是右值！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论传入左值还是右值，arg 在 bad_wrapper 内部都是左值，导致右值无法触发移动优化。</p><p>情况 2：使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持原始值类别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">good_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">good_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理右值: 20 （正确触发右值重载！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 std::forward 根据传入参数的值类别，正确选择 process 的左值或右值版本。</p><p>那么 std::forward 是如何做到的呢？是靠引用折叠规则。</p><p>引用折叠规则<br>当模板参数 T 推导为左值或右值时，T&amp;&amp; 会触发引用折叠：</p><ul><li>如果 T 是 X&amp;（左值引用），T&amp;&amp; 折叠为 X&amp;（仍是左值引用）。</li><li>如果 T 是 X 或 X&amp;&amp;，T&amp;&amp; 变为 X&amp;&amp;（右值引用）。</li></ul><p>简化版的 std::forward 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 T 是左值引用（如 int&amp;），T&amp;&amp; 折叠为 int&amp;，返回左值引用。</li><li>如果 T 是普通类型（如 int），T&amp;&amp; 是 int&amp;&amp;，返回右值引用。</li></ul><ol start="3"><li>优化临时对象</li></ol><p>通过 std::move 将左值显式转换为右值引用，触发移动操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; v1;</span><br><span class="line">std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s));  <span class="comment">// 移动 s 的资源到 vector，s 变为空</span></span><br></pre></td></tr></table></figure><h1>注意事项</h1><ol><li>右值引用本身是左值<br>右值引用变量有名字，因此是左值。若需继续传递右值，需用 std::move</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 是左值（有名字），若需传递给其他函数，需转为右值</span></span><br><span class="line">    <span class="built_in">another_process</span>(std::<span class="built_in">move</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>避免滥用 std::move<br>对局部变量使用 std::move 可能导致意外悬空引用。</li></ol><p>移动后的对象处于有效但未定义状态（通常被置空）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="comment">// a.data_ 变为 nullptr，不可再访问 a 的数据！</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>std::move 的本质<br>std::move 只是将对象强制转换为右值引用，本身不执行任何移动操作。真正的资源转移在移动构造函数或移动赋值运算符中完成。</p></li><li><p>异常安全<br>移动操作应标记为 noexcept，否则某些标准库操作（如 vector 扩容）可能回退到拷贝语义。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 里的 lower_bound 和 upper_bound</title>
      <link href="/2025/03/04/chores1/"/>
      <url>/2025/03/04/chores1/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，lower_bound 和 upper_bound 是标准库 <algorithm> 中提供的两个非常实用的函数，用于在已排序的序列中进行二分查找。它们的功能和用法非常相似，但在细节上有一些区别。</p><h1>使用条件</h1><p>由于 lower_bound 和 upper_bound 底层是基于二分查找的，故lower_bound 和 upper_bound 都要求输入的序列是已排序的（默认是升序）。</p><h1>lower_bound 的功能</h1><p>lower_bound 用于在已排序的序列中查找第一个大于或等于目标值的元素的位置。通俗地讲，就是在这个序列中为目标值找一个位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于或等于 value 的元素的迭代器。如果所有元素都小于 value，则返回 last。</li></ul><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt;= 6 is 7 at index 3</code></pre><h1>upper_bound 的功能</h1><p>upper_bound 用于在已排序的序列中查找第一个大于目标值的元素的位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于 value 的元素的迭代器。如果所有元素都小于或等于 value，则返回 last。</li></ul><p>参数与lower_bound相同，返回值就不同了。</p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt; 6 is 7 at index 3</code></pre><h1>lower_bound 和 upper_bound 的区别</h1><table><thead><tr><th>特性</th><th><code>lower_bound</code></th><th><code>upper_bound</code></th></tr></thead><tbody><tr><td><strong>查找条件</strong></td><td>第一个 <strong>大于或等于</strong> 目标值的元素</td><td>第一个 <strong>大于</strong> 目标值的元素</td></tr><tr><td><strong>返回值</strong></td><td>指向第一个满足条件的元素的迭代器</td><td>指向第一个满足条件的元素的迭代器</td></tr><tr><td><strong>目标值存在时</strong></td><td>返回目标值的第一个位置</td><td>返回目标值的下一个位置</td></tr><tr><td><strong>目标值不存在时</strong></td><td>返回第一个大于目标值的位置</td><td>返回第一个大于目标值的位置</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C/C++ 那些事儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划六：最长递增子序列</title>
      <link href="/2025/03/04/dp6/"/>
      <url>/2025/03/04/dp6/</url>
      
        <content type="html"><![CDATA[<p>今日学习灵茶山艾府出品的<a href="https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">最长递增子序列【基础算法精讲 20】</a>。</p><p>UP通过Leetcode官方题<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列</a>进行讲解。</p><h1>300. 最长递增子序列</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p><code>子序列</code>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><h1>基本思路</h1><p>由于子序列是数组的一个子集，因此用子集型回溯来思考，也就是[选或不选]或者[枚举选哪个]。</p><p>对于nums = [1, 6, 7, 2, 4, 5, 3]：</p><ul><li>如果我们倒着思考，假设3是严格递增子序列中的最后一个数，考虑选或不选，需要与前面的数字进行比较，需要知道当前数的下标以及上一个数的下标。</li><li>如果考虑枚举选哪个，可以直接枚举3前面比3小的数字，当作严格递增子序列的倒数第二个数，只需要知道当前数字的下标即可。</li></ul><p>经过对比，枚举选哪个的思路只需要一个参数，更方便。</p><p>因此最终的思路为：<br>- 枚举以nums[i]结尾的严格递增子序列的长度<br>- 接着需要枚举以nums[j]为倒数第二个元素的严格递增子序列的长度<br>- 其中j &lt; i，nums[j] &lt; nums[i]</p><p>以下是灵茶山艾府总结的回溯三问：</p><ul><li>子问题？以nums[i]结尾的严格递增子序列的长度</li><li>当前操作？枚举nums[j]</li><li>下一个子问题？以nums[j]结尾的严格递增子序列的长度</li></ul><p>定义dfs(i)为以nums[i]结尾的严格递增子序列的长度，枚举满足要求的nums[j]，子问题就变成了以nums[j]结尾的严格递增子序列的长度，这些子问题求个最大值再+1，就得到了以nums[i]结尾的严格递增子序列的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i) = max&#123;dfs(j)&#125; + 1， j &lt; i &amp;&amp; nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure><h1>递归</h1><p>递归实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// dfs(i)表示以nums[i]结尾的严格递增子序列的长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(j), res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ++res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，一定要将i = 0 ~ n - 1当参数传给dfs，也就是最后的循环里挨个调用。如果直接dfs(n-1)的话，只有当j &lt; i &amp;&amp; nums[j] &lt; nums[i]的时候才能递归到其他状态，可能会导致0~n-2中的某些递归不到。并且dfs(n-1)的意义是以nums[n-1]结尾的严格递增子序列的长度，但是最长的严格递增子序列并不一定以nums[n-1]结尾，也可能是以前面的某个数字结尾。</p><h1>递推</h1><p>递归很容易翻译成递推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++f[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>贪心 + 二分</h1><p>这一块开始听不懂了，主要感觉灵茶山艾府的证明不是很清晰。</p><p>通过贪心 + 二分查找求解<code>最长严格递增子序列（LIS）</code>问题的核心思想是：<code>尽可能地让递增子序列的末尾元素更小，从而为后续的元素提供更多的扩展机会</code>。</p><h2 id="贪心思想">贪心思想</h2><p>贪心算法的核心是：在每一步选择中，都采取当前最优的策略，从而希望最终得到全局最优解。</p><p>在这个问题中，我们希望找到一个尽可能长的递增子序列。为了达到这个目标，我们需要让子序列的末尾元素尽可能小，因为较小的末尾元素更容易被后续的元素扩展。</p><p>因此，贪心策略是<code>对于相同长度的递增子序列，我们只保留末尾元素最小的那个</code>。</p><p>g[i] 表示长度为 i+1 的递增子序列的最小末尾元素</p><h2 id="二分查找的作用">二分查找的作用</h2><p>对于每个新元素 num，我们需要找到它在 g 中的位置：</p><ul><li>如果 num 比 g 中的所有元素都大，说明它可以扩展当前的最长递增子序列，因此将其添加到 g 的末尾。</li><li>否则，找到 g 中第一个大于等于 num 的位置 pos，并用 num 替换 g[pos]。这是因为 num 可以作为一个更小的末尾元素来构成长度为 pos+1 的递增子序列。</li></ul><p>通过二分查找，我们可以在 O(log n) 的时间内找到 num 应该插入或替换的位置，从而保证算法的高效性。</p><h2 id="为什么贪心-二分查找是正确的？">为什么贪心 + 二分查找是正确的？</h2><p>我们需要证明：通过贪心策略维护的数组 g，最终的长度就是最长递增子序列的长度。</p><p>关键点：</p><ol><li><p>g 的长度就是 LIS 的长度：</p><ul><li>每次向 g 中添加一个新元素时，都意味着我们发现了一个更长的递增子序列。</li><li>每次替换 g 中的元素时，只是优化了相同长度的递增子序列的末尾元素，而不会改变 g 的长度。</li></ul></li><li><p>g 的严格递增性：</p><ul><li>由于我们总是用更小的元素替换 g 中的元素，g 始终保持严格递增。</li><li>这种性质保证了我们可以通过二分查找快速定位 num 应该插入或替换的位置。</li></ul></li><li><p>替换操作不会影响最终结果：</p><ul><li>当我们用 num 替换 g[pos] 时，虽然我们改变了长度为 pos+1 的递增子序列的末尾元素，但这并不影响更长递增子序列的构建。</li><li>因为 num 比原来的 g[pos] 更小，它为后续的元素提供了更多的扩展机会。</li></ul></li></ol><h2 id="一个例子">一个例子</h2><p>假设 nums = [10, 9, 2, 5, 3, 7, 101, 18]，我们通过贪心 + 二分查找来求解：</p><ul><li>初始化 g = []。</li><li>遍历 nums：<ol><li>num = 10：<ul><li>g 为空，直接添加：g = [10]。</li></ul></li><li>num = 9：<ul><li>找到第一个大于等于 9 的位置是 0，替换：g = [9]。</li></ul></li><li>num = 2：<ul><li>找到第一个大于等于 2 的位置是 0，替换：g = [2]。</li></ul></li><li>num = 5：<ul><li>5 比 g 中的所有元素都大，添加到末尾：g = [2, 5]。</li></ul></li><li>num = 3：<ul><li>找到第一个大于等于 3 的位置是 1，替换：g = [2, 3]。</li></ul></li><li>num = 7：<ul><li>7 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7]。</li></ul></li><li>num = 101：<ul><li>101 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7, 101]。</li></ul></li><li>num = 18：<ul><li>找到第一个大于等于 18 的位置是 3，替换：g = [2, 3, 7, 18]。</li></ul></li></ol></li></ul><p>最终，g 的长度是 4，因此最长递增子序列的长度是 4。</p><p>这种方法的时间复杂度是 O(n log n)，空间复杂度是 O(n)，是一种非常高效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心 + 二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;num: nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), num);</span><br><span class="line">            <span class="keyword">if</span> (it == g.<span class="built_in">end</span>())</span><br><span class="line">                g.<span class="built_in">emplace_back</span>(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>变形</h1><p>如果允许最长递增子序列中有重复元素，那么按照<code>贪心+二分</code>的思路，在g中需要寻找的就是第一个大于（原来是大于等于）num的位置，也就是把原来使用的lower_bound改成upper_bound即可。</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 集成Element-Plus</title>
      <link href="/2025/03/04/project-test2/"/>
      <url>/2025/03/04/project-test2/</url>
      
        <content type="html"><![CDATA[<p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1GLKweAEHj/?spm_id_from=333.1245.0.0">【带小白做毕设】02. 使用Vue3集成Element-Plus快速搭建一个管理系统的页面</a>并进行一个学习记录。</p><h1>Element-Plus</h1><p>Element-Plus 是一套前端 UI 框架，提供了许多精美的样式，Ctrl-C + Ctrl-V即可使用。<a href="https://element-plus.org/zh-CN/">官网跳转</a>。</p><p>使用以下命令安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-plus -S</span><br></pre></td></tr></table></figure><p>在main.js中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/css/global.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>) <span class="comment">// 这一行</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后直接从官网找到以下代码粘贴到Home.vue体验：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    主页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span>&gt;</span>Info<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span>&gt;</span>Warning<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span>&gt;</span>Danger<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1>使用 icon</h1><p>首先安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @element-plus/icons-vue</span><br></pre></td></tr></table></figure><p>然后需要从 @element-plus/icons-vue 中导入所有图标并进行全局注册：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您正在使用CDN引入，请删除下面一行。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ElementPlusIconsVue</span> <span class="keyword">from</span> <span class="string">&#x27;@element-plus/icons-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, component] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="title class_">ElementPlusIconsVue</span>)) &#123;</span><br><span class="line">  app.<span class="title function_">component</span>(key, component)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环部分放在main.js的末尾即可。</p><p>然后就可以从官网复制一个icon放到Home.vue中即可使用icon了。</p><p>使用图标:</p><ul><li>el-input：当你在输入框组件里面使用图标，你需要单独导入图标</li><li>el-icon、el-button：按钮或者图标组件里面，不需要单独导入图标</li></ul><h1>Element-Plus 主题色设置</h1><p>安装依赖 sass、unplugin-vue-components、unplugin-auto-import</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D sass unplugin-vue-components unplugin-auto-import</span><br></pre></td></tr></table></figure><p>配置index.scss放在 src/assets/css 目录下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@forward <span class="string">&quot;element-plus/theme-chalk/src/common/var.scss&quot;</span> <span class="title function_">with</span>(</span><br><span class="line">    <span class="attr">$colors</span>:(</span><br><span class="line">            <span class="string">&quot;primary&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #2c82ff),</span><br><span class="line">            <span class="string">&quot;success&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #31bf00),</span><br><span class="line">            <span class="string">&quot;warning&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #ffade0),</span><br><span class="line">            <span class="string">&quot;danger&quot;</span>:   (<span class="string">&quot;base&quot;</span>:  #e52f2f), </span><br><span class="line">            <span class="string">&quot;info&quot;</span>:     (<span class="string">&quot;base&quot;</span>: #8855ff),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置vite.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span><span class="string">&#x27;unplugin-auto-import/vite&#x27;</span><span class="comment">//自动导入vue中的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span><span class="comment">//自动导入ui-组件 比如 element-plus等</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span><span class="comment">//对应组件引入</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line"><span class="comment">//element-plus按简导入</span></span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [</span><br><span class="line">            <span class="comment">//配置elementPlus采用sass样式配置系统</span></span><br><span class="line">            <span class="title class_">ElementPlusResolver</span>(&#123;<span class="attr">importStyle</span>:<span class="string">&quot;sass&quot;</span>&#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="attr">css</span>:&#123;</span><br><span class="line">  <span class="attr">preprocessorOptions</span>:&#123;</span><br><span class="line">    <span class="attr">scss</span>: &#123;</span><br><span class="line">      <span class="attr">additionalData</span>: <span class="string">`@use&quot;@/assets/css/index.scss&quot; as *;`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1>创建后台基本框架</h1><p>创建vue/src/views/Manager.vue文件</p>]]></content>
      
      
      <categories>
          
          <category> Java 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> Element-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端 Vue3 框架搭建</title>
      <link href="/2025/03/04/project-test1/"/>
      <url>/2025/03/04/project-test1/</url>
      
        <content type="html"><![CDATA[<p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV16dKHeiE92?spm_id_from=333.788.videopod.sections&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】01. 前端Vue3 框架的快速搭建以及项目工程的讲解</a>并进行一个学习记录。</p><h1>安装NodeJS</h1><p>vue3 建议 nodejs v22.14.0，npm 版本 10.9.2<br>使用安装包安装nodejs时，会自动配置Node和npm的环境变量。<br>npm要配置淘宝镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h1>搭建Vue工程</h1><p>创建一个工程目录（我就叫它Project吧），在工程目录下打开CMD，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure><p>然后会让你输入项目名称，我起名为vue。</p><p>紧接着会让你选择<br>√ 是否使用 TypeScript 语法？ 选否<br>√ 是否启用 JSX 支持？ 选否<br>√ 是否引入 Vue Router 进行单页面应用开发？ 选是<br>√ 是否引入 Pinia 用于状态管理？ 选否<br>√ 是否引入 Vitest 用于单元测试？ 选否<br>√ 是否要引入一款端到端（End to End）测试工具？ » 选不需要<br>√ 是否引入 ESLint 用于代码质量检测？ » 选否</p><p>也就是除了“是否引入 Vue Router 进行单页面应用开发？”选是以外，其余均选择否或者不需要。</p><p>然后会提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目初始化完成，可执行以下命令：</span><br><span class="line"></span><br><span class="line">  cd vue</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure><p>输入<code>cd vue</code>，进入vue的工程目录。</p><p>然后输入<code>npm install</code>安装依赖，并且会有类似提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">added 147 packages <span class="keyword">in</span> 20s</span><br><span class="line"></span><br><span class="line">43 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p>再输入<code>npm run dev</code>即可运行这个vue项目，会有提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VITE v6.2.0  ready <span class="keyword">in</span> 585 ms</span><br><span class="line"></span><br><span class="line">➜  Local:   http://localhost:5173/</span><br><span class="line">➜  Network: use --host to expose</span><br><span class="line">➜  Vue DevTools: Open http://localhost:5173/__devtools__/ as a separate window</span><br><span class="line">➜  Vue DevTools: Press Alt(⌥)+Shift(⇧)+D <span class="keyword">in</span> App to toggle the Vue DevTools</span><br><span class="line">➜  press h + enter to show <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>在浏览器中输入网址：<a href="http://localhost:5173/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E8%BF%99%E4%B8%AAvue%E9%A1%B9%E7%9B%AE%E3%80%82">http://localhost:5173/，即可查看这个vue项目。</a></p><h1>Vue 工程精简</h1><p>使用idea打开Project目录（也就是上面vue工程目录的上一级目录）。</p><p>目前工程目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─.idea</span><br><span class="line">└─vue</span><br><span class="line">    ├─.vscode</span><br><span class="line">    ├─node_modules</span><br><span class="line">    ├─public</span><br><span class="line">    ├─src</span><br><span class="line">    │   ├─assets</span><br><span class="line">    │   ├─components</span><br><span class="line">    │   │  └─icons</span><br><span class="line">    │   ├─router</span><br><span class="line">    │   └─views</span><br><span class="line">    ├─.gitignore</span><br><span class="line">    ├─index.html</span><br><span class="line">    ├─jsconfig.json</span><br><span class="line">    ├─package.json</span><br><span class="line">    ├─package-lock.json</span><br><span class="line">    ├─README.md</span><br><span class="line">    └─vite.config.js</span><br></pre></td></tr></table></figure><p>.vscode、.gitignore、README.md三个文件不需要，直接删除。</p><p>找到设置，输入enc，点击<code>File Encodings</code>，把global Encodings、Project Encodings、Default encoding for properties files全部设为<code>UTF-8</code>，并勾选Transparent native-to-ascii conversion。</p><p>还有一些文件也是不需要的，继续删除以下文件：</p><ul><li>vue/src/assets目录下的base.css、main.css</li><li>vue/src/components下的所有文件和文件夹</li><li>vue/src/views 目录下的AboutView.vue</li></ul><p>将vue/src/views/HomeView.vue的内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        主页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>并将HomeView.vue重命名为Home.vue</p><p>将vue/src/App.vue的内容编辑为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;RouterView /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>vue/src/router/index.js的内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vue/src/main.js的第一行有对vue/src/assets/main.css的导入，但是其已被我们删除，故将这一行删除。</p><h1>Vue 工程目录解读</h1><ul><li>node_modules：依赖包存放文件</li><li>public：存放全局静态文件</li><li>src：<ul><li>assets：存放代码引用的静态文件，css、js等</li><li>components：存放vue的组件（可复用代码块）</li><li>router：存放路由文件的目录</li><li>views：存放vue网页的目录</li><li>App.vue：vue页面全局入口</li><li>main.js：全局的配置文件，引入第三方的组件或者自定义的组件</li></ul></li><li>index.html：vue编译成的网页</li><li>package.json：定义依赖库的文件</li><li>package-lock.json：安装依赖时用于锁定版本的文件</li><li>vite.config.js：全局的配置文件</li></ul><h1>全局css</h1><p>在vue/src/assets目录下新建css目录，再在css目录下新建global.css文件（全局样式表），内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    box-<span class="attr">sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    <span class="attr">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">color</span>: #<span class="number">333</span>;</span><br><span class="line">    font-<span class="attr">size</span>: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">    text-<span class="attr">decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在main.js文件中引用，添加这行代码即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/css/global.css&#x27;</span></span><br></pre></td></tr></table></figure><h1>定义404页面</h1><p>将一张404的图片放在vue/src/assets/imgs目录下，在vue/src/views目录下新建404.vue，编辑内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div style=&quot;height: 100vh; display: flex; align-items: center; justify-content: center&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;img style=&quot;width: 100%&quot; src=&quot;@/assets/imgs/404.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;div style=&quot;text-align: center; padding: 20px 0; font-size: 20px; color: #3741fb&quot;&gt;&lt;a href=&quot;/&quot;&gt;返回主页&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后定义路由，在vue/src/router/index.js文件中一行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),&#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/notFount&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/404.vue&#x27;</span>),&#125;, <span class="comment">// 添加的那行代码</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>此时访问<a href="http://localhost:5174/notFount%E5%B0%B1%E4%BC%9A%E8%B7%B3%E8%BD%AC%E5%88%B0404%E9%A1%B5%E9%9D%A2%E3%80%82%E4%BD%86%E5%85%B6%E5%AE%9E%E6%88%91%E4%BB%AC%E6%83%B3%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%98%AF%E5%8F%AA%E8%A6%81%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B7%AF%E7%94%B1%E5%B0%B1%E8%B7%B3%E8%BD%AC404%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:5174/notFount就会跳转到404页面。但其实我们想实现的是只要访问一个未定义的路由就跳转404页面。</a></p><p>只需要再在index.js中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/notFound&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Java 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针模板类：auto_ptr，shared_ptr，unique_ptr</title>
      <link href="/2025/03/03/cpp-interview2/"/>
      <url>/2025/03/03/cpp-interview2/</url>
      
        <content type="html"><![CDATA[<p>今日通过阅读《c++ Primer Plus》来学习一下智能指针。部分内容参考<a href="https://blog.csdn.net/weixin_45031801/article/details/140594215">【C++11】智能指针深度详解（什么是智能指针？为什么需要智能指针？如何使用智能指针？）</a>（CSDN博客链接，点击即可跳转）。</p><h1>What is it ?</h1><p><code>智能指针</code>这个名词听着挺唬人，其实也没啥，无非就是会自动销毁 new 出来的对象，避免内存泄漏。毕竟 C/C++ 没有类似<code>Java</code>的垃圾回收机制，需要手动释放 new 出来的对象，<code>智能指针</code>可以自动地完成这个工作。</p><h1>Why ? 为什么需要智能指针？</h1><p>先看这个函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string* ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的缺陷就是忘了释放new出来的内存，但是只要别忘了return前加上<code>delete ps</code>释放内存。</p><p>但是但凡是涉及<code>别忘了</code>的解决方法，往往不佳。即使没有忘记，依然可能出现问题，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string* ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现异常时，将不会执行delete ps，导致内存泄漏。</p><p>当remodel()这样的函数终止(不管是正常终止，还是由于出现了异常而终止)，本地变量都将从栈内存中删除，因此指针ps占据的内存将被释放。</p><p>如果ps指向的内存也被释放，就nice了。</p><p>如果ps有一个<code>析构函数</code>，该析构函数将在ps过期时释放它指向的内存。如果ps是对象，则可以在对象过期时，让它的析构函数删除指向的内存。这正是为什么出现<code>auto_ptr</code>、<code>unique_ptr</code>和<code>shared _ptr</code>的原因了。</p><h1>使用智能指针</h1><p>要创建智能指针对象，就得包含头文件memory。</p><p>模板auto_ptr的构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="explicit">explicit</h2><p><code>explicit</code>关键字用于<code>禁止隐式类型转换</code>。</p><ol><li><p>隐式转换是什么？<br>隐式转换是指编译器在不需要显式调用构造函数或转换函数的情况下，自动将一种类型转换为另一种类型。<br>例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 隐式调用 MyClass(10)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，func(10) 会自动调用 MyClass(int x) 构造函数，将 int 隐式转换为 MyClass 对象。</p></li><li><p>隐式转换在<code>auto_ptr</code>中的问题<br>假设 auto_ptr 的构造函数没有 explicit：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(X* p = <span class="number">0</span>) <span class="keyword">throw</span>() : <span class="built_in">ptr</span>(p) &#123;&#125; <span class="comment">// 没有 explicit</span></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">X* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    X* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// 隐式调用构造函数</span></span><br></pre></td></tr></table></figure><ul><li>发生了什么？<ol><li>new int(5) 返回一个 int* 类型的指针。</li><li>由于 auto_ptr 的构造函数没有 explicit，编译器会自动调用 auto_ptr<int>(int*) 构造函数，将 int* 隐式转换为 auto_ptr<int>。</li><li>最终，ap 是一个 auto_ptr<int> 对象，接管了 new int(5) 返回的指针。</li></ol></li></ul><ol start="3"><li><p>为什么隐式转换会导致问题？<br>隐式转换可能导致以下问题：<br>(1) 意外的所有权转移<br>auto_ptr 的核心特性是<code>独占所有权</code>，即一个 auto_ptr 对象独占一个资源，不能有多个 auto_ptr 对象同时管理同一个资源。</p><p>如果允许隐式转换，以下代码会导致意外的所有权转移：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// ap1 接管指针</span></span><br><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap2 = ap1;         <span class="comment">// ap1 的所有权转移到 ap2</span></span><br></pre></td></tr></table></figure><ul><li>在第二行，ap1 的所有权被转移到 ap2，ap1 变为空指针。</li><li>如果后续代码继续使用 ap1，会导致未定义行为（如访问空指针）。</li></ul></li></ol><p>(2) 资源管理问题<br>隐式转换可能导致资源泄漏或重复释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(auto_ptr&lt;<span class="type">int</span>&gt; ap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* raw_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(raw_ptr);  <span class="comment">// 隐式转换，raw_ptr 的所有权被转移</span></span><br><span class="line">    <span class="comment">// 此时 raw_ptr 已被释放，后续访问会导致未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>func(raw_ptr) 隐式调用了 auto_ptr<int>(int*) 构造函数，raw_ptr 的所有权被转移到 func 的参数 ap。</li><li>当 func 返回时，ap 被销毁，raw_ptr 指向的内存被释放。</li><li>如果后续代码继续使用 raw_ptr，会导致未定义行为。</li></ul><p>因此，通过将构造函数声明为 explicit，可以禁止隐式转换，强制要求显式调用构造函数。</p><h2 id="noexcept">noexcept</h2><p><code>noexcept</code>表示auto_ptr类的构造函数保证不会抛出任何异常。<br>如果函数声明了 noexcept 但实际上抛出了异常，程序会调用 std::unexpected()，通常导致程序终止。</p><h2 id="使用智能指针">使用智能指针</h2><p>继续回过头看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后申请X类型的auto_ptr将获得一个指向X类型的auto_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>; <span class="comment">// pd是一个指向double类型的auto_ptr</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string)</span></span>; <span class="comment">// ps是一个指向string的auto_ptr</span></span><br></pre></td></tr></table></figure><p>new double 是new 返回的指针，指向new出来的内存块。new double 是构造函数auto_ptr<double>的参数，对应于原型中形参p的实参。同样，new string也是构造函数的实参。其他两种智能指针的使用也是同样的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">double</span>&gt; <span class="title">pdu</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>; <span class="comment">// pd 是一个指向double的unique_ptr</span></span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">pss</span><span class="params">(<span class="keyword">new</span> string)</span></span>; <span class="comment">// pd 是一个指向string的shared_ptr</span></span><br></pre></td></tr></table></figure><p>要改造先前的remodel()函数，需要包含memory头文件、将指向string的指针改为指向string的智能指针、删除delete语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::string* ps = new std::string(str);</span></span><br><span class="line">    <span class="function">std::auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> std::string(str))</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="comment">// delete ps;</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于所有的智能指针类的构造函数都有<code>explicit</code>关键字修饰，该构造函数将指针作为参数，并且要显式地调用构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pd;</span><br><span class="line"><span class="type">double</span> *p_reg = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">pd = p_reg; <span class="comment">// 错误，使用了隐式转换</span></span><br><span class="line">pd = <span class="built_in">shared_ptr</span>&lt;<span class="type">double</span>&gt;(p_reg); <span class="comment">// 正确，显示转换</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pshared = p_reg; <span class="comment">// 错误，使用了隐式转换</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">double</span>&gt; <span class="title">pshared</span><span class="params">(p_reg)</span></span>;  <span class="comment">// 正确，显示转换</span></span><br></pre></td></tr></table></figure><p>此外，三类智能指针都应该避免一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vacation</span><span class="params">(<span class="string">&quot;I wandered lonely as a cloud.&quot;</span>&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">shared_ptr&lt;string&gt; pvac(&amp;vacation);</span></span></span><br></pre></td></tr></table></figure><p>pvac的生命周期时，自动释放其指向的内存，这回导致delete一个不是new出来的内存。</p><p>对于auto_ptr，对于以下赋值语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; vocation;</span><br><span class="line">vocation = ps;</span><br></pre></td></tr></table></figure><p>它有明显的bug，因为ps和vocation的生命周期结束时，ps的析构函数会将这块new出来的内存释放一次，vocation的析构函数又会再释放一次。</p><p>可以采用以下方法解决：</p><ul><li>重载赋值运算符，使用深拷贝</li><li>建立所有权的概念，对于特定的对象，只允许一个智能指针可以拥有它。这样只有拥有该对象的智能指针的析构函数会删除该对象。auto_ptr和unique_ptr采用此策略</li><li>创建更智能的指针，跟踪引用特定对象的智能指针的个数（称为引用计数）。例如，赋值时，计数将+1，而指针的生命周期结束时，计数-1。只有当最后一个指针的生命周期也结束时，才delete。shared_ptr采用此策略。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划五：线性DP</title>
      <link href="/2025/03/02/dp5/"/>
      <url>/2025/03/02/dp5/</url>
      
        <content type="html"><![CDATA[<p>今日继续学习灵茶山艾府的基础算法精讲系列中的<a href="https://www.bilibili.com/video/BV1TM4y1o7ug/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">最长公共子序列 编辑距离【基础算法精讲 19】</a>（本文内容参考该视频，点击即可跳转视频，非商业引用，侵权联系删）。</p><p>灵茶山艾府主要通过两道Leetcode题进行讲解：<a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a>和<a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离</a>。</p><h1>1143. 最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长<code>公共子序列</code>的长度。如果不存在<code>公共子序列</code>，返回 0 。</p><p>一个字符串的<code>子序列</code>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li></ul><p>两个字符串的<code>公共子序列</code>是这两个字符串所共同拥有的子序列。</p><p>公共子序列就是两个字符串都有的子序列，我们需要计算所有公共子序列中的最长长度。</p><p>把两个字符串分别设为s和t，长度设为n和m，和背包问题一样，子序列也是考虑每个字符<code>选或不选</code>，从最后一个字母开始考虑，s的最后一个字母设为x，t的最后一个字母设为y，分为四种情况：</p><ul><li>不选x，不选y</li><li>不选x，选y</li><li>选x，不选y</li><li>选x，选y</li></ul><p>上述是灵茶山艾府给出的启发思路，再来看看他总结的回溯三问：</p><ul><li>当前操作？考虑s[i]和t[j]选或不选</li><li>子问题？s的前i个字母和t的前j个字母的LCS长度</li><li>下一个子问题？<ul><li>s的前i-1个字母和t的前j-1个字母的LCS长度</li><li>s的前i-1个字母和t的前j个字母的LCS长度</li><li>s的前i个字母和t的前j-1个字母的LCS长度</li></ul></li></ul><p>这样可以确定递归参数中的i和j表示的子问题，就是s的前i个字母和t的前j个字母的LCS长度。</p><p>另外注意，都选和都不选两种情况的下一个子问题是一样的，并且只有s[i] == t[j]的时候才能都选。</p><p>可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">    <span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] != t[j])</span><br><span class="line">    <span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>));</span><br></pre></td></tr></table></figure><p>可以简化成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>)) + (s[i] == t[j]);</span><br></pre></td></tr></table></figure><p>然后灵茶山艾府提出了两个问题：</p><ol><li>在s[i] == t[j]的时候，我们需要考虑只选其中一个的情况吗？</li><li>在s[i] != t[j]的时候，我们需要考虑都不选的情况吗？</li></ol><p>答案是都不需要。灵茶山艾府对这一块的讲解有点没听明白，谈谈自己的理解。</p><p>对于问题<code>在s[i] == t[j]的时候，我们需要考虑只选其中一个的情况吗？</code>，我认为反证法更好理解。</p><p>假设在 s[i] == t[j] 时，我们不将这两个字符加入 LCS 中，而是选择忽略其中一个。那么：</p><ul><li>如果忽略s[i]，那么 LCS 的长度最多是 dfs(i-1, j)。</li><li>如果忽略t[j]，那么 LCS 的长度最多是 dfs(i, j-1)。</li></ul><p>然而，如果我们选择将 s[i] 和 t[j] 加入 LCS 中，那么 LCS 的长度是 dfs(i-1, j-1) + 1。由于 dfs(i-1, j-1) + 1 一定大于或等于 dfs(i-1, j) 或 dfs(i, j-1)，因此选择匹配这两个字符一定不会使结果变差，反而可能使结果更好。</p><p>因此s[i] === t[j]时，我们只需要考虑都选的情况就可以了。</p><p>对于问题<code>在s[i] != t[j]的时候，我们需要考虑都不选的情况吗？</code></p><p>如果 s 的第 i 个字符和 t 的第 j 个字符不相等，此时，我们需要考虑两种情况：</p><ul><li>忽略 s[i]，即只考虑 s 的前 i-1 个字符和 t 的前 j 个字符的 LCS。</li><li>忽略 t[j]，即只考虑 s 的前 i 个字符和 t 的前 j-1 个字符的 LCS。</li></ul><p>然后，我们取这两种情况的最大值。</p><ul><li>为什么不需要考虑“都不选”的情况？<br>因为“都不选”的情况已经被包含在上述两种情况中了。如果我们既不选 s[i] 也不选 t[j]，那么这种情况等价于 dfs(i-1, j-1)。而在 s[i] != t[j] 时，dfs(i-1, j-1)的值一定小于或等于 dfs(i-1, j) 或 dfs(i, j-1)，所以不需要单独考虑。</li></ul><h2 id="递归解法">递归解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// dfs(i, j)表示s[0...i-1]和t[0...j-1]的LCS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>)), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>) + (s[i] == t[j]));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(nm)，空间复杂度也为O(nm)。</p><h2 id="递推">递推</h2><p>能否继续优化空间复杂度？Of course！</p><p>先改为递推（空间复杂度仍为O(nm)）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[i<span class="number">+1</span>][j], f[i][j<span class="number">+1</span>]), f[i][j] + (s[i] == t[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两个数组">两个数组</h3><p>很容易优化成以下空间复杂度为O(m)的形式（使用两个数组）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[(i<span class="number">+1</span>) % <span class="number">2</span>][j], f[i % <span class="number">2</span>][j<span class="number">+1</span>]), f[i % <span class="number">2</span>][j] + (s[i] == t[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一个数组">一个数组</h3><p>画个图很容易发现，当前状态由左边、上边以及左上三个状态转移而来，当前状态还需要参与右边状态的转移，此时存在覆盖问题，因此用一个pre临时存储一下当前状态转移之前的值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pre = f[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = f[j<span class="number">+1</span>];</span><br><span class="line">                f[j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[j], f[j<span class="number">+1</span>]), pre + (s[i] == t[j]));</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>72. 编辑距离</h1><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。<br>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>依然记它们分别为s和t，基于上述三种操作把s改成t。</p><p>分析方法和上一题类似。</p><p><code>删除</code>一个字母相当于去掉s[i]。</p><p><code>插入</code>一个字母的话，由于需要保持和t[j]一样，那s插入一个字母相当于去掉t[j]。</p><p>如果s[i] == t[j]，那么就都去掉。</p><p>如果s[i] != t[j]则可以通过<code>替换</code>操作，比如说对于s=&quot;horse&quot;和t=&quot;ros&quot;的最后一个字母都不同，那么把s的最后一个字母替换成’s’，然后把s和t的最后一个字母都去掉即可。</p><p>可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, j), <span class="built_in">dfs</span>(i, j - <span class="number">1</span>)), <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中s[i] != t[j]的时候dfs(i - 1, j)相当于<code>删除</code>操作，dfs(i, j - 1)相当于<code>插入</code>操作，dfs(i - 1, j - 1) + 1相当于替换操作。</p><p>还有一些边界条件就是i &lt; 0或者 j &lt; 0 需要处理。</p><ul><li>i &lt; 0<ul><li>s为空t不为空，需要在s中插入和t相等长度的字符</li><li>故返回 j + 1</li></ul></li><li>j &lt; 0<ul><li>s不为空t为空，需要把s中字母全部删除，删除长度为t的长度</li><li>return i + 1;</li></ul></li></ul><h2 id="递归">递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j + <span class="number">1</span>; <span class="comment">// s为空t不为空，需要在s中插入和t相等长度的字符</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// s不为空t为空，需要把s中字母全部删除，删除长度为t的长度</span></span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">                <span class="keyword">return</span> res = <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, j), <span class="built_in">dfs</span>(i, j - <span class="number">1</span>)), <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递推-2">递推</h2><p>递归很容易翻译成递推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[<span class="number">0</span>][j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i<span class="number">+1</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[i<span class="number">+1</span>][j<span class="number">+1</span>] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i][j<span class="number">+1</span>], f[i<span class="number">+1</span>][j]), f[i][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递推解法-空间复杂度O-m-两个数组">递推解法 空间复杂度O(m) 两个数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[<span class="number">0</span>][j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[(i<span class="number">+1</span>) % <span class="number">2</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = f[i % <span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i % <span class="number">2</span>][j<span class="number">+1</span>], f[(i<span class="number">+1</span>) % <span class="number">2</span>][j]), f[i % <span class="number">2</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递推解法-空间复杂度O-m-一个数组：">递推解法 空间复杂度O(m) 一个数组：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pre = f[<span class="number">0</span>];</span><br><span class="line">            f[<span class="number">0</span>] = i<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = f[j<span class="number">+1</span>];</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[j<span class="number">+1</span>] = pre;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[j<span class="number">+1</span>], f[j]), pre) + <span class="number">1</span>;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划四：完全背包</title>
      <link href="/2025/03/02/dp4/"/>
      <url>/2025/03/02/dp4/</url>
      
        <content type="html"><![CDATA[<p>今日继续学习B站Up主出品的基础算法精讲系列，<a href="https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">0-1背包 完全背包【基础算法精讲 18】</a>（点击即可跳转视频链接）。</p><p>0-1背包和完全背包是非常重要的DP模型，灵茶山艾府认为一定程度上它们就是“选或不选”思想的代表。</p><p>本片博客主要关注完全背包。</p><h1>完全背包</h1><p><code>完全背包</code>：有n种物品，第i种物品的体积为 w[i]，价值为 v[i]，每种物品<code>无限次重复选</code>，求体积和不超过 capacity时的最大价值和。</p><p>递归做法的回溯三问为：</p><ul><li>当前操作?枚举<code>第</code>i种物品选一个或不选:<ul><li>不选，剩余容量不变;</li><li>选一个，剩余容量减少 w[i]</li></ul></li><li>子问题?在剩余容量为c时，从<code>前</code>i种物品中得到的最大价值和</li><li>下一个子问题?分类讨论：<ul><li>不选：在剩余容量为c时，从<code>前</code>i-1 种物品中得到的最大价值和:</li><li>选一个，在剩余容量为c-w[i]时，从<code>前</code>i种物品中得到的最大价值和</li></ul></li></ul><p>这里和0-1背包的回溯<code>区别</code>为，在选了一个物品之后，i是不变的，表示可以继续选第i中物品。因此不是递归到i-1，而是递归到i。</p><p>很容易得到其实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">unbounded_knapsack</span><span class="params">(<span class="type">int</span> c, vector&lt;<span class="type">int</span>&gt;&amp; w, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i, c), <span class="built_in">dfs</span>(i, c-w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>322. 零钱兑换</h1><p>看一道Leetcode题<a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span><br><span class="line"></span><br><span class="line">计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</span><br><span class="line"></span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure><p>背包问题的常见变形：</p><ol><li>至多装capacity，求方案数/最大价值和</li><li>恰好装capacity，求方案数/最大/最小价值和</li><li>至少装capacity，求方案数/最小价值和</li></ol><p>这道Leetcode题也是完全背包的一种变形，把物品价值看成是1，把求最大改成求最小，可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i, c) = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i, c-w[i]) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>dfs(i, c)表示前i种硬币组合金额恰好为c的所需的硬币个数。由于要求恰好组成amount，所以当c=0时才能返回0表示前i个物品组成金额c（金额0）需要0枚硬币，否则返回无穷大表示方案不合法。这样后面取min时自然就取到了不是无穷大的方案。</p><p>最后还需要判断一下，如果ans小于无穷大表示这是一个合法方案，否则无合法方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, <span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : INT_MAX / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][c];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">                <span class="keyword">return</span> res = <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i, c-w[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">dfs</span>(n<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] w;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.w = w;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> dfs(n-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][c] != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][c];</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i]) </span><br><span class="line">            <span class="keyword">return</span> memo[i][c] = dfs(i-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> memo[i][c] = Math.min(dfs(i-<span class="number">1</span>, c), dfs(i, c-w[i]) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化为递推">优化为递推</h2><p>依然是使用f数组，根据递归边界条件当<code>i == 0 &amp;&amp; c == 0</code>时才是0，其他都是无穷大，所以f数组可以初始化为无穷大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i]) </span><br><span class="line">                    f[i<span class="number">+1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i<span class="number">+1</span>][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">+1</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = f[n][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: f) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    f[i+<span class="number">1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i+<span class="number">1</span>][j] = Math.min(f[i][j], f[i+<span class="number">1</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[n][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间优化">空间优化</h2><h3 id="两个数组">两个数组</h3><p>同0-1背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i]) </span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][j] = f[i%<span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][j] = <span class="built_in">min</span>(f[i%<span class="number">2</span>][j], f[(i<span class="number">+1</span>)%<span class="number">2</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = f[n%<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: f) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = f[i%<span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = Math.min(f[i%<span class="number">2</span>][j], f[(i+<span class="number">1</span>)%<span class="number">2</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[n%<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个数组">一个数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(amount<span class="number">+1</span>, INT_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= amount; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= coins[i])</span><br><span class="line">                    f[c] = <span class="built_in">min</span>(f[c], f[c-coins[i]]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount] &lt; INT_MAX / <span class="number">2</span> ? f[amount] : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL二：使用C++连接MySQL</title>
      <link href="/2025/03/02/mysql2/"/>
      <url>/2025/03/02/mysql2/</url>
      
        <content type="html"><![CDATA[<p>在Visual Studio Code 下使用C++连接MySQL进行基本操作，参考CSDN博客<a href="https://blog.csdn.net/weixin_40582034/article/details/115562097?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522fb76f6ed18bf4ea960962a642e3d6c29%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=fb76f6ed18bf4ea960962a642e3d6c29&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-115562097-null-null.nonecase&amp;utm_term=mysql&amp;spm=1018.2226.3001.4450">C/C++访问MySQL数据库</a>、<a href="https://blog.csdn.net/weixin_41987016/article/details/135668803?spm=1001.2014.3001.5501">VsCode + CMake构建项目 C/C++连接Mysql数据库 | 数据库增删改查C++封装 | 信息管理系统通用代码 ---- 课程笔记</a>以及<a href="https://blog.csdn.net/weixin_52273949/article/details/130613224">windows下使用vscode原生态配置c++链接mysql数据库</a>三篇博客文章（点击即可跳转文章，非商业引用，侵权联系删）。</p><h1>配置工程环境</h1><ol><li>新建一个文件夹作为工程目录</li><li>将mysql下的<code>include文件夹</code>直接拷贝到工程目录下【或者只拷贝include中的mysql.h文件】<code>方便引用mysql.h头文件</code></li><li>拷贝<code>libmysql.dll</code> 、<code>libmysql.lib</code>、<code>mysqlclient.lib</code>文件直接放在工程目录下<code>因为这里可执行文件在其所在目录下直接寻找动态链接源文件</code></li><li>将<code>libmysql.dll</code> 、<code>libmysql.lib</code>再拷贝到工程的lib目录下<code>方便编译写库路径</code></li></ol><p>然后工程目录如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">工程目录</span><br><span class="line">│  libmysql.dll</span><br><span class="line">│  libmysql.lib</span><br><span class="line">│  mysqlclient.lib</span><br><span class="line">│</span><br><span class="line">├─include</span><br><span class="line">│</span><br><span class="line">└─lib</span><br><span class="line">    libmysql.dll</span><br><span class="line">    libmysql.lib</span><br></pre></td></tr></table></figure><p>到此工程环境配置完成。</p><h1>编写代码</h1><h2 id="连接数据库">连接数据库</h2><p>先连接数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * user = <span class="string">&quot;root&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * pw = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * database_name = <span class="string">&quot;database_test&quot;</span>; <span class="comment">// 数据库名</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> port = <span class="number">3306</span>; <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL * con = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mysql_real_connect</span> (con, host, user, pw, database_name, port, <span class="literal">nullptr</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to connect to database: Error:%s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码保存到main.cpp文件中，然后在cmd使用以下命令进行编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ .\main.cpp -Llib -lmysql -Iinclude</span><br></pre></td></tr></table></figure><p>解释一下这段命令：</p><ol><li>g++<ul><li>这是 GNU C++ 编译器</li></ul></li><li>.\main.cpp<ul><li>这是要编译的源文件，.\main.cpp 表示当前目录下的 main.cpp 文件。</li></ul></li><li>-Llib<ul><li>-L 选项用于指定库文件的搜索路径。</li><li>lib 是库文件所在的目录。编译器会在 lib 目录中查找链接时需要的库文件。</li></ul></li><li>-lmysql<ul><li>-l（小写l） 选项用于链接指定的库。</li><li>mysql 是要链接的库名称。</li><li>在Linux中，编译器会查找名为 libmysql.a（静态库）或 <a href="http://libmysql.so">libmysql.so</a>（动态库）的文件。</li><li>在Windows中，编译器会查找名为 libmysql.lib（静态库）或 libmysql.dll（动态库）的文件。</li></ul></li><li>-Iinclude<ul><li>-I（大写I） 选项用于指定头文件的搜索路径。</li><li>include 是头文件所在的目录。编译器会在 include 目录中查找 #include 指令中引用的头文件。</li></ul></li></ol><p>这条命令的作用是：</p><ol><li>编译 main.cpp 文件。</li><li>在 include 目录中查找头文件。</li><li>在 lib 目录中查找 libmysql 库文件。</li><li>将 main.cpp 编译成可执行文件，并链接 libmysql 库。</li><li>最终生成a.exe（windows）或者a.out（linux）的可执行文件</li></ol><h2 id="增删查改">增删查改</h2><p>我使用的数据库名称为database_test，里面有个表名称为students，表中内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------+--------------+--------------+</span><br><span class="line">| student_id | student_name | class_id     |</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">|      10000 | 张三         | 软件工程一班 |</span><br><span class="line">+------------+--------------+--------------+</span><br></pre></td></tr></table></figure><p>为了方便增删查改和管理，定义一个结构体组织信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> student_id;</span><br><span class="line">    string student_name;</span><br><span class="line">    <span class="type">int</span> class_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="插入">插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * user = <span class="string">&quot;root&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * pw = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * database_name = <span class="string">&quot;database_test&quot;</span>; <span class="comment">// 数据库名</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> port = <span class="number">3306</span>; <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> student_id;</span><br><span class="line">    string student_name;</span><br><span class="line">    string class_id;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL * con = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mysql_real_connect</span> (con, host, user, pw, database_name, port, <span class="literal">nullptr</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to connect to database: Error: %s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">        <span class="built_in">mysql_close</span>(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    Student stu&#123;<span class="number">10002</span>, <span class="string">&quot;李华&quot;</span>, <span class="string">&quot;计算机科学与技术二班&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> sql[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into students (student_id, student_name, class_id) values (%d,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, </span><br><span class="line">        stu.student_id, stu.student_name.<span class="built_in">c_str</span>(), stu.class_id.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(con, sql)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to insert data: Error: %s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">        <span class="built_in">mysql_close</span>(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 Student 对象 stu，并初始化其数据。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu&#123;<span class="number">10002</span>, <span class="string">&quot;李华&quot;</span>, <span class="string">&quot;计算机科学与技术二班&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>构造 SQL 插入语句</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> sql[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into students (student_id, student_name, class_id) values (%d,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, </span><br><span class="line">    stu.student_id, stu.student_name.<span class="built_in">c_str</span>(), stu.class_id.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><ul><li>使用 sprintf 构造一个 SQL 插入语句。<ul><li>sprintf 是 C 标准库中的一个函数，用于将格式化的数据写入字符串中。</li><li>它的作用类似于 printf，但 printf 是将数据输出到标准输出（如终端），而 sprintf 是将数据写入一个字符数组中</li><li>sprintf 的 %s 格式说明符要求传入的参数是一个 C 风格字符串（即 const char* 类型），使用c_str成员函数将string转换为 C 风格字符串</li><li><code>C 风格字符串</code>：是一个以 \0 结尾的字符数组（char[] 或 const char*）</li></ul></li><li>students 是目标表名，student_id、student_name 和 class_id 是表的字段。</li><li>stu.student_id、stu.student_name 和 stu.class_id 是待插入的数据。</li></ul><ol start="3"><li>执行 SQL 语句</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">mysql_query</span>(con, sql)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to insert data: Error: %s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mysql_query 执行 SQL 语句。<ul><li>如果执行失败，输出错误信息并关闭连接。</li><li>如果执行成功，数据将被插入到数据库中。</li><li>mysql_query 是 MySQL C API 中的一个函数，用于向 MySQL 服务器发送 SQL 查询并执行。</li><li>mysql_query 是 MySQL C API 中最常用的函数之一，适用于执行各种 SQL 语句</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2025/03/02/designPattern1/"/>
      <url>/2025/03/02/designPattern1/</url>
      
        <content type="html"><![CDATA[<p>通过他人博客学习一下单例模式以及C++实现，博客文章链接<a href="https://blog.csdn.net/trackxiaoxin321/article/details/110749781">C++设计模式之单例模式详解（懒汉模式、饿汉模式、双重锁）</a>。</p><h1>走进单例模式</h1><p>我们希望类的实例对象有且仅有一个，比如数据库连接配置、应用设置时，系统中需要一个全局对象，所有模块共享同一配置。再比如数据库连接池也需要全局管理，避免频繁创建与销毁。</p><p>感觉上述例子并不直观，再举个直观通俗的例子——家里的电表。家里的电表记录整个家庭的用电量。无论你在厨房、卧室还是客厅用电，电表都是同一个。你不会希望每个房间都有一个独立的电表，因为那样会导致用电量的计算混乱。</p><p>我们希望实例对象有且只有一个，此时就需要用到单例模式了。单例模式保证一个类有且仅有一个实例，并且会提供一个全局访问点。</p><p>如何实现让一个类的实例只有一个呢？那么就需要在构造函数上做点“手脚”。如果构造函数是public，那么就没有任何限制地可以构造对象了。因此，需要将构造函数私有化即设置为private属性，并对外提供一个接口，并且这个接口得是静态的即static关键字修饰的接口。如果不使用static关键字修饰，那么调用这个接口就需要创建对象，而构造函数又被私有化了，无法创建对象。因此这个接口得是静态的。</p><p>此外，还需要禁用拷贝构造函数和复制运算符。</p><h2 id="补充拷贝构造函数">补充拷贝构造函数</h2><p>复习一下拷贝构造函数。</p><p>拷贝构造函数是C++中的一个特殊成员函数，用于创建一个新对象，并将其初始化为另一个同类型对象的副本。它在以下情况下会被调用：</p><ul><li>用一个对象初始化另一个对象时。</li><li>将对象作为参数按值传递给函数时。</li><li>从函数按值返回对象时。</li></ul><p>拷贝构造函数的典型形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 拷贝函数逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拷贝构造函数的参数是一个常量引用（const MyClass&amp;），表示被拷贝的对象。</p><p>拷贝构造函数常见问题是<code>浅拷贝</code>的问题，不再多说啦。</p><h1>具体实现</h1><p>单例模式实现有两种方式：</p><ul><li>懒汉方式</li><li>饿汉方式</li></ul><h2 id="懒汉方式">懒汉方式</h2><p>懒汉方式：顾名思义，很“懒”，只有用到了才实例化对象并返回（调用了对外的接口才会实例化对象）。代码实现如下：</p><h3 id="不加锁">不加锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton* singlep1 = Singleton::<span class="built_in">getInstance</span>();   <span class="comment">// 通过类域获取接口</span></span><br><span class="line">Singleton* singlep2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; singlep1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; singlep2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现是<code>线程不安全</code>的，原因在于<code>getInstance</code>方法中的条件判断和实例创建操作不是原子的。在多线程环境下，可能会导致多个线程同时创建实例，从而破坏单例模式的唯一性。</p><p>在 getInstance 方法中，以下代码是问题的根源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) </span><br><span class="line">    instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure><ul><li>多个线程可能同时进入 if (instance == nullptr) 的判断。</li><li>如果 instance 为 nullptr，多个线程会同时执行 instance = new singleClass()，导致创建多个实例。</li><li>最终，instance 可能指向不同的对象，破坏了单例模式的唯一性。</li></ul><h3 id="加锁后检查">加锁后检查</h3><p>为了解决这一问题，很容易想到使用互斥信号量也就是互斥锁来解决，于是就有以下方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br><span class="line">mutex Singleton::mtx; <span class="comment">// 类外初始化 </span></span><br></pre></td></tr></table></figure><p>这种实现方法有很明显的优缺点:</p><ul><li>优点<ul><li>简单直观</li></ul></li><li>缺点<ul><li>每次调用<code>getInstance</code>都需要加锁，性能开销较大。</li></ul></li></ul><h3 id="二重锁">二重锁</h3><p>因此继续进行改进，使用<code>双重检查锁定</code>的方式，又称为<code>二重锁</code>。不同于前一种上锁方法，二重锁的<code>核心思想</code>是通过两次检查实例是否为空来减少加锁的次数：</p><ol><li>第一次检查（不加锁）：检查实例是否已经创建。如果已经创建，直接返回实例，避免加锁的开销。</li><li>第二次检查（加锁）：如果实例未创建，加锁后再次检查实例是否为空。如果仍然为空，则创建实例。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br><span class="line">mutex Singleton::mtx; <span class="comment">// 类外初始化</span></span><br></pre></td></tr></table></figure><h4 id="二重锁优点">二重锁优点</h4><ol><li>减少加锁开销<ul><li>只有在实例未创建时才加锁，避免了每次调用 getInstance 都加锁的性能开销。</li></ul></li><li>线程安全<ul><li>通过加锁确保实例创建过程的线程安全。</li></ul></li></ol><h4 id="额外补充">额外补充</h4><p>上述实现中对于互斥信号量mtx的上锁使用的是<code>mtx.lock()</code>，解锁使用的是<code>mtx.unlock()</code>。其实可以使用<code>lock_guard&lt;mutex&gt; lock(mtx)</code>来实现。</p><ol><li><p>mtx.lock() 和 mtx.unlock()</p><ul><li>手动加锁和解锁：<ul><li>mtx.lock()：手动加锁。</li><li>mtx.unlock()：手动解锁。</li></ul></li><li>需要显式调用解锁：<ul><li>如果忘记调用 mtx.unlock()，会导致锁未被释放，可能引发死锁。</li></ul></li><li>灵活性：<ul><li>可以在代码的任何地方加锁和解锁，适合需要精细控制锁的场景。</li></ul></li></ul></li><li><p>lock_guard<mutex> lock(mtx)</p><ul><li>自动加锁和解锁：<ul><li>lock_guard 是一个 RAII（资源获取即初始化）封装类。</li><li>在构造时自动加锁，在析构时自动解锁。</li></ul></li><li>无需手动解锁：<ul><li>即使函数提前返回或抛出异常，lock_guard 也能保证锁被释放。</li></ul></li><li>简洁性和安全性：<ul><li>代码更简洁，不易出错。</li></ul></li></ul></li><li><p>lock_guard<mutex> lock(mtx) 和 mtx.lock() 的区别</p></li></ol><table><thead><tr><th>特性</th><th>lock_guard<mutex> lock(mtx)</th><th>mtx.lock() 和 mtx.unlock()</th></tr></thead><tbody><tr><td>加锁方式</td><td>自动加锁（构造时）</td><td>手动加锁</td></tr><tr><td>解锁方式</td><td>自动解锁（析构时）</td><td>手动解锁</td></tr><tr><td>异常安全</td><td>是（即使抛出异常也能解锁）</td><td>否（需要手动处理异常）</td></tr><tr><td>代码简洁性</td><td>高</td><td>低</td></tr><tr><td>灵活性</td><td>低（锁的作用域由 lock_guard 的生命周期决定）</td><td>高（可以在任意位置加锁和解锁）</td></tr><tr><td>适用场景</td><td>简单的加锁和解锁场景</td><td>需要精细控制锁的场景</td></tr></tbody></table><h4 id="静态局部变量实例化实现懒汉方式">静态局部变量实例化实现懒汉方式</h4><p>C++11 标准规定，静态局部变量的初始化是线程安全的。因此可以使用静态局部变量初始化来实现懒汉模式。</p><ol><li>核心思想<ul><li>延迟初始化：单例对象在第一次调用 getInstance 时才被创建，而不是在程序启动时。</li><li>线程安全：C++11 标准规定，局部静态变量的初始化是线程安全的，编译器会自动处理线程同步问题。</li><li>简洁高效：无需手动管理锁或静态成员变量，代码更简洁。</li></ul></li><li>静态局部变量的特性<ul><li>生命周期：静态局部变量的生命周期从第一次执行到它的声明语句开始，直到程序结束。</li><li>线程安全：C++11 及以上标准保证，静态局部变量的初始化是线程安全的。</li><li>唯一性：静态局部变量只会被初始化一次。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton&amp; singlep1 = Singleton::<span class="built_in">getInstance</span>();   <span class="comment">//通过类域获取接口</span></span><br><span class="line">Singleton&amp; singlep2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; &amp;singlep1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;singlep2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉方式">饿汉方式</h2><p>以上是单例模式的懒汉实现方法，接下来介绍饿汉实现方法。</p><p>饿汉模式：不管调不调用对外接口，都已经实例化对象了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式：不管用不用得到，都构造出来。本身就是线程安全的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); <span class="comment">// 初始化静态变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton* singlep1 = Singleton::<span class="built_in">getInstance</span>();   <span class="comment">//通过类域获取接口</span></span><br><span class="line">Singleton* singlep2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; singlep1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; singlep2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发环境搭建</title>
      <link href="/2025/03/01/java1/"/>
      <url>/2025/03/01/java1/</url>
      
        <content type="html"><![CDATA[<h1>JDK的下载与安装</h1><p>百度搜索JDK8到Oracle官网下载<code>Java SE Development Kit 8u202</code>即可，需要注册账号。</p><p>下载好对应电脑版本的安装包后直接安装，记得把安装目录给记清楚，配置环境需要使用。</p><h1>配置环境目录</h1><ol><li>编辑系统环境变量<ul><li>创建一个新的系统环境变量，名称为<code>JAVA_HOME</code>，值为java的安装路径</li></ul></li><li>配置PATH变量<ul><li>在PATH变量中添加<code>%JAVA_HOME%\bin</code></li><li>在PATH变量中添加<code>%JAVA_HOME%\jre\bin</code></li></ul></li><li>验证<ul><li>在cmd中输入<code>java -version</code></li><li>显示java的版本等信息即为成功</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL一：MySQL环境配置</title>
      <link href="/2025/03/01/mysql1/"/>
      <url>/2025/03/01/mysql1/</url>
      
        <content type="html"><![CDATA[<p>即日起学习Mysql并进行记录。</p><h1>数据库分类</h1><h2 id="关系型数据库">关系型数据库</h2><ul><li>称作SQL</li><li>Mysql，Oracle，Sql Server， DB2， SQLlite</li><li>通过表与表之间，行与行之间的关系进行数据存储</li></ul><h2 id="非关系型数据库">非关系型数据库</h2><ul><li>称作NoSQL即Not only SQL</li><li>Redis， MongDB</li><li>对象存储，通过对象自身的属性来进行存储</li></ul><h2 id="DBMS">DBMS</h2><ul><li>DBMS即数据库管理系统</li></ul><h2 id="MySQL">MySQL</h2><ul><li>MySQL是一个关系型数据库管理系统</li><li>由瑞典 MySQL AB 公司开发</li><li>属于 Oracle 旗下产品</li><li>MySQL是最流行的关系型数据库管理系统之一</li><li>在 WEB 应用方面，MySQL是最好的RDBMS (Relational Database Management System，关系数据库管理系统)应用软件之一。</li></ul><h1>MySQL 安装</h1><h2 id="建议">建议</h2><ul><li>尽量使用压缩包，不用exe文件（貌似与注册表有关）</li></ul><h2 id="详细安装说明">详细安装说明</h2><ol><li>解压到合适的位置（我的安装目录为D:\ProgramFiles\mysql-5.7.44）</li><li>为解压后文件中的bin目录配置环境变量</li><li>在解压后的目录下创建一个my.ini文件（D:\ProgramFiles\mysql-5.7.44\my.ini）</li><li>编辑my.ini文件为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=D:\ProgramFiles\mysql-5.7.44\</span><br><span class="line">datadir=D:\ProgramFiles\mysql-5.7.44\data\</span><br><span class="line">port=3306</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>注意：虽然没有data目录也不用去手动创建！</p><ol start="5"><li>启动管理员模式下的cmd，并将目录切换到mysql的bin目录下，然后输入<code>mysqld --install</code><ul><li>显示Service successfully installed.即成功</li></ul></li><li>再输入<code>mysqld --initialize-insecure --user=mysql</code>初始化数据文件<ul><li>此时会在mysql目录下产生data文件夹</li></ul></li><li>输入<code>net start mysql</code>启动mysql服务</li><li>输入<code>mysql -u root -p</code>，注意-p后不要＋任何东西，包括空格。提示输入密码，直接回车跳过</li><li>输入<code>update mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost';</code>修改密码为123456，最后输入<code>flush priviledges;</code>刷新权限（注意MySQL语句以分号结尾）<ul><li>如果使用的是MySQL 5.7.6 及以上版本，输入<code>ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';</code>，然后<code>flush priviledges</code></li></ul></li><li>将my.ini文件<code>skip-grant-tables</code>删除</li><li>重启MySQL服务即可使用<ul><li>net stop mysql</li><li>net start mysql</li></ul></li><li>输入<code>mysql -u root -p</code>再键入密码即可使用</li></ol><h2 id="基本命令行">基本命令行</h2><ol><li>查询所有数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><ol start="2"><li>切换数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use [数据库名称]</span><br></pre></td></tr></table></figure><ol start="3"><li>查看数据库中所有的表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看显示数据库中所有表的信息</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descibe [表名]</span><br></pre></td></tr></table></figure><ol start="5"><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [数据库名称]</span><br></pre></td></tr></table></figure><ol start="6"><li>退出连接</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="sqlyog的使用">sqlyog的使用</h2><p>参考CSDN博客<a href="https://blog.csdn.net/weixin_43364551/article/details/116754626">https://blog.csdn.net/weixin_43364551/article/details/116754626</a></p><h2 id="数据库基本操作">数据库基本操作</h2><p>数据库 XXX 语言</p><ol><li>DDL 定义</li><li>DML 操作</li><li>DQL 查询</li><li>DCL 控制</li></ol><h1>操作数据库</h1><p>操作数据库-&gt;操作数据库中的表-&gt;操作数据库中的表的数据</p><ol><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [数据库名称]</span><br></pre></td></tr></table></figure><ol start="2"><li>删除数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] [数据库名称]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 关系型数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划三：0-1背包</title>
      <link href="/2025/02/28/dp3/"/>
      <url>/2025/02/28/dp3/</url>
      
        <content type="html"><![CDATA[<p>今日继续学习B站Up主出品的基础算法精讲系列，<a href="https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">0-1背包 完全背包【基础算法精讲 18】</a>（点击即可跳转视频链接）。</p><p>0-1背包和完全背包是非常重要的DP模型，灵茶山艾府认为一定程度上它们就是“选或不选”思想的代表。</p><p>本片博客主要关注<code>0-1背包</code>。</p><h1>0-1 背包</h1><p><code>0-1 背包</code>:有 n 个物品，第i个物品的体积为 w[i]，价值为 v[i]，每个物品至多选一个，求体积和不超过 capacity 时的最大价值和。</p><p>先从回溯开始思考，这里先附上灵茶山艾府总结的关于该问题的回溯三问：</p><ul><li>当前操作？枚举<code>第</code>i个物品选还是不选：<ul><li>不选，剩余容量不变</li><li>选，剩余容量变量</li></ul></li><li>子问题？即在剩余容量为c时，从<code>前</code>i-1个物品中得到的最大价值和</li><li>下一个子问题？分类讨论<ul><li>不选，剩余容量仍为c，从<code>前</code>i个物品中得到的最大价值和</li><li>选，剩余容量变为c-w[i]，从<code>前</code>i-1个物品中得到的最大价值和</li></ul></li></ul><p>先从回溯开始思考，也就是考虑第i个物品选还是不选，不选-&gt;容量不变，选-&gt;容量变小，由此确定递归参数中的i和c。对应的<code>子问题</code>就变成从前i个物品中能得到的最大价值和。</p><ul><li>不选就递归到它表示在剩余容量为c时，从前i-1个物品中获得的最大价值和。</li><li>选就递归到它表示在剩余容量为c-w[i]时，从前i-1个物品中获得的最大价值和。<br>上述两个取最大值就是dfs(i, c)的结果了。</li></ul><p>基于上述结果可以编写代码，我忽略的一点是当剩余容量c小于第i个物品即<code>c &lt; w[i]</code>时，我们只能不选第i个物品，因此直接返回<code>dfs(i-1, c)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">zero_one_knapsack</span><span class="params">(<span class="type">int</span> capacity, vector&lt;<span class="type">int</span>&gt;&amp; w, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i<span class="number">-1</span>, c-w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>494.目标和</h1><p>然后看Leetcode题<a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个非负整数数组 nums 和一个整数 target 。</span><br><span class="line"></span><br><span class="line">向数组中的每个整数前添加 &#x27;+&#x27; 或 &#x27;-&#x27; ，然后串联起所有整数，可以构造一个<span class="code">`表达式`</span>：</span><br><span class="line"></span><br><span class="line"><span class="code">    例如，nums = [2, 1] ，可以在 2 之前添加 &#x27;+&#x27; ，在 1 之前添加 &#x27;-&#x27; ，然后串联起来得到表达式 &quot;+2-1&quot; 。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">返回可以通过上述方法构造的、运算结果等于 target 的不同<span class="code">`表达式`</span>的数目。</span><br></pre></td></tr></table></figure><p>这道题看上去和0-1背包没有关系。</p><p>假设添加正号的数的和为p，那么添加负号的数的和为所有元素的和s减去p。那么<code>p - (s - p)</code>就是target了，即<code>p - (s - p) = t</code>=&gt;<code>2p=s+t</code>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">p=\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>。</p><p>现在问题就变成从nums中选择一些数字，使得他们的和恰好等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>的方案数。注意s+t既然要除以2那么s+t就得为偶数，并且由于nums[i]为非负数，故无论怎么选s+t都不会为负数。</p><p>背包问题的常见变形：</p><ol><li>至多装capacity，求方案数/最大价值和</li><li>恰好装capacity，求方案数/最大/最小价值和</li><li>至少装capacity，求方案数/最小价值和</li></ol><p>经过灵茶山艾府的巧妙转换，494. 目标和 问题就变形为上述第2中情况下的：恰好装capacity，求方案数。</p><h2 id="递归解法">递归解法</h2><p>接下来编写代码。首先计算s+t，如果s+t是负数或者说s+t是一个奇数，则不满足要求，方案数为0。否则将s+t除以2（整除）记为p。</p><p>对于递归函数dfs，dfs(i, c)表示前i个数相加和为c的方案数。对于递归的边界条件，因为是从target倒着减，当c=0时说明找到了一个合法的方案数，因此返回1。否则返回0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t); <span class="comment">// p = (s + t)</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c) + <span class="built_in">dfs</span>(i<span class="number">-1</span>, c - w[i]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        p /= <span class="number">2</span>; <span class="comment">// p = (s + t) / 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w.<span class="built_in">size</span>() - <span class="number">1</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.length-<span class="number">1</span>, p, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c, <span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c, w) + dfs(i-<span class="number">1</span>, c - w[i], w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化为递推">优化为递推</h2><p>如何将记忆化搜索改成递推？灵茶山艾府总结如下：</p><ol><li>dfs -&gt; f数组</li><li>递归 -&gt; 循环</li><li>递归边界 -&gt; 数组初始值</li></ol><p>dfs改成f数组，这里的f数组是一个二维数组f[i][c]表示前i个数相加和为c的方案数。需要重点处理一下边界条件，从原递归中的边界条件入手。递归的边界条件有<code>i &lt; 0 &amp;&amp; c == 0</code>时return 1，每次向下递归时都传参i-1，故负数下标为边界。原来的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以更改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>只对<code>i &lt; 0 &amp;&amp; c == 0</code>的边界条件转换为数组边界<code>f[0][0] = 1</code>，而没有处理<code>i &lt; 0 &amp;&amp; c != 0</code>是因为c != 0时不为f数组边界。</p><p>递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c) + <span class="built_in">dfs</span>(i<span class="number">-1</span>, c - w[i]);</span><br></pre></td></tr></table></figure><p>改成循环为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][c] = f[i<span class="number">-1</span>][c] + f[i<span class="number">-1</span>][c-w[i]]</span><br></pre></td></tr></table></figure><p>为了避免负数下标将f中出现i的地方全部+1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+1</span>][c] = f[i][c] + f[i][c-w[i]]</span><br></pre></td></tr></table></figure><p>相应的数组的第一维大小应为nums.size() + 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (p + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][c] = f[i][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[i<span class="number">+1</span>][c] += f[i][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][c] = f[i][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[i+<span class="number">1</span>][c] += f[i][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继续优化空间复杂度">继续优化空间复杂度</h2><h3 id="两个数组">两个数组</h3><p>每次把f[i+1]算完之后，后面就不会用到f[i]了，也就是每时每刻数组中只有两个元素在参与状态转移，干脆就只用两个数组。比如把f[1]算完了，那么计算f[2]时直接把结果填到f[0]当中。然后计算f[3]时，f[1]没用，就把f[3]填到f[1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+1</span>][c] = f[i][c];</span><br><span class="line"><span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">    f[i<span class="number">+1</span>][c] += f[i][c-w[i]];</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line"><span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">    f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br></pre></td></tr></table></figure><p>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (p + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[(i+<span class="number">1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个数组">一个数组</h3><p>能否进一步优化？Of course！<br>两行数组对于第一维是正向计算，有覆盖问题。但是如果反向计算就没有覆盖问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(p<span class="number">+1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = p; c &gt;= <span class="number">0</span>; --c) </span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[c] += f[c-w[i]];</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> p; c &gt;= <span class="number">0</span>; --c) </span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[c] += f[c-w[i]];</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 二十九：2353. 设计食物评分系统</title>
      <link href="/2025/02/28/leetcode29/"/>
      <url>/2025/02/28/leetcode29/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/design-a-food-rating-system/description/">2353. 设计食物评分系统</a>。</p><p>设计一个支持下述操作的食物评分系统：</p><ul><li>修改 系统中列出的某种食物的评分。</li><li>返回系统中某一类烹饪方式下评分最高的食物。</li></ul><p>实现 FoodRatings 类：</p><ul><li>FoodRatings(String[] foods, String[] cuisines, int[] ratings) 初始化系统。食物由 foods、cuisines 和 ratings 描述，长度均为 n 。<ul><li>foods[i] 是第 i 种食物的名字。</li><li>cuisines[i] 是第 i 种食物的烹饪方式。</li><li>ratings[i] 是第 i 种食物的最初评分。</li></ul></li><li>void changeRating(String food, int newRating) 修改名字为 food 的食物的评分。</li><li>String highestRated(String cuisine) 返回指定烹饪方式 cuisine 下评分最高的食物的名字。如果存在并列，返回<code>字典序较小</code>的名字。</li></ul><p>注意，字符串 x 的字典序比字符串 y 更小的前提是：x 在字典中出现的位置在 y 之前，也就是说，要么 x 是 y 的前缀，或者在满足 x[i] != y[i] 的第一个位置 i 处，x[i] 在字母表中出现的位置在 y[i] 之前。</p><p>这几天设计题做得头大😒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">int</span>, string&gt;&gt; foods_map;</span><br><span class="line">    unordered_map&lt;string, set&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;&gt; cuisines_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FoodRatings</span>(vector&lt;string&gt;&amp; foods, vector&lt;string&gt;&amp; cuisines, vector&lt;<span class="type">int</span>&gt;&amp; ratings) &#123;</span><br><span class="line">        <span class="type">int</span> n = foods.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            foods_map[foods[i]] = &#123;ratings[i], cuisines[i]&#125;;</span><br><span class="line">            cuisines_map[cuisines[i]].<span class="built_in">emplace</span>(-ratings[i], foods[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeRating</span><span class="params">(string food, <span class="type">int</span> newRating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [rating, cuisine] = foods_map[food];</span><br><span class="line">        cuisines_map[cuisine].<span class="built_in">erase</span>(&#123;-rating, food&#125;);</span><br><span class="line">        cuisines_map[cuisine].<span class="built_in">emplace</span>(-newRating, food);</span><br><span class="line">        rating = newRating;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cuisines_map[cuisine].<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FoodRatings object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);</span></span><br><span class="line"><span class="comment"> * obj-&gt;changeRating(food,newRating);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;highestRated(cuisine);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>由于每日一题题型较散，即日起本专栏停更。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划二</title>
      <link href="/2025/02/27/dp2/"/>
      <url>/2025/02/27/dp2/</url>
      
        <content type="html"><![CDATA[<p>今日继续动态规划，先来道简单题练练手<a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a>。</p><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre><code>F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre><p>给定 n ，请计算 F(n) 。</p><p>这道题我称之为递归入门题目，但是在DP里也算入门级吧。</p><h1>跟着灵茶山艾府学DP</h1><p>接下来，学习学习灵茶山艾府出品的<a href="https://www.bilibili.com/video/BV1Xj411K7oF/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">动态规划入门：从记忆化搜索到递推【基础算法精讲 17】</a>（视频链接为B站UP主灵茶山艾府出品，点击即可跳转视频）。</p><p>UP主指出，动态规划的核心：</p><ul><li>状态定义</li><li>状态转移方程</li></ul><p>UP主要是通过Leetcode上的一道题目<a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍</a>来进行讲解的。</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><pre><code>输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p>示例 2：</p><pre><code>输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><h2 id="灵茶山艾府的思路">灵茶山艾府的思路</h2><h3 id="递归">递归</h3><p>先把它看成一道回溯题，把一个大问题变成规模更小的子问题，从第一个房子或者最后一个房子开始思考，因为他们收到的约束最少。比如考虑最后一个房子选还是不选：</p><ul><li>如果不选，那么问题就变成n-1个房子的问题</li><li>如果选，就变成n-2个房子的问题<br>不断这样思考下去可以得到一棵搜索树：</li></ul><p><img src="/images/dp2.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><p>注意一点，图中每个节点的数字代表第几个房子，4就是第四个房子。</p><p>灵茶山艾府提出了回溯三问：</p><ol><li>当前操作？是枚举<code>第</code>i个房子选/不选</li><li>子问题？是<code>前</code>i个房子中得到的最大金额和</li><li>下一个子问题？需要分类讨论：<ul><li>不选：从<code>前</code>i-1个房子得到的最大金额和</li><li>选：从<code>前</code>i-2个房子得到的最大金额和<br>最终得到以下实现：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>), nums[i] + <span class="built_in">dfs</span>(i<span class="number">-2</span>));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="记忆化搜索">记忆化搜索</h3><p>上述代码类似于回溯，时间复杂度是指数级别的，会超时。如何优化？灵茶山艾府引导我们回去看之前的那颗搜索树。观察搜索树我们会发现，有两个包含节点2的子树，并且这两个子树是相同的。也就是说dfs(2)算了两次，但它们的结果是一样，干脆在第一次计算时就把计算结果存到一个cache数组或者哈希表里。</p><p><img src="/images/dp2_2.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><p>优化后的搜索树如下，可以看到这棵搜索树只有O(n)个节点，时间复杂度也优化到了O(n)。</p><p><img src="/images/dp2_3.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> memo[i];</span><br><span class="line">            memo[i] = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>), nums[i] + <span class="built_in">dfs</span>(i<span class="number">-2</span>));</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums, memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(dfs(i-<span class="number">1</span>), dfs(i-<span class="number">2</span>) + nums[i]);</span><br><span class="line">        memo[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度如何计算呢？有公式：</p><ul><li>状态数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">×</span></span></span></span>单个状态所需要的计算时间<br>本题状态个数是O(n)，单个状态的计算时间是O(1)，所以时间复杂度为O(n)。空间复杂度为O(n)。</li></ul><h3 id="递推">递推</h3><p>有没有办法把空间复杂度优化到O(1)呢？递归的递即调用函数，归即return。</p><p>再回头看上面那张图，这里为了避免来回翻，再在这里附上。</p><p><img src="/images/dp2_3.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><p>这里计算max发生在dfs调用结束之后，也就是在递归的“归”的过程中才发生了实际的max计算。0和1归到2，2和1归到3，3和2归到4，那既然我们知道要从哪些点归到哪个点，那么干脆去掉递归中的“递”，只留下“归”的过程，也就是从最下面开始往上计算。这被灵茶山艾府称作“递推”。</p><pre><code>自顶向下算 = 记忆化搜索自底向上算 = 递推</code></pre><p>上述应该是UP主灵茶山艾府提出的概念了，仔细详细感觉很有道理😁。</p><p>如何将记忆化搜索改成递推？灵茶山艾府总结如下：</p><ol><li>dfs -&gt; f数组</li><li>递归 -&gt; 循环</li><li>递归边界 -&gt; 数组初始值</li></ol><p>原来的递归为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-2</span>) + nums[i]);</span><br></pre></td></tr></table></figure><p>基于上述方法很容易将递归修改成递推，但是需要对i = 0和i = 1的情况特殊处理（因为会产生负数下标）。</p><p>为了避免产生负数下标，可以把i改成从2开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i] = <span class="built_in">max</span>(f[i<span class="number">-1</span>], f[i<span class="number">-2</span>] + nums[i]);</span><br></pre></td></tr></table></figure><p>也可以把三处i都+2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+2</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>], f[i] + nums[i]);</span><br></pre></td></tr></table></figure><p>最终得到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            f[i<span class="number">+2</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>], f[i] + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * f = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n + <span class="number">2</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        f[i+<span class="number">2</span>] = MAX(f[i+<span class="number">1</span>], f[i] + nums[i]);</span><br><span class="line">    <span class="keyword">return</span> f[n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            f[i+<span class="number">2</span>] = Math.max(f[i+<span class="number">1</span>], f[i] + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> f[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递推的代码空间复杂度仍然为O(n)，但是结合一开始的<a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a>，应该不难想到如何空间优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f1 = <span class="number">0</span>, f2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">max</span>(f1, f2 + nums[i]);</span><br><span class="line">            f2 = f1;</span><br><span class="line">            f1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">0</span>, f2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cur = MAX(f1, f2 + nums[i]);</span><br><span class="line">        f2 = f1;</span><br><span class="line">        f1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>, f2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(f1, f2 + nums[i]);</span><br><span class="line">            f2 = f1;</span><br><span class="line">            f1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc、free 和 new、delete 的区别</title>
      <link href="/2025/02/27/cpp-interview1/"/>
      <url>/2025/02/27/cpp-interview1/</url>
      
        <content type="html"><![CDATA[<p>malloc 和 free 是C语言的库函数， new 和 delete 是 C++ 里的操作符。谈到区别就要去讨论共同点与不同点，尤其要关注他们之间的差异。</p><h1>new 和 malloc</h1><ol><li>new 自动计算所需分配的内存大小，malloc需要手动计算。</li><li>返回值不同，new的返回值为对象类型的指针，而malloc返回的是<code>void*</code>类型的指针（使用malloc往往需要手动进行类型转换）。</li><li>new 分配失败时抛出异常std::bad_alloc，而malloc分配失败则返回NULL。</li><li>new 是free store上分配内存，而malloc是在堆上或者文件映射区。</li><li>new 分配的内存一般是初始化过的，malloc分配的内存没有经过初始化。</li></ol><h2 id="new-的工作过程">new 的工作过程</h2><ol><li>使用new操作符时，先调用operator new（这个可以重载）</li><li>然后申请所需的空间</li><li>最后调用构造函数，初始化成员变量</li></ol><h2 id="malloc">malloc</h2><ol><li>malloc分配的虚拟内存</li><li>malloc当分配的内存小于128K字节时通过brk系统调用在堆上分配内存，当超过128K字节时通过mmap系统调用在文件映射区分配内存</li></ol><h1>delete 和 free</h1><ol><li>delete 需要对象类型的指针，free 不需要关注需要释放对象的类型<ul><li>delete需要调用对应的析构函数，擦除类型delete就不知道调用什么析构函数了。</li></ul></li></ol><h2 id="delete-工作过程">delete 工作过程</h2><ol><li>先调用析构函数</li><li>再调用operator delete（也可以进行重载）</li><li>释放空间</li></ol><h2 id="free是如何知道要释放多大的空间">free是如何知道要释放多大的空间</h2><p>malloc分配内存的时候，事实上多分配了16字节的空间(16 + mem)，返回值返回mem的首地址。free的时候，就会向左偏移16字节，这16字节的空间存储了内存块的描述信息，包含mem的大小。free就是通过这种方式来获取要释放的空间大小，并且正因为此，free释放时无需关注所需释放对象的类型。</p><h2 id="free释放内存后，这块内存还在吗">free释放内存后，这块内存还在吗</h2><ul><li>如果内存块是通过brk系统调用获得的，内存管理器会将这块内存插入到其维护的<code>空闲链表</code>或<code>空闲内存池</code>中，以便在后续的内存分配请求中复用。</li><li>如果是通过mmap系统调用获得的，这块内存会归还给操作系统。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十八：2296. 设计一个文本编辑器</title>
      <link href="/2025/02/27/leetcode28/"/>
      <url>/2025/02/27/leetcode28/</url>
      
        <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/design-a-text-editor/description/">2296. 设计一个文本编辑器</a>。</p><p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p><ul><li>添加：在光标所在处添加文本。</li><li>删除：在光标所在处删除文本（模拟键盘的删除键）。</li><li>移动：将光标往左或者往右移动。</li></ul><p>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候 0 &lt;= cursor.position &lt;= currentText.length 都成立。</p><p>请你实现 TextEditor 类：</p><ul><li>TextEditor() 用空文本初始化对象。</li><li>void addText(string text) 将 text 添加到光标所在位置。添加完后光标在 text 的右边。</li><li>int deleteText(int k) 删除光标左边 k 个字符。返回实际删除的字符数目。</li><li>string cursorLeft(int k) 将光标向左移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。</li><li>string cursorRight(int k) 将光标向右移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。</li></ul><p>最近真的是头大，Leetcode的每日一题怎么这几天一直搞这种设计题，苦不堪言。</p><p>解法参考Leetcode官方的解法，一开始准备使用双向链表的做法，但是发现第二种做法——使用栈来实现貌似更加简单，就是用了栈来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_len 1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *left;</span><br><span class="line">    <span class="type">char</span> *right;</span><br><span class="line">    <span class="type">int</span> leftSize;</span><br><span class="line">    <span class="type">int</span> rightSize;</span><br><span class="line">&#125; TextEditor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextEditor* <span class="title function_">textEditorCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    TextEditor *obj = (TextEditor*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TextEditor));</span><br><span class="line">    obj-&gt;left = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * max_len);</span><br><span class="line">    obj-&gt;right = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * max_len);</span><br><span class="line">    obj-&gt;leftSize = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;rightSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">textEditorAddText</span><span class="params">(TextEditor* obj, <span class="type">char</span>* text)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*text) &#123;</span><br><span class="line">        obj-&gt;left[obj-&gt;leftSize++] = *text;</span><br><span class="line">        ++text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">textEditorDeleteText</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;leftSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;left[--obj-&gt;leftSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        --k;</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">textEditorCursorLeft</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;leftSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;right[obj-&gt;rightSize++] = obj-&gt;left[--obj-&gt;leftSize];</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> retLen = MIN(<span class="number">10</span>, obj-&gt;leftSize);</span><br><span class="line">    <span class="type">char</span> * ret = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (retLen + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; retLen; ++i) </span><br><span class="line">        ret[i] = obj-&gt;left[obj-&gt;leftSize-retLen+i];</span><br><span class="line">    ret[retLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">textEditorCursorRight</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;rightSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;left[obj-&gt;leftSize++] = obj-&gt;right[--obj-&gt;rightSize];</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> retLen = MIN(<span class="number">10</span>, obj-&gt;leftSize);</span><br><span class="line">    <span class="type">char</span> * ret = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (retLen + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; retLen; ++i) </span><br><span class="line">        ret[i] = obj-&gt;left[obj-&gt;leftSize-retLen+i];</span><br><span class="line">    ret[retLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">textEditorFree</span><span class="params">(TextEditor* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;left) </span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;right) </span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor* obj = textEditorCreate();</span></span><br><span class="line"><span class="comment"> * textEditorAddText(obj, text);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = textEditorDeleteText(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * char* param_3 = textEditorCursorLeft(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * char* param_4 = textEditorCursorRight(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * textEditorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 设计 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一</title>
      <link href="/2025/02/26/dp1/"/>
      <url>/2025/02/26/dp1/</url>
      
        <content type="html"><![CDATA[<p>开启一个动态规划专栏，跟着灵茶山艾府学习一下动态规划，将动态规划按在地上摩擦。<a href="https://leetcode.cn/circle/discuss/tXLS3i/"><br>分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化）</a>。</p><p>题目为<a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a>。</p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><ul><li>输入：n = 2</li><li>输出：2</li><li>解释：有两种方法可以爬到楼顶。<ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol></li></ul><p>示例 2：</p><ul><li>输入：n = 3</li><li>输出：3</li><li>解释：有三种方法可以爬到楼顶。<ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></li></ul><h1>基本思路</h1><p>n = 1时有1种方法，n = 2时有2种方法；从第 3 阶开始，每一阶的爬法数等于前一阶的爬法数加上前两阶的爬法数，即 arr[i] = arr[i-1] + arr[i-2]。最终返回 arr[n]，即第 n 阶的爬法数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> * arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> * arr = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码虽然可以正确求解，但是存在一些问题：</p><ol><li>内存泄漏<ul><li>使用 malloc 分配的内存没有释放，会导致内存泄漏。</li></ul></li><li>空间复杂度优化<ul><li>使用数组存储所有阶的爬法数，空间复杂度为 O(n)，但实际上只需要前两个值即可，可以优化为 O(1) 的空间复杂度。<br>经优化获得如下实现：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cur = pre1 + pre2;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十六：2502. 设计内存分配器</title>
      <link href="/2025/02/25/leetcode26/"/>
      <url>/2025/02/25/leetcode26/</url>
      
        <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/design-memory-allocator/description/">2502. 设计内存分配器</a>。</p><p>给你一个整数 n ，表示下标从 0 开始的内存数组的大小。所有内存单元开始都是空闲的。</p><p>请你设计一个具备以下功能的内存分配器：</p><p>分配 一块大小为 size 的连续空闲内存单元并赋 id <code>mID</code> 。<br>释放 给定 id <code>mID</code> 对应的所有内存单元。<br>注意：</p><p>多个块可以被分配到同一个 mID 。<br>你必须释放<code>mID</code>对应的所有内存单元，即便这些内存单元被分配在不同的块中。<br>实现<code>Allocator</code>类：</p><p>Allocator(int n) 使用一个大小为 n 的内存数组初始化 Allocator 对象。<br>int allocate(int size, int mID) 找出大小为 size 个连续空闲内存单元且位于最左侧的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 -1 。<br>int freeMemory(int mID) 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</p><h1>分析理解</h1><p>题目要求实现一个内存管理单元。</p><p>函数allocate有两个参数：size和mID，size即需要找到size个内存块并且这些内存块得是连续的，mID即这些内存块得被赋值为mID。这个函数的返回值为这些内存块的首地址即下标索引。</p><p>函数freeMemory有一个参数mID，实现的功能为将所有内存单元中值为mID的单元释放，然后返回释放的内存单元的个数。</p><h1>基本思路</h1><p>我的第一想法是通过链表来进行组织这些内存块，然后通过哈希表、二维数组等记录未使用的内存块的数量和大小等。但是一直苦于将内存块按照大小进行排序这件事儿，感觉这么做将事情反而复杂化了，并且使用链表貌似也有点多余了。</p><p>最后看了看<a href="https://leetcode.cn/problems/design-memory-allocator/solutions/2016010/bao-li-mo-ni-by-endlesscheng-bqba/?envType=daily-question&amp;envId=2025-02-25">灵茶山艾府的题解</a>。他提供了两种方法：</p><ul><li>模拟</li><li>线段树</li></ul><p>看了看两种方法，感觉使用他的模拟解法就足够了。</p><p>基本思路是使用数组来组织内存块，在分配内存块时，并且全部初始化为0，表示内存块未使用（题目限定mID的取值范围为[1, 1000]）。然后从头开始遍历，寻找到一块大小为size的连续内存块，找不到则返回-1。回收内存块就更简单了，遍历所有内存块，内存块值为mID的均释放并设为0，并使用count进行计数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *mem;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Allocator</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span> ) * n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">this</span>-&gt;mem[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">allocate</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span> (count == size) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i - count + <span class="number">1</span>; j &lt; i + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    mem[j] = mID;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i - count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">freeMemory</span><span class="params">(<span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] == mID) &#123;</span><br><span class="line">                mem[i] = <span class="number">0</span>;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Allocator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Allocator* obj = new Allocator(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;allocate(size,mID);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;freeMemory(mID);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> * mem;</span><br><span class="line">    <span class="type">int</span> n;    </span><br><span class="line">&#125; Allocator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Allocator* <span class="title function_">allocatorCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Allocator * obj = (Allocator *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Allocator));</span><br><span class="line">    obj-&gt;mem = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    obj-&gt;n = n;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">allocatorAllocate</span><span class="params">(Allocator* obj, <span class="type">int</span> size, <span class="type">int</span> mID)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *mem = obj-&gt;mem;</span><br><span class="line">    <span class="type">int</span> n = obj-&gt;n;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">if</span> (count == size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - count + <span class="number">1</span>; j &lt; i + <span class="number">1</span>; ++j)</span><br><span class="line">                mem[j] = mID;</span><br><span class="line">            <span class="keyword">return</span> i - count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">allocatorFreeMemory</span><span class="params">(Allocator* obj, <span class="type">int</span> mID)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * mem = obj-&gt;mem;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = obj-&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i] == mID) &#123;</span><br><span class="line">            mem[i] = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocatorFree</span><span class="params">(Allocator* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;mem);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Allocator struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Allocator* obj = allocatorCreate(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = allocatorAllocate(obj, size, mID);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = allocatorFreeMemory(obj, mID);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * allocatorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>分配和释放内存函数的时间复杂度均为O(n)，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十五：1656. 设计有序流</title>
      <link href="/2025/02/24/leetcode25/"/>
      <url>/2025/02/24/leetcode25/</url>
      
        <content type="html"><![CDATA[<p>今日的 Leetcode 每日一题为<a href="https://leetcode.cn/problems/design-an-ordered-stream/description/">1656. 设计有序流</a>。</p><p>有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。</p><p>设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。</p><p>实现 OrderedStream 类：</p><ul><li>OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。</li><li>String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后：<ul><li>如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个  id + 1 。</li><li>否则，返回一个空列表。</li></ul></li></ul><h1>官方题解</h1><p>这道题采用了官方题解，解释的还是比较清楚的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> **stream;</span><br><span class="line">    <span class="type">int</span> streamSize;</span><br><span class="line">    <span class="type">int</span> ptr;</span><br><span class="line">&#125; OrderedStream;</span><br><span class="line"></span><br><span class="line">OrderedStream* <span class="title function_">orderedStreamCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    OrderedStream *obj = (OrderedStream *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OrderedStream));</span><br><span class="line">    obj-&gt;stream = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        obj-&gt;stream[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;streamSize = n + <span class="number">1</span>;</span><br><span class="line">    obj-&gt;ptr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ** <span class="title function_">orderedStreamInsert</span><span class="params">(OrderedStream* obj, <span class="type">int</span> idKey, <span class="type">char</span> * value, <span class="type">int</span>* retSize)</span> &#123;</span><br><span class="line">    obj-&gt;stream[idKey] = value;</span><br><span class="line">    <span class="type">char</span> **res = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * obj-&gt;streamSize);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;ptr &lt; obj-&gt;streamSize &amp;&amp; obj-&gt;stream[obj-&gt;ptr]) &#123;</span><br><span class="line">        res[pos++] = obj-&gt;stream[obj-&gt;ptr];</span><br><span class="line">        obj-&gt;ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    *retSize = pos;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">orderedStreamFree</span><span class="params">(OrderedStream* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;stream);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-an-ordered-stream/solutions/1749068/she-ji-you-xu-liu-by-leetcode-solution-3imb/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1>对官方题解进行改善</h1><p>感觉官方将C语言实现里的insert函数中的res内嵌到结构体里比较好，大小与流的大小相同，这样就不必反复分配内存，以及后续忘记释放了。一下是我进行了改进的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> **str;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ptr;</span><br><span class="line">    <span class="type">char</span> **buffer; </span><br><span class="line">&#125; OrderedStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OrderedStream* <span class="title function_">orderedStreamCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    OrderedStream* obj = (OrderedStream*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OrderedStream));</span><br><span class="line">    obj-&gt;str = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">        obj-&gt;str[i] = <span class="literal">NULL</span>;</span><br><span class="line">    obj-&gt;n = n;</span><br><span class="line">    obj-&gt;ptr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配缓冲区大小</span></span><br><span class="line">    obj-&gt;buffer = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * n);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** <span class="title function_">orderedStreamInsert</span><span class="params">(OrderedStream* obj, <span class="type">int</span> idKey, <span class="type">char</span>* value, <span class="type">int</span>* retSize)</span> &#123;</span><br><span class="line">    obj-&gt;str[idKey] = value;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;ptr &lt;= obj-&gt;n &amp;&amp; obj-&gt;str[obj-&gt;ptr])</span><br><span class="line">        obj-&gt;buffer[pos++] = obj-&gt;str[obj-&gt;ptr++];</span><br><span class="line">    *retSize = pos;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">orderedStreamFree</span><span class="params">(OrderedStream* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;str);</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;buffer);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your OrderedStream struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * OrderedStream* obj = orderedStreamCreate(n);</span></span><br><span class="line"><span class="comment"> * char** param_1 = orderedStreamInsert(obj, idKey, value, retSize);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * orderedStreamFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 设计 </tag>
            
            <tag> 数据流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十四：1206. 设计跳表</title>
      <link href="/2025/02/23/leetcode24/"/>
      <url>/2025/02/23/leetcode24/</url>
      
        <content type="html"><![CDATA[<p>今日 Leetcode 每日一题为<a href="https://leetcode.cn/problems/design-skiplist/description/">1206. 设计跳表</a>。</p><p>不使用任何库函数，设计一个 跳表 。</p><p>跳表是在<code>O(log n)</code>时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：<br><img src="/images/1702370216-mKQcTt-1506_skiplist.gif" alt=""><br>注：图片来源于Leetcode <a href="https://leetcode.cn/problems/design-skiplist/description/">https://leetcode.cn/problems/design-skiplist/description/</a></p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>了解更多 : <a href="https://oi-wiki.org/ds/skiplist/">https://oi-wiki.org/ds/skiplist/</a></p><p>在本题中，你的设计应该要包含这些函数：</p><ul><li>bool search(int target) : 返回target是否存在于跳表中。</li><li>void add(int num): 插入一个元素到跳表。</li><li>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。</li></ul><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><h1>分析理解</h1><p>这道题目让我们设计一个数据结构——跳表。在这之前确实不怎么了解跳表，仔细看了一会儿发现跳表和链表有点像，但是跳表应该说是一个多层链表。其中第0层是包含所有元素的有序链表；1层及以上，每一层都是下一层的子集，作为索引层，帮助快速跳过多个元素。每一层的元素通过指针连接，高层元素会指向低层的相同元素，形成一个“跳跃”的结构。</p><p>跳表有三个核心操作：</p><ol><li>查找</li><li>插入</li><li>删除</li></ol><p>跳表的应用还挺广泛的，Redis的有序集合（Sorted Set）底层就使用了跳表。</p><p>跳表可以实现操作复杂度为O(log n)的查找、插入和删除，还是挺高效的。谈一谈个人对这的理解吧。不管跳表还是链表，都离不开查找、插入和删除三个核心操作，而私以为插入和删除都是基于查找操作的，只要查找得快，插入和删除得也就快。</p><p>链表查找的时候，最坏的情况下是O(n)，就是遍历了整个表。而跳表作为多层链表，可以跳过遍历某些元素，从而加快查找速度，举个简单的例子。</p><p>假设我们要在跳表中查找值 7，跳表的结构如下：</p><ul><li>第2层（最高层）：1 -&gt; 9</li><li>第1层：1 -&gt; 5 -&gt; 9</li><li>第0层（底层）：1 -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 9</li></ul><p>查找过程：</p><ol><li>从最高层（第2层）开始：<ul><li>当前节点是 1，下一个节点是 9。</li><li>9 大于 7，所以不能直接跳到 9，而是向下移动到第1层。</li></ul></li><li>在第1层：<ul><li>当前节点是 1，下一个节点是 5。</li><li>5 小于 7，所以跳到 5。</li><li>从 5 开始，下一个节点是 9。</li><li>9 大于 7，所以向下移动到第0层。</li></ul></li><li>在第0层：<ul><li>当前节点是 5，下一个节点是 7。</li><li>7 等于目标值，查找成功。</li></ul></li></ol><p>基于上述过程可以大概了解跳表的查询过程，可以看到跳表在查询7的时候跳过了对3的遍历。这个例子或许并不能很好地体现跳表的高效，但是在规模较大时，会跳过对很多元素的遍历，产生较好的效果。</p><p>此外，还有一点。跳表依赖于随机算法。在最坏的情况下会退化成单层有序链表。因此随机算法的选择很重要。</p><h1>基本思路</h1><p>这道题我是一点思路都没有，研究了许久官方题解中的C语言实现。一直感觉C语言是不错的语言，虽然有诸多的不便，没有面向对象，没有类似于C++的模板。但是也不可否认C语言的精妙。所以，基本思路：抄！doge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> P_FACTOR = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SkiplistNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;SkiplistNode *&gt; forward;</span><br><span class="line">    <span class="built_in">SkiplistNode</span>(<span class="type">int</span> _val, <span class="type">int</span> _maxLevel = MAX_LEVEL) : <span class="built_in">val</span>(_val), forward(_maxLevel, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SkiplistNode * head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    mt19937 gen&#123;random_device&#123;&#125;()&#125;;</span><br><span class="line">    uniform_real_distribution&lt;<span class="type">double</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Skiplist</span>(): <span class="built_in">head</span>(<span class="keyword">new</span> <span class="built_in">SkiplistNode</span>(<span class="number">-1</span>)), <span class="built_in">level</span>(<span class="number">0</span>), <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 target 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">        <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;SkiplistNode *&gt; <span class="title">update</span><span class="params">(MAX_LEVEL, head)</span></span>;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lv = <span class="built_in">randomLevel</span>();</span><br><span class="line">        level = <span class="built_in">max</span>(level, lv);</span><br><span class="line">        SkiplistNode *newNode = <span class="keyword">new</span> <span class="built_in">SkiplistNode</span>(num, lv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">            <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">            newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">            update[i]-&gt;forward[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;SkiplistNode *&gt; <span class="title">update</span><span class="params">(MAX_LEVEL, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* 如果值不存在则返回 false */</span></span><br><span class="line">        <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span></span><br><span class="line">            update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="comment">/* 更新当前的 level */</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head-&gt;forward[level - <span class="number">1</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dis</span>(gen) &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;</span><br><span class="line">            lv++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-skiplist/solutions/1696545/she-ji-tiao-biao-by-leetcode-solution-e8yh/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P_FACTOR = RAND_MAX &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> maxLevel;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> **<span class="title">forward</span>;</span></span><br><span class="line">&#125; SkiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SkiplistNode *head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; Skiplist;</span><br><span class="line"></span><br><span class="line">SkiplistNode *<span class="title function_">skiplistNodeCreat</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> maxLevel)</span> &#123;</span><br><span class="line">    SkiplistNode *obj = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode));</span><br><span class="line">    obj-&gt;val = val;</span><br><span class="line">    obj-&gt;maxLevel = maxLevel;</span><br><span class="line">    obj-&gt;forward = (SkiplistNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode *) * maxLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLevel; i++) &#123;</span><br><span class="line">        obj-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeFree</span><span class="params">(SkiplistNode* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;forward) &#123;</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;forward);</span><br><span class="line">        obj-&gt;forward = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;maxLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *obj = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Skiplist));</span><br><span class="line">    obj-&gt;head = skiplistNodeCreat(<span class="number">-1</span>, MAX_LEVEL);</span><br><span class="line">    obj-&gt;level = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SkiplistNode * curr = obj-&gt;head; curr; ) &#123;</span><br><span class="line">        SkiplistNode *prev = curr;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        skiplistNodeFree(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">    <span class="keyword">while</span> (rand() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;</span><br><span class="line">        lv++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 target 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">    <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lv = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; i++) &#123;</span><br><span class="line">            update[i] = obj-&gt;head;</span><br><span class="line">        &#125;</span><br><span class="line">        obj-&gt;level = lv;</span><br><span class="line">    &#125;</span><br><span class="line">    SkiplistNode *newNode = skiplistNodeCreat(num, lv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">        newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 如果值不存在则返回 false */</span></span><br><span class="line">    <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span></span><br><span class="line">        update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    skiplistNodeFree(curr);</span><br><span class="line">    <span class="comment">/* 更新当前的 level */</span></span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        obj-&gt;level--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-skiplist/solutions/1696545/she-ji-tiao-biao-by-leetcode-solution-e8yh/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>我主要围绕着C语言的实现进行一下理解，便于日后复习。理解了C语言版本，C++版本也就不难了。</p><h2 id="代码理解">代码理解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P_FACTOR = RAND_MAX &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>首先定义了两个常量MAX_LEVEL和P_FACTOR。MAX_LEVEL是跳表的最大层数，而P_FACTOR是一个概率，这里称它为概率或许有点牵强，结合着函数randomLevel应该就不难理解了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">    <span class="keyword">while</span> (rand() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) </span><br><span class="line">        lv++;</span><br><span class="line">    <span class="keyword">return</span> lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数randomLevel是一个静态的内联函数，由关键字<code>static</code>和<code>inline</code>标识。</p><h3 id="static关键字"><code>static</code>关键字</h3><p><code>static</code>将函数的作用域限制在当前文件内，其他文件无法访问这个函数。这里使用static关键字标识这个函数有以下好处：</p><ol><li>避免命名冲突<ul><li>如果其他文件中也定义了同名的 randomLevel 函数，链接时会发生冲突。</li><li>使用 static 可以确保这个函数只在当前文件中可见，避免冲突。</li></ul></li><li>封装性<ul><li>randomLevel 是跳表内部使用的辅助函数，不需要暴露给外部。</li></ul></li></ol><h3 id="inline关键字"><code>inline</code>关键字</h3><p><code>inline</code>关键字将函数标识为<code>内联函数</code>，提示编译器将函数内联展开，即将函数的代码直接插入到调用处，而不是通过函数调用的方式执行。使用<code>inline</code>关键字有以下好处：</p><ol><li>减少函数调用开销<ul><li>函数调用需要保存上下文、跳转到函数地址、执行完后再返回，这些操作有一定的开销。</li><li>randomLevel 是一个简单的函数，内联展开可以避免这些开销，提高性能。</li></ul></li><li>适合小型函数<ul><li>randomLevel 的逻辑非常简单（只是一个循环），适合内联展开。</li><li>如果函数体较大，内联可能会导致代码膨胀，反而降低性能。所以说不是所有的函数都适合作内联声明。</li></ul></li><li>编译器优化<ul><li>inline 是对编译器的建议，编译器可以选择是否真正内联展开。</li></ul></li></ol><h3 id="randomLevel-函数">randomLevel 函数</h3><p>randomLevel函数的作用是生成一个随机数，随机数的区间为[1, MAX_LEVEL]即[1, 32]。lv从1开始，每次以25%的概率递增。为什么是25%呢？这就得看开头的静态常量P_FACTOR，P_FACTOR = RAND_MAX &gt;&gt; 2。RAND_MAX为rand函数能生成的随机数的最大值，然后右移两位，也就是除以4。rand能生成的随机数区间为[1, RAND_MAX]，当生成的随机数小于P_FACTOR即RAND_MAX / 4时进行递增。生成的随机数小于P_FACTOR的区间占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，大于P_FACTOR的区间占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>3</mn></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，这也不难理解为什么是25%概率。还有就是随机数的生成需要初始化随机数种子，这一步在跳表的创建中通过<code>srand(time(NULL))</code>实现了。</p><h3 id="跳表有关结构体">跳表有关结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> maxLevel;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> **<span class="title">forward</span>;</span></span><br><span class="line">&#125; SkiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SkiplistNode *head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; Skiplist;</span><br></pre></td></tr></table></figure><p>类似于链表，其中SkiplistNode是跳表中<code>节点的定义</code>，Skiplist是<code>跳表的定义</code>。</p><p><code>SkiplistNode</code>结构体内val代表节点存储的值，maxLevel为该节点的最大层数。需要注意的是如果某个节点的maxLevel值为4，那么说明该节点存在于第0、1、2、3层。结构体内的forward是一个指针数组，而forward[i]指向该节点在第i层的下一个节点。</p><p><code>Skiplist</code>结构体，个人感觉不用它也可以，但是使用后方便管理，主要是方便参数的地址传递。这样每次只需要将Skiplist类型的指针传递给函数即可，否则既要传指向*head的指针，又要传指向level的指针，实属不方便。还需要注意的一点是level的值，它其实是跳表中所有节点中maxLevel值最大的那一个。</p><h3 id="跳表节点的创建">跳表节点的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *<span class="title function_">skiplistNodeCreat</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> maxLevel)</span> &#123;</span><br><span class="line">    SkiplistNode *obj = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode));</span><br><span class="line">    obj-&gt;val = val;</span><br><span class="line">    obj-&gt;maxLevel = maxLevel;</span><br><span class="line">    obj-&gt;forward = (SkiplistNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode *) * maxLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLevel; i++) </span><br><span class="line">        obj-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很好理解，就是为跳表节点分配内存，初始化跳表节点中的val、maxLevel，为跳表节点的指针数组forward分配内存，并将所有的成员指向NULL。</p><h3 id="跳表节点的释放">跳表节点的释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeFree</span><span class="params">(SkiplistNode* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;forward) &#123;</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;forward);</span><br><span class="line">        obj-&gt;forward = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;maxLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了跳表节点的创建，那么释放也不难理解，相当于将创建节点时所做的事儿反过来做一遍。释放forward（在释放前先检查其是否为NULL，避免反复释放），释放跳表节点所占用内存。</p><h3 id="跳表的创建与释放">跳表的创建与释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *obj = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Skiplist));</span><br><span class="line">    obj-&gt;head = skiplistNodeCreat(<span class="number">-1</span>, MAX_LEVEL);</span><br><span class="line">    obj-&gt;level = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SkiplistNode * curr = obj-&gt;head; curr; ) &#123;</span><br><span class="line">        SkiplistNode *prev = curr;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        skiplistNodeFree(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块也类似于跳表节点的创建与释放，不再赘述。</p><h3 id="跳表的搜索">跳表的搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target)</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">    <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回target是否存在于跳表中，存在返回true，否则返回false。</p><p>我开始看到这段代码是大写的懵逼，调试了一会儿才明白是怎么个事儿。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target)</span><br><span class="line">        curr = curr-&gt;forward[i];</span><br></pre></td></tr></table></figure><p>理解了这段循环体应该就差不多了。还要强调的一点是跳表的头节点存在于每一层。</p><p>从跳表的最高层开始遍历，在每层定位到最后一个小于target的节点，就向下移动一层。当遍历到最后一层时，就找到了最底层最后一个小于target的节点，它的下一个节点很有可能就是目标节点。使用<code>cur = cur-&gt;forward[0]</code>让cur指向该节点，检查其是否为NULL，不为NULL就再检查节点的值是否为target即可。</p><p>查找过程是从最高层开始，逐层向下查找目标值。</p><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *curr = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>curr 指向跳表的头节点。</li></ul><ol start="2"><li>从最高层开始查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br></pre></td></tr></table></figure><ul><li>obj-&gt;level 是跳表当前的最大层数。</li><li>从最高层（obj-&gt;level - 1）开始，逐层向下查找。</li></ul><ol start="3"><li>在当前层向右查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) </span><br><span class="line">    curr = curr-&gt;forward[i];</span><br></pre></td></tr></table></figure><ul><li>curr-&gt;forward[i] 是当前节点在第 i 层的下一个节点。</li><li>如果下一个节点的值小于 target，则继续向右移动。</li><li>这个过程会跳过多个节点，快速接近目标值。</li></ul><ol start="4"><li>移动到下一层</li></ol><ul><li>当在当前层无法继续向右移动时，向下移动到下一层<code>（i--）</code>，继续查找。</li></ul><ol start="5"><li>最终定位到目标节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curr = curr-&gt;forward[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>查找结束后，curr 指向第0层中最后一个小于 target 的节点。</li><li>curr-&gt;forward[0] 是第0层中下一个节点，可能是目标节点。</li></ul><ol start="6"><li>检查是否找到目标值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>如果 curr-&gt;forward[0] 存在且值等于 target，则返回 true。</li><li>否则返回 false。</li></ul><h3 id="跳表中节点的添加">跳表中节点的添加</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lv = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; i++) &#123;</span><br><span class="line">            update[i] = obj-&gt;head;</span><br><span class="line">        &#125;</span><br><span class="line">        obj-&gt;level = lv;</span><br><span class="line">    &#125;</span><br><span class="line">    SkiplistNode *newNode = skiplistNodeCreat(num, lv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">        newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skiplistAdd 的作用是向跳表中插入一个值为 num 的节点。插入时需要：</p><ol><li>找到每一层中最后一个小于 num 的节点。</li><li>随机生成新节点的层数。</li><li>将新节点插入到每一层的正确位置。</li></ol><h4 id="插入过程">插入过程</h4><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">SkiplistNode *cur = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>update是一个指针数组，用于记录每一层中最后一个小于num的节点。</li><li>cur是当前节点，初始化为跳表的头节点。</li></ul><ol start="2"><li>查找插入位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;forward[i] &amp;&amp; cur-&gt;forward[i]-&gt;val &lt; num) </span><br><span class="line">        cur = cur-&gt;forward[i];</span><br><span class="line">    update[i] = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从最高处(<code>obj-&gt;level-1</code>)开始，逐层向下查找。</li><li>在每一层中，向右移动cur，直到找到最后一个小于num的节点。</li><li>将cur记录到update[i]，表示在第i层，应将新节点插入update[i]的后面。</li></ul><ol start="3"><li>随机生成新节点的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lv = randomLevel();</span><br></pre></td></tr></table></figure><ul><li>调用 randomLevel 函数，随机生成新节点的层数 lv。</li></ul><ol start="4"><li>更新跳表的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; ++i) </span><br><span class="line">        update[i] = obj-&gt;head;</span><br><span class="line">    obj-&gt;level = lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果新节点的层数lv大于跳表的层数obj-&gt;level，需要更新跳表的层数</li><li>对于新增的层（obj-&gt;level-1到lv-1），将update[i]初始化为头节点obj-&gt;head。</li><li>更新跳表的层数obj-&gt;level为lv。</li></ul><ol start="5"><li>创建新节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode * newNode = skiplistNodeCreate(num, lv);</span><br></pre></td></tr></table></figure><ul><li>调用 skiplistNodeCreate 函数，创建一个值为 num、层数为 lv 的新节点。</li></ul><ol start="6"><li>插入新节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; ++i) &#123;</span><br><span class="line">    newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">    update[i]-&gt;forward[i] = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历新节点的每一层（从第0层到第 lv - 1 层）：<ul><li>将新节点的 forward[i] 指向 update[i]-&gt;forward[i]。</li><li>将 update[i]-&gt;forward[i] 指向新节点。</li></ul></li></ul><p>这样，新节点就被插入到每一层的正确位置。</p><h3 id="跳表节点的删除">跳表节点的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    skiplistNodeFree(curr);</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        obj-&gt;level--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skiplistErase 的作用是从跳表中删除值为 num 的节点。如果节点存在并成功删除，返回 true；否则返回 false。</p><h4 id="删除过程">删除过程</h4><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">SkiplistNode *curr = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>update 数组用于记录每一层中需要更新的节点。</li><li>curr 指向跳表的头节点（head），用于遍历跳表</li></ul><ol start="2"><li>查找待删除节点的位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) </span><br><span class="line">        curr = curr-&gt;forward[i];</span><br><span class="line">    update[i] = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从最高层开始，逐层向下查找值为 num 的节点。</li><li>在每一层中，找到最后一个小于 num 的节点，并记录到 update[i] 中。</li><li>这个过程和 skiplistSearch 类似，目的是定位待删除节点的位置。</li></ul><ol start="3"><li>定位待删除节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">curr 现在指向第<span class="number">0</span>层中最后一个小于 num 的节点。</span><br></pre></td></tr></table></figure><ul><li>curr-&gt;forward[0] 是第0层中下一个节点，可能是待删除节点</li></ul><ol start="4"><li>检查节点是否存在</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!curr || curr-&gt;val != num) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>如果 curr-&gt;forward[0] 不存在，或者它的值不等于 num，说明节点不存在，返回 false。</li></ul><ol start="5"><li>更新每一层的指针</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历每一层，更新指向待删除节点的指针。</li><li>如果 update[i]-&gt;forward[i] 不等于 curr，说明在这一层中不需要更新（因为待删除节点不在这一层），并且是从底层向高层遍历的，所以后面的所有层也不需要更新，break退出。</li><li>否则，将 update[i]-&gt;forward[i] 指向 curr-&gt;forward[i]，跳过待删除节点。</li></ul><ol start="6"><li>释放待删除节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skiplistNodeFree(curr);</span><br></pre></td></tr></table></figure><p>调用 skiplistNodeFree 函数释放待删除节点的内存。</p><ol start="7"><li>更新跳表的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) </span><br><span class="line">    obj-&gt;level--;</span><br></pre></td></tr></table></figure><ul><li>如果删除节点后，某些层变为空（即头节点在这一层的下一个节点为 NULL），则降低跳表的层数。</li><li>这是为了确保跳表的层数不会过高，避免浪费空间。</li></ul><ol start="8"><li>返回结果</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>删除成功，返回 true。</li></ul><p>到此整个代码可算是理解完毕了QvQ。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 设计 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 跳表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十三：2506. 统计相似字符串对的数目</title>
      <link href="/2025/02/22/leetcode23/"/>
      <url>/2025/02/22/leetcode23/</url>
      
        <content type="html"><![CDATA[<p>今日 Leetcode 每日一题为<a href="https://leetcode.cn/problems/count-pairs-of-similar-strings/description/">2506. 统计相似字符串对的数目</a>。</p><p>给你一个下标从 0 开始的字符串数组 words 。</p><p>如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。</p><ul><li>例如，“abca” 和 “cba” 相似，因为它们都由字符 ‘a’、‘b’、‘c’ 组成。</li><li>然而，“abacba” 和 “bcfd” 不相似，因为它们不是相同字符组成的。</li></ul><p>请你找出满足字符串 words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 &lt;= i &lt; j &lt;= words.length - 1 。</p><h1>分析理解</h1><p>题目给了一个数组，数组存放的是字符串，然后要求我们统计相似字符串的对数。而相似字符串就是出现的字母相同的字符串，无论字母的个数，看例子就能很好的明白。</p><h1>基本思路</h1><p>枚举每个字符串中的每个字符是否出现，然后比较逐个比较每对字符串即可。</p><p>按照上述思路应使用的数据结构是哈希表，但是其实使用一个int型变量即可。因为题目限定了每个字符串中出现的字母均为小写字母，而小写字母为26个，int型变量为4字节为32位，刚好满足需要。初始时置为0，从最低位依次开始记录字母a、b、c、d……是否出现即可，出现就将该位置为1。通过移位和或操作，<code>bitNum[i] = bitNum[i] | (1 &lt;&lt; (words[i][j] - 'a'))</code>即可。这里减掉’a’是因为小写字母对应的ASCII码值为97~122。如果直接左移的话就左移97~122位了，减去’a’后就是左移0~25.</p><p>使用int变量记录每个字符串中每个字母是否出现之后，每个字符串就对应一个值。如果两个字符串是相似字符串，那么他们对应的值相等。将每个字符串对应的值使用数组存储后，使用两层循环枚举即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">similarPairs</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">     <span class="type">int</span>* bitNum = <span class="keyword">new</span> <span class="type">int</span>[n]&#123;&#125;;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">         <span class="type">int</span>&amp; cur = bitNum[i];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str: words[i])</span><br><span class="line">             cur = cur | (<span class="number">1</span> &lt;&lt; (str - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)        </span><br><span class="line">         res += (bitNum[i] == bitNum[j]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">similarPairs</span><span class="params">(<span class="type">char</span>** words, <span class="type">int</span> wordsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * bitNum = (<span class="type">int</span> *)<span class="built_in">calloc</span>(wordsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(words[i]); ++j) &#123;</span><br><span class="line">            bitNum[i] = bitNum[i] | (<span class="number">1</span> &lt;&lt; (words[i][j] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsSize; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; wordsSize; ++j) </span><br><span class="line">            <span class="keyword">if</span> (bitNum[i] == bitNum[j])</span><br><span class="line">                ++res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(n * min(m, n))，其中 n 是数组 words 的长度，m 是数组 words 中单个字符串的平均长度。<br>空间复杂度为O(n)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十二：2209. 用地毯覆盖后的最少白色砖块</title>
      <link href="/2025/02/21/leetcode22/"/>
      <url>/2025/02/21/leetcode22/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/description/">2209. 用地毯覆盖后的最少白色砖块</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十一：2595. 奇偶位数</title>
      <link href="/2025/02/20/leetcode21/"/>
      <url>/2025/02/20/leetcode21/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/number-of-even-and-odd-bits/description/">2595. 奇偶位数</a>。</p><p>给你一个正整数 n 。</p><p>用 even 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的偶数下标的个数。</p><p>用 odd 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的奇数下标的个数。</p><p>请注意，在数字的二进制表示中，位下标的顺序 从右到左。</p><p>返回整数数组 answer ，其中 answer = [even, odd] 。</p><h1>思路分析</h1><p>使用int型变量even和odd分别记录，对n进行移位操作，因为记录的是1的个数，因此直接在移位操作后直接加在even或者odd上即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">evenOddBit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> even = <span class="number">0</span>, odd = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;&gt; pos != <span class="number">0</span>) &#123;</span><br><span class="line">            even += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">            odd += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;even, odd&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">evenOddBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;&gt; pos != <span class="number">0</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>] += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">        res[<span class="number">1</span>] += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(log n)，空间复杂度为O(1)。灵茶山艾府就比较厉害了，使用了位掩码的办法，实现了O(1)复杂度的算法。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二十：624. 数组列表中的最大距离</title>
      <link href="/2025/02/19/leetcode20/"/>
      <url>/2025/02/19/leetcode20/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/maximum-distance-in-arrays/description/">624. 数组列表中的最大距离</a>。</p><p>给定 m 个数组，每个数组都已经按照升序排好序了。</p><p>现在你需要从两个不同的数组中选择两个整数（每个数组选一个）并且计算它们的距离。两个整数 a 和 b 之间的距离定义为它们差的绝对值 |a-b| 。</p><h1>分析理解</h1><p>题目意思很明确，并且每个数组中的数是按升序排列的，我们需要返回不同数组中的两个数的差值的绝对值，并且这个差值的绝对值得是最大的那个。</p><h1>思路分析</h1><p>暴力的做法是枚举所有的差值的绝对值进行比较，返回绝对值最大的那个即可，但是这种做法显然有提升空间，并且效率不高，复杂度为二阶。</p><p>然后我一开始的想法是比较所有数组的最大值和最小值，然后取出这些最大值中的最大值和最小值中的最小值，返回他们的差值即可，但是无法排除他们在同一个数组中的情况。</p><p>紧接着，我先找出最小值中的最小值，然后记录下其下标；然后在寻找最大值中的最大值时，排除这个下标即可。但是依然无法排除某些特殊情况，如对于[[-2],[-3,-2,1]]，会记录数组②中的-3为最小值，记录数组①中的-2为最大值，得到结果1。但应该是1-(-2)=3。</p><p>于是乎我又开始先找出最大值中的最大值，然后最小值中的最小值，但是依然无法排除某些特殊情况。</p><p>再于是乎，我转向了灵茶山艾府的题解。他的思路很清晰，解释得也比较清楚。基本思路是遍历每个数组，先计算当前数组与记录的最小值和记录的最大值之间的最大距离。记录的最小值和最大值为min_a和max_b，然后当前数组的最大值是最后一个元素，它减去min_a可能是一个候选结果；最小值是第一个元素，max_b减去它是一个候选结果。然后更新min_a和max_b。最终即可得到结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; arrays)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = arrays.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min_a = arrays[<span class="number">0</span>][<span class="number">0</span>], max_b = arrays[<span class="number">0</span>].<span class="built_in">back</span>();</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="built_in">max</span>(max_b - arrays[i].<span class="built_in">front</span>(), arrays[i].<span class="built_in">back</span>() - min_a), ans);</span><br><span class="line">            min_a = <span class="built_in">min</span>(min_a, arrays[i].<span class="built_in">front</span>());</span><br><span class="line">            max_b = <span class="built_in">max</span>(max_b, arrays[i].<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>** arrays, <span class="type">int</span> arraysSize, <span class="type">int</span>* arraysColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min_a = arrays[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max_b = arrays[<span class="number">0</span>][arraysColSize[<span class="number">0</span>]<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arraysSize; ++i) &#123;</span><br><span class="line">        ans = max(max(max_b - arrays[i][<span class="number">0</span>], arrays[i][arraysColSize[i]<span class="number">-1</span>] - min_a), ans);</span><br><span class="line">        min_a = min(min_a, arrays[i][<span class="number">0</span>]);</span><br><span class="line">        max_b = max(max_b, arrays[i][arraysColSize[i]<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十九：2080. 区间内查询数字的频率</title>
      <link href="/2025/02/18/leetcode19/"/>
      <url>/2025/02/18/leetcode19/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/range-frequency-queries/description/">2080. 区间内查询数字的频率</a>。</p><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。</p><p>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。</p><p>请你实现<code>RangeFreqQuery</code>类：</p><ul><li>RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。</li><li>int query(int left, int right, int value) 返回子数组 arr[left…right] 中 value 的 频率 。</li></ul><p>一个 子数组 指的是数组中一段连续的元素。arr[left…right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。</p><h1>分析理解</h1><p>目标是实现一个数据结构，该数据结构能够在给定一个数组的情况下，返回在指定下标范围内特定值的频率。指定下标范围记作[left, right]。</p><h1>基本思路</h1><p>基本思路是使用哈希表将数组中的数值与其出现的下标位置建立映射关系，下标位置使用数组就可以存储。然后再使用二分查找，并且是两次二分查找：</p><ul><li>第一次二分查找用于查找下标位置数组中第一个大于right的值。</li><li>第二次二分查找用于查找下标位置数组中第一个小于等于left的值。</li></ul><p>二者进行相减即为所求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeFreqQuery</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; hash;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RangeFreqQuery</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            hash[arr[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (it == hash.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;&amp; nums = hash[value];</span><br><span class="line">        <span class="comment">// return ranges::upper_bound(nums, right) - ranges::lower_bound(nums, left);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">upper_bound</span>(nums, right) - <span class="built_in">lower_bound</span>(nums, left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; value)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= value)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RangeFreqQuery object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RangeFreqQuery* obj = new RangeFreqQuery(arr);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;query(left,right,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>C语言哈希表库的使用请查看这篇文章<a href="https://malone-ai.github.io/2025/02/18/c1">C语言哈希表库使用</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言哈希表库使用</title>
      <link href="/2025/02/18/c1/"/>
      <url>/2025/02/18/c1/</url>
      
        <content type="html"><![CDATA[<p>写一篇博客记录一下C语言的哈希表库的使用。哈希表说白了就是Python的字典，我认为二者几乎无异。本文主要讨论的是uthash库。</p><h1>使用步骤</h1><ol><li>安装与包含<br>uthash是一个单文件头库，只需要下载<code>uthash.h</code>库并将其包含在项目中即可。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义结构体<br>定义一个结构体来表示哈希表中的元素，并且结构体中必须包含<code>UT_hash_handle</code>类型的字段。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 值</span></span><br><span class="line">    UT_hash_handle hh; <span class="comment">// 声明一个UT_hash_handle类型的变量</span></span><br><span class="line">&#125;Hash;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化哈希表<br>哈希表是一个指向Hash类型的指针，初始时设为<code>NULL</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash* hash = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>插入元素<br>使用<code>HASH_ADD_INT</code>宏将元素插入哈希表。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hash* item = (Hash*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Hash));</span><br><span class="line">item-&gt;key = key;    <span class="comment">// 此处的key你可以任意指定</span></span><br><span class="line">item-&gt;value = value;    <span class="comment">// 此处的value你可以任意指定</span></span><br><span class="line">HASH_ADD_INT(hash, key, item);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十八：1287. 有序数组中出现次数超过25%的元素</title>
      <link href="/2025/02/17/leetcode18/"/>
      <url>/2025/02/17/leetcode18/</url>
      
        <content type="html"><![CDATA[<p>今日Leecode每日一题为<a href="https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/">1287. 有序数组中出现次数超过25%的元素</a>。</p><p>给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。</p><p>请你找到并返回这个整数</p><h1>基本思路</h1><p>数组是<code>非递减</code>顺序的，那就好办了，直接遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSpecialInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == res) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">if</span> (count &gt;= (n / <span class="number">4</span> + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = arr[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findSpecialInteger</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == res) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= n / <span class="number">4</span> + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = arr[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十七：1299. 将每个元素替换为右侧最大元素</title>
      <link href="/2025/02/16/leetcode17/"/>
      <url>/2025/02/16/leetcode17/</url>
      
        <content type="html"><![CDATA[<p>今日Leecode每日一题为<a href="https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/description/">1299. 将每个元素替换为右侧最大元素</a>。</p><p>给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。</p><p>完成所有替换操作后，请你返回这个数组。</p><h1>分析理解</h1><p>题目很好理解，无需多言。</p><h1>基本思路</h1><p>从最后一个元素开始向前遍历，然后维护一个从当前元素往后的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">replaceElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cur_max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = cur_max;</span><br><span class="line">            cur_max = <span class="built_in">max</span>(cur_max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">replaceElements</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cur_max = <span class="number">-1</span>;</span><br><span class="line">    *returnSize = arrSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = cur_max;</span><br><span class="line">        cur_max = Max(cur_max, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十六：1706. 球会落何处</title>
      <link href="/2025/02/15/leetcode16/"/>
      <url>/2025/02/15/leetcode16/</url>
      
        <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/where-will-the-ball-fall/description/">1706. 球会落何处</a>。</p><p>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。</p><p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p><ul><li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。</li><li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。</li></ul><p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p><p>返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。</p><h1>分析理解</h1><p>给了一个矩阵，矩阵中每个元素要么为1要么为-1，为1代表挡板连接左上角和右下角；为-1代表挡板连接右上角和左下角。然后从最上层出发的每个小球最终落点的位置，使用下标表示，其中如果小球不能达到底部就返回-1。</p><h1>基本思路</h1><p>看到题目是一脸懵逼，直接看灵茶山艾府的解题思路，一看大家基本上都是灵茶山艾府的思路（doge）。</p><p>他的思路是，从列开始遍历，一列一列地遍历。而在对每列的遍历中，进行逐行遍历。开始行遍历之前，记录下当前遍历的列号，然后进入行遍历，在列号上加上当前位置所对应位置的值，相当于左右移动。然后每次记录进行加法后的列号是否小于0或者大于列尺寸最大值（此时出界，对应于卡在边界），是否此时的列号所对应的矩阵元素值是否与上一次列号所对应的矩阵元素值相等（此时如果不相等，则形成了“V”形）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findBall</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> cur = j;</span><br><span class="line">            <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;row: grid) &#123;</span><br><span class="line">                <span class="type">int</span> d = row[cur];</span><br><span class="line">                cur += d;</span><br><span class="line">                <span class="keyword">if</span> (cur &lt; <span class="number">0</span> || cur &gt;= n || row[cur] != d) &#123;</span><br><span class="line">                    cur = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[j] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findBall</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize, <span class="type">int</span>* returnSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    *returnSize = *gridColSize;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">    <span class="type">int</span>* p = res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; *gridColSize; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> cur = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gridSize; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> d = grid[i][cur];</span><br><span class="line">            cur += d;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="number">0</span> || cur &gt;= *gridColSize || grid[i][cur] != d) &#123;</span><br><span class="line">                cur = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *p = cur;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 矩阵 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十五：1552. 两球之间的磁力</title>
      <link href="/2025/02/14/leetcode15/"/>
      <url>/2025/02/14/leetcode15/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode 每日一题为<a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/description/">1552. 两球之间的磁力</a>：</p><p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p><p>已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。</p><p>给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。</p><h1>分析理解</h1><p>position数组的每个元素position[i]代表一个位置，然后从中挑选出m个位置，求得这m个位置之间的距离的绝对值（这个绝对值即磁力值）中的最小值，并且还要使这个最小值最大。</p><h1>基本思路</h1><p>这道题呈现出明显的<code>单调性</code>：</p><ul><li>如果我们能找到一个磁力值d，使得可以放置m个球，那么所有比d小的值也一定可以满足条件。因为如果d可以，那么更小的d更容易满足。</li><li>如果d不能满足条件，那么所有比d大的值也一定不能满足条件。因为如果d不可以，那么更大的值只会更难满足。</li></ul><p>因此此题目有明显的单调性，考虑<code>二分查找</code>。使用二分法遍历d的可能值，并且不断检查当前的d值是否满足条件，满足就尝试更大的d，不满足就尝试更小的d值。d的遍历区间为position中的两两元素之间的最小值m与最大值M组成的区间[m, M]。position数组是未经排序的，经过排序后很容易求得M为最后一个元素减去第一个元素，而m不容易求得。但是我们注意到有条件1≤position[i]≤10^9，因此可以得到m的下界为1。</p><p>现在只需要确定检查当前d值是否满足条件的逻辑就可以了。基本想法是设置一个pre代表上一个放小球的位置，初始化为position[0]，并设定一个计数器count=1，然后从position[1]开始逐渐向后遍历，每当position[i]-pre的值≥d时，就使计数器自增，并修正pre为position[i]即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; position, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = position.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(position.<span class="built_in">begin</span>(), position.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = position.<span class="built_in">back</span>() - position[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, position, m)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                res = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> d, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pos, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 第一个球已放置</span></span><br><span class="line">        <span class="type">int</span> prev = pos[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[i] - prev &gt;= d) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                prev = pos[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= m ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef enum &#123;</span></span><br><span class="line"><span class="comment">//     false, </span></span><br><span class="line"><span class="comment">//     true</span></span><br><span class="line"><span class="comment">// &#125;bool;</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> *pos, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 第一个球已放置</span></span><br><span class="line">    <span class="type">int</span> pre = pos[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos[i] - pre &gt;= d) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            pre = pos[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= m ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmpFunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>* pos, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    qsort(pos, n, <span class="keyword">sizeof</span>(*pos), cmpFunc);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>, right = pos[n<span class="number">-1</span>] - pos[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid, pos, n, m)) &#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><h1>时间复杂度</h1><p>首先快排的复杂度为O(n log n)，然后二分查找的复杂度为O(log M)（M为position数组中任意两两元素差的绝对值中的最大值，check函数的复杂度为O(n)，总体复杂度为O(n log n + n log M)。</p><h1>空间复杂度</h1><p>使用常数个变量，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十四：1742. 盒子中小球的最大数量</title>
      <link href="/2025/02/13/leetcode14/"/>
      <url>/2025/02/13/leetcode14/</url>
      
        <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/description/">1742. 盒子中小球的最大数量</a>。</p><p>你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。</p><p>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。</p><p>给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。</p><h1>思路分析</h1><p>遍历[lowLimit, highLimit]，并且计算每位数字之和，然后记录到哈希表中，返回最大的一个，这是我的第一想法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBalls</span><span class="params">(<span class="type">int</span> lowLimit, <span class="type">int</span> highLimit)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lowLimit; i &lt;= highLimit; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">bitSum</span>(i);</span><br><span class="line">            hash[cur]++;</span><br><span class="line">            <span class="keyword">if</span> (hash[cur] &gt; res)</span><br><span class="line">                res = hash[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bitSum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            res += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>灵茶山艾府的解法</h1><p>下午的时候看见了灵神写的题解，灵神就是灵神，直接给出了三种方法：</p><ol><li>暴力枚举</li><li>前缀和</li><li>数位DP</li></ol><h2 id="暴力枚举">暴力枚举</h2><p>暴力枚举的思路和我相同，但灵神更牛的是使用了一个数组来存储各个数位和的个数，他注意到了条件1 &lt;= lowLimit &lt;= highLimit &lt;= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">5</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，数位和最大值为数字99999计算所得的45，最小为1，直接用组存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBalls</span><span class="params">(<span class="type">int</span> lowLimit, <span class="type">int</span> highLimit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">46</span>]&#123;&#125;; <span class="comment">// 99999 的数位和 = 45</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lowLimit; i &lt;= highLimit; i++) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = i; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>) &#123;</span><br><span class="line">                s += x % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ranges::<span class="built_in">max</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：灵茶山艾府</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/maximum-number-of-balls-in-a-box/solutions/3073112/san-chong-fang-fa-bao-li-mei-ju-qian-zhu-kze9/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="前缀和">前缀和</h2><h2 id="数位DP">数位DP</h2>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 记忆化搜索 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十三：1760. 袋子里最少数目的球</title>
      <link href="/2025/02/12/leetcode13/"/>
      <url>/2025/02/12/leetcode13/</url>
      
        <content type="html"><![CDATA[<p>这里想谈谈之前写Leetcode 每日一题文章的顺序，我基本上是先把代码放上去，然后将代码进行详细讲解。感觉这种方法不合适，因为是先有思路然后有代码。先代码后思路显然是本末倒置了，这一点要改改。</p><p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/description/">1760. 袋子里最少数目的球</a>。</p><h1>分析理解</h1><p>该题给定一个数组nums，其中的每个元素nums[i]代表第i个袋子中有几个小球。还给定了一个数maxOperations即最大操作数。接下来要对nums进行操作，每次操作可以将第i个袋子中的小球拆分到两个袋子里。总共进行的操作数不能超过maxOperations，最后要使得进行不超过maxOperations次的操作后，使得nums数组中的最大值最小（花了一点时间才理解doge）。</p><h1>思路分析</h1><p>这道题的一个关键点是寻找一个最小的“最大值”，也就是说我们找到的最大值mid，使得在进行不超过maxOperations次操作后，所有袋子中的小球数都不超过mid即nums中每个元素num都满足num &lt;= mid。因为当mid可能时，比mid更大的数也一定可行。比如当mid=3可行时，mid=4或者mid=5等更大的整数也一定可行，因为允许的最大值变大了，操作次数会更少或者不变。当mid不可行时，比mid更小的数一定不可行，因为允许的最大值变小了，操作次数会更多。比如mid=3不可行时，那么mid=2需要更多的操作次数。因此本题目存在单调性，符合二分搜索的应用条件。</p><p>题目给定了条件nums中所有元素均为大于等于1的整数，所以mid的下界为1，而上界为nums中最大元素的值。因此我们通过二分搜索来遍历[1, M]就行（M为nums中最大元素）。</p><p>另外一个关键点就是拆分次数的公式，就是给定一个num，将其拆分到不大于mid的次数如何计算。一开始我认为其为num // mid，然后对于num=9，mid=3，发现9/3=3，但是9拆分到不大于3只需两次操作：9=6+3=3+3+3。。。</p><p>对于一个含有num个小球的袋子，进行拆分使得每个袋子中的小球数不超过mid，则袋子数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>，而对应的操作次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>。这里想插入一点其他内容，上取整与下取整等的数学公式的推导，还是放在后面弄个附录吧。而编程语言中的除法操作一般是下取整除法，所以还需要进行转换，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1 = \lfloor \frac{num - 1}{mid} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>。因此将含有num个小球的袋子进行拆分使得每个袋子中的小球不超过mid所需的操作次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num-1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>下取整。</p><p>接下来在区间[1, M]遍历mid（M为nums中最大值），具体步骤为：</p><ol><li>初始化左边界left=1，有边界right=M</li><li>在每次循环中，mid = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac{left+right}{2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9322159999999999em;"></span><span class="strut bottom" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.44610799999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">t</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>，计算总的操作次数是否≤maxOperations</li><li>如果满足条件则尝试更小的mid即right=mid，否则需要增大mid即left=mid+1</li><li>当left≥right时，返回right即可</li></ol><p>按照上述步骤可得C++实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num: nums) &#123;</span><br><span class="line">                cur = cur + (num - <span class="number">1</span>) / mid;</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; maxOperations)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt;= maxOperations)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><h2 id="时间复杂度">时间复杂度</h2><p>外层循环是二分搜索，复杂度为O(log M)（M为nums中的最大值）；内层循环的复杂度为O(n)（n为nums中元素个数），总的时间复杂度为O(n log M)。</p><h2 id="空间复杂度">空间复杂度</h2><p>使用常数个遍历，空间复杂度为O(1)。</p><h1>附录</h1><h2 id="1-lceil-frac-num-mid-rceil-1-lfloor-frac-num-mid-rfloor-吗">1. $ \lceil \frac{num}{mid} \rceil - 1== \lfloor \frac{num}{mid} \rfloor$ 吗</h2><h3 id="情况-1：-frac-num-mid-是整数">情况 1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>是整数</h3><ul><li>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\frac{num}{mid} = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>，其中k是整数</li><li>上取整后减1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mi>k</mi><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil k \rceil - 1 = k -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>​</li><li>下取整：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>k</mi><mo>⌋</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lfloor k \rfloor = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>​</li><li>结论不相等</li></ul><h3 id="情况-2：-frac-num-mid-不是整数">情况 2：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>不是整数</h3><ul><li>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\frac{num}{mid} = k + f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>，其中k是整数，0 &lt; f &lt; 1</li><li>上取整后减1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lceil k + f \rceil - 1 = k + 1 - 1 = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>​</li><li>下取整：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌋</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lfloor k + f \rfloor = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>​</li><li>结论相等</li></ul><p>因此$ \lceil \frac{num}{mid} \rceil - 1== \lfloor \frac{num}{mid} \rfloor$不成立。</p><h2 id="2-lceil-frac-num-mid-rceil-1-lfloor-frac-num-1-mid-rfloor">2. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1= \lfloor \frac{num-1}{mid} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></h2><p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\frac{num}{mid}=k+f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>，其中k为整数部分，f为小数部分，0≤f&lt;1。</p><ul><li>若f=0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>=</mo><mo>⌈</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌉</mo><mo>=</mo><mo>⌈</mo><mi>k</mi><mo>⌉</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil=\lceil k+f \rceil = \lceil k \rceil = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span></li><li>若f&gt;0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>=</mo><mo>⌈</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌉</mo><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil=\lceil k+f \rceil = k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></li></ul><p>通过变形可以统一上述两种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num+mid-1}{mid}=k+f+1-\frac{1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p><ul><li>若f=0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num+mid-1}{mid}=k+f+1-\frac{1}{mid}=k+1-\frac{1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，下取整为k</li><li>若f&gt;0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num+mid-1}{mid}=k+f+1-\frac{1}{mid}=k+f+1-\frac{1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，下取整为k+1</li></ul><p>因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil = \lfloor\frac{num+mid-1}{mid}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>。下取整函数有性质<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>⌋</mo><mo>=</mo><mo>⌊</mo><mi>x</mi><mo>⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor x + 1 \rfloor = \lfloor x \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord mathit">x</span><span class="mclose">⌋</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>+</mo><mn>1</mn><mo>⌋</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor\frac{num+mid-1}{mid}\rfloor=\lfloor\frac{num-1}{mid}+1\rfloor=\lfloor\frac{num-1}{mid}\rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>，继而可得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1= \lfloor\frac{num-1}{mid}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十二：913. 猫和老鼠</title>
      <link href="/2025/02/11/leetcode12/"/>
      <url>/2025/02/11/leetcode12/</url>
      
        <content type="html"><![CDATA[<p>今日的Leetcode 每日一题为<a href="https://leetcode.cn/problems/cat-and-mouse/description/">913. 猫和老鼠</a>。</p><p>两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。</p><p>图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。</p><p>老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。</p><p>在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。</p><p>此外，猫无法移动到洞中（节点 0）。</p><p>然后，游戏在出现以下三种情形之一时结束：</p><ul><li>如果猫和老鼠出现在同一个节点，猫获胜。</li><li>如果老鼠到达洞中，老鼠获胜。</li><li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li></ul><p>给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：</p><ul><li>如果老鼠获胜，则返回 1；</li><li>如果猫获胜，则返回 2；</li><li>如果平局，则返回 0 。</li></ul><h1>分析理解</h1><p>这道题是真滴难，看了好久好久才弄明白那么一点，leetcode官方给的标签也是<code>困难</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 图 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题十：63. 不同路径 II</title>
      <link href="/2025/02/09/leetcode10/"/>
      <url>/2025/02/09/leetcode10/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II</a>。</p><p>给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。</p><p>返回机器人能够到达右下角的不同路径数量。</p><p>测试用例保证答案小于等于 2 * 10^9。</p><p>提示：</p><ul><li>m == obstacleGrid.length</li><li>n == obstacleGrid[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h1>分析理解</h1><p>提供一个mxn二维数组grid，其中的元素为1代表有障碍物，为0代表无障碍物。机器人初始位于(0, 0)处，目的地为(m-1, n-1)，需要我们求出从(0, 0)到(m-1, n-1)的路径个数。</p><h1>基本思路</h1><p>使用动态规划求解，求解一个二维的dp数组，dp[i+1][j+1]来代表从(0, 0)到(i, j)的路径个数。这里使用dp[i+1][j+1]而不用dp[i][j]是有原因的，主要是该题目有个特殊的几个用例，(0, 0)处为障碍物，导致解为0。</p><p>初始时将dp中所有元素均设为0，然后将dp[0][1]或者dp[1][0]初始化为1。而在求解dp[i+1][j+1]时dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1]，这样当i=0时求得dp[1][1]=dp[0][1]+dp[1][0]即从(0, 0)到(0, 0)的路径条数。这样做的好处就是不用特殊化处理边界，便于撰写代码。最后返回dp[m][n]即(0, 0)到(m-1, n-1)的路径条数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    dp[i<span class="number">+1</span>][j<span class="number">+1</span>] = dp[i][j<span class="number">+1</span>] + dp[i<span class="number">+1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>** obstacleGrid, <span class="type">int</span> obstacleGridSize, <span class="type">int</span>* obstacleGridColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = obstacleGridSize, n = *obstacleGridColSize;</span><br><span class="line">    <span class="type">int</span>** dp = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * (m+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        dp[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; ++j)</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度和空间复杂度均为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> Leetcode 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题九：128. 最长连续序列</title>
      <link href="/2025/02/08/leetcode9/"/>
      <url>/2025/02/08/leetcode9/</url>
      
        <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">128. 最长连续序列</a>。</p><h1>分析理解</h1><p>题目给一个未排序的整数数组，要求我们找出一个最长的连续的子序列，当然不需要求这个子序列是什么，只需要求出他的长度。题目要求使用时间复杂度为O(n)的算法。</p><h1>思路分析</h1><p>由于题目要求使用时间复杂度为O(n)的算法，故排序是不可能用的了，因为排序的复杂度最低也为O(n log n)。但是提交完题解后发现，最快的方法竟然是排序，给我震惊呆住了。可能是官方的例子比较特殊等原因吧。不过接着看灵神给出的哈希表的方法。</p><p>首先将数组用哈希表去重，将数组转换为哈希集合即没有重复元素的集合。然后开始遍历哈希集合。</p><p>遍历的时候，对于每一个元素x：</p><ul><li>如果x-1存在于哈希集合中，就跳过当前元素；</li><li>如果x-1不存在与哈希集合中，就开始记录从x开始的连续子序列的长度。就是依次遍历x+1、x+2、x+3，…</li></ul><p>x-1存在于哈希集合时，跳过当前元素是因为最长连续子序列的长度一定不从x开始，可能从x-1、也可能从x-2开始，但不会是从x开始。这就是基本思路了，直接给出C++代码，下次试试用Rust：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(i<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            hash.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (hash.<span class="built_in">count</span>(j))</span><br><span class="line">                j++;</span><br><span class="line">            res = <span class="built_in">max</span>(j - i, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题八：59. 螺旋矩阵 II</title>
      <link href="/2025/02/07/leetcode8/"/>
      <url>/2025/02/07/leetcode8/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a>。</p><p>本题参考大神Krahets的解法，这种解法最便于理解。Krahets的基本思路是依次填充上边界、右边界、下边界和左边界，每次填充完边界后，对填充的边界进行压缩，见代码中的t++、r–、b–、l++，直到填充完毕为止。以下是他的Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>, t = <span class="number">0</span>, b = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] mat = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>, tar = n * n;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= tar)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) mat[t][i] = num++; <span class="comment">// left to right.</span></span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++) mat[i][r] = num++; <span class="comment">// top to bottom.</span></span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--) mat[b][i] = num++; <span class="comment">// right to left.</span></span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--) mat[i][l] = num++; <span class="comment">// bottom to top.</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Krahets</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>参考其Java代码给出C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, up = <span class="number">0</span>, down = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n * n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">                matrix[up][i] = num++;</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = up; i &lt;= down; i++)</span><br><span class="line">                matrix[i][right] = num++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                matrix[down][i] = num++;</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= up; i--)</span><br><span class="line">                matrix[i][left] = num++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度和空间复杂度显而易见，为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)和O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 矩阵 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题七：47. 全排列 II</title>
      <link href="/2025/02/06/leetcode7/"/>
      <url>/2025/02/06/leetcode7/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II</a>。拿到这道题一眼就想到算法课上的<code>生成排列</code>，当即就使用回溯算法解决，直接提交，直接报错。没注意到题目有条限制条件——存在重复元素。由于题目叫做<code>47. 全排列 II</code>，那我估计肯定存在<code>全排列 I</code>的题目，所有元素均不重复，一找还真有<a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a>。直接copy代码过去，提交运行，直接通过，爽歪歪。</p><h1>46. 全排列</h1><p>先看看不存在重复元素的<a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a>，这道题更简单，直接用生成排列的回溯算法，照着抄就行。</p><h2 id="思路分析">思路分析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(nums)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">perm</span>(<span class="number">0</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">perm</span><span class="params">(<span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == path.<span class="built_in">size</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; path.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(path[j], path[i]);</span><br><span class="line">                <span class="built_in">perm</span>(i<span class="number">+1</span>, path, res);</span><br><span class="line">                <span class="built_in">swap</span>(path[j], path[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这部分递归要弄清楚执行过程。permute是主函数，接受一个整数数组nums的输入，path是nums的一个副本，用于存放当前遍历到的排列，res用于存放所有排列，perm是一个递归函数，通过调用perm(0, path, res)来从索引0开始生成排列。然后是perm的不断递归调用。</p><p>然后看perm函数的具体执行过程，首先是if条件判断，只有当i与path.size()相等时才会执行，一般先执行else里的内容。else包括一个循环，对于当前位置i，遍历从i到path.size()-1的所有位置j，每次遍历过程中交换path[j]与path[i]，相当于将path[j]交换到当前的位置i处。然后递归调用perm(i+1, path, res)，处理下一个位置i+1，然后回溯即将path[j]与path[i]交换回来。</p><h3 id="例子">例子</h3><p>看一个例子[1, 2, 3]。<br>1.初始调用perm(0, [1, 2, 3], res)。<br>2.在perm(0, [1, 2, 3], res)中i = 0不等于path.size()，执行else中的for循环，i = 0，遍历j从0到2：</p><ul><li>j = 0，交换path[j]与path[i]即path[0]与path[0]，path仍为[1, 2, 3]，递归调用perm(1, [1, 2, 3], res)：<ul><li>在perm(1, [1, 2, 3], res)中，i = 1不等于path.size()，执行else中的for循环，遍历j从1到2：<ul><li>j = 1，交换path[j]与path[i]即path[1]和path[1]，path仍为[1, 2, 3]，递归调用perm(2, [1, 2, 3], res)：<ul><li>在perm(2, [1, 2, 3], res)中，i = 2，遍历j从2到2：<ul><li>j = 2，交换path[j]与path[i]即path[2]与path[2]，res仍为[1, 2, 3]，递归调用perm(3, [1, 2, 3], res)：<ul><li>在perm(3, [1, 2, 3], res)中，i = 3等于path.size()，满足if条件，执行<code>res.push_back([1, 2, 3])</code>，然后回溯。</li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]与path[2]（此时的交换对应上方的交换，这里的交换应该叫做换回），path仍为[1, 2, 3]，回溯。</li></ul></li></ul></li><li>j = 1，交换path[j]与path[i]即path[1]和path[1]（此时的交换为换回），path为[1, 2, 3]，回溯。</li><li>j = 2，交换path[j]与path[i]即path[2]与path[1]，path为[1, 3, 2]，递归调用perm(2, [1, 3, 2], res)：<ul><li>在perm(2, [1, 3, 2], res)中，i = 2，执行else中的for循环，遍历j从2到2：<ul><li>j = 2，交换path[j]与path[i]即path[2]与path[2]，res仍为[1, 3, 2]，递归调用perm(3, [1, 3, 2], res)：<ul><li>在perm(3, [1, 3, 2], res)中，i = 3等于path.size()，满足if条件，执行<code>res.push_back([1, 3, 2])</code>，然后回溯。</li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]与path[2]（此时的交换对应上方的交换，这里的交换应该叫做换回），path为[1, 3, 2]，回溯。</li></ul></li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]和path[1]（此时的交换为换回），path为[1, 2, 3]，回溯。</li></ul></li></ul></li><li>j = 0，交换path[j]与path[i]即path[0]与path[0]（换回），path为[1, 2, 3]，回溯。</li><li>j = 1，交换path[j]与path[i]即path[1]与path[0]，path为[2, 1, 3]，递归调用perm(1, [2, 1, 3], res)：<ul><li>在perm(1, [2, 1, 3], res)中，i = 1不等于path.size()，执行else中的for循环，遍历j从1到2<ul><li>j = 1，交换path[j]与path[i]即path[1]和path[1]，path仍为[2, 1, 3]，递归调用perm(2, [2, 1, 3], res)：<ul><li>在perm(2, [2, 1, 3], res)中，i = 2，遍历j从2到2：<ul><li>j = 2，交换path[j]与path[i]即path[2]与path[2]，res仍为[2, 1, 3]，递归调用perm(3, [2, 1, 3], res)：<ul><li>在perm(3, [2, 1, 3], res)中，i = 3等于path.size()，满足if条件，执行<code>res.push_back([2, 1, 3])</code>，然后回溯。</li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]与path[2]（此时的交换对应上方的交换，这里的交换应该叫做换回），path仍为[2, 1, 3]，回溯。</li></ul></li></ul></li><li>j = 1，交换path[j]与path[i]即path[1]和path[1]（此时的交换为换回），path为[2, 1, 3]，回溯。</li><li>j = 2，交换path[j]与path[i]即path[2]与path[1]，res为[2, 3, 1]，递归调用perm(2, [2, 3, 1], res)：<ul><li>在perm(2, [2, 3, 1], res)中，i = 2，执行else中的for循环，遍历j从2到2：<ul><li>j = 2，交换path[j]与path[i]即path[2]与path[2]，res仍为[2, 3, 1]，递归调用perm(3, [2, 3, 1], res)：<ul><li>在perm(3, [2, 3, 1], res)中，i = 3等于path.size()，满足if条件，执行<code>res.push_back([2, 3, 1])</code>，然后回溯。</li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]与path[2]（此时的交换对应上方的交换，这里的交换应该叫做换回），path为[2, 3, 1]，回溯。</li></ul></li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]和path[1]（此时的交换为换回），path为[2, 1, 3]，回溯。</li></ul></li></ul></li><li>j = 1，交换path[j]与path[i]即path[1]与path[0]（换回），path为[1, 2, 3]，回溯。</li><li>j = 2，交换path[j]与path[i]即path[2]与path[0]，path为[3, 2, 1]，递归调用perm(1, [3, 2, 1], res)：<ul><li>在perm(1, [3, 2, 1], res)中，i = 1不等于path.size()，执行else中的for循环，遍历j从1到2<ul><li>j = 1，交换path[j]与path[i]即path[1]和path[1]，path仍为[3, 2, 1]，递归调用perm(2, [3, 2, 1], res)：<ul><li>在perm(2, [3, 2, 1], res)中，i = 2，遍历j从2到2：<ul><li>j = 2，交换path[j]与path[i]即path[2]与path[2]，res仍为[3, 2, 1]，递归调用perm(3, [3, 2, 1], res)：<ul><li>在perm(3, [2, 3, 1], res)中，i = 3等于path.size()，满足if条件，执行<code>res.push_back([3, 2, 1])</code>，然后回溯。</li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]与path[2]（此时的交换对应上方的交换，这里的交换应该叫做换回），path仍为[3, 2, 1]，回溯。</li></ul></li></ul></li><li>j = 1，交换path[j]与path[i]即path[1]和path[1]（此时的交换为换回），path为[3, 2, 1]，回溯。</li><li>j = 2，交换path[j]与path[i]即path[2]与path[1]，res为[3, 1, 2]，递归调用perm(2, [3, 1, 2], res)：<ul><li>在perm(2, [3, 1, 2], res)中，i = 2，执行else中的for循环，遍历j从2到2：<ul><li>j = 2，交换path[j]与path[i]即path[2]与path[2]，res仍为[3, 1, 2]，递归调用perm(3, [3, 1, 2], res)：<ul><li>在perm(3, [2, 3, 1], res)中，i = 3等于path.size()，满足if条件，执行<code>res.push_back([3, 1, 2])</code>，然后回溯。</li><li>j = 2，交换path[j]与path[i]即path[2]与path[2]（此时的交换对应上方的交换，这里的交换应该叫做换回），path为[3, 1, 2]，回溯。</li></ul></li></ul></li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]和path[1]（此时的交换为换回），path为[3, 2, 1]，回溯。</li></ul></li></ul></li><li>j = 2，交换path[j]与path[i]即path[2]与path[0]（换回），path为[1, 2, 3]，回溯。<br>3.perm递归执行结束，回到permute函数，此时的res为:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [1, 3, 2],</span><br><span class="line">    [2, 1, 3],</span><br><span class="line">    [2, 3, 1],</span><br><span class="line">    [3, 2, 1],</span><br><span class="line">    [3, 1, 2],</span><br><span class="line">]</span><br><span class="line">```   </span><br><span class="line">上述讲解可能比较啰嗦，看这个示意图应该更好理解：</span><br></pre></td></tr></table></figure><p>开始: [1, 2, 3]<br>|<br>±- [1, 2, 3] (i=0, j=0)<br>|      |<br>|      ±- [1, 2, 3] (i=1, j=1)<br>|      |      |<br>|      |      ±- [1, 2, 3] (i=2, j=2) -&gt; 加入结果集<br>|      |<br>|      ±- [1, 3, 2] (i=1, j=2)<br>|             |<br>|             ±- [1, 3, 2] (i=2, j=2) -&gt; 加入结果集<br>|<br>±- [2, 1, 3] (i=0, j=1)<br>|      |<br>|      ±- [2, 1, 3] (i=1, j=1)<br>|      |      |<br>|      |      ±- [2, 1, 3] (i=2, j=2) -&gt; 加入结果集<br>|      |<br>|      ±- [2, 3, 1] (i=1, j=2)<br>|             |<br>|             ±- [2, 3, 1] (i=2, j=2) -&gt; 加入结果集<br>|<br>±- [3, 2, 1] (i=0, j=2)<br>|<br>±- [3, 2, 1] (i=1, j=1)<br>|      |<br>|      ±- [3, 2, 1] (i=2, j=2) -&gt; 加入结果集<br>|<br>±- [3, 1, 2] (i=1, j=2)<br>|<br>±- [3, 1, 2] (i=2, j=2) -&gt; 加入结果集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 复杂度分析</span><br><span class="line">### 时间复杂度</span><br><span class="line">n个元素有n!个排列，而生成每个排列的时间为O(n)，故总的时间复杂度为O(n$\times$n!)。</span><br><span class="line">### 空间复杂度</span><br><span class="line">递归深度为n，空间复杂度主要来源于递归栈，为O(n)。</span><br><span class="line"></span><br><span class="line"># 47. 全排列 II</span><br><span class="line">## 思路分析</span><br><span class="line">[46. 全排列](https://leetcode.cn/problems/permutations/description/)使用的是递归交换法，当处理到位置i的时候，将i和后面的每一个元素进行交换，然后递归处理位置i+1。比如对于nums=[1, 2, 3]，i=0的时候，遍历j从0到2，交换1和1、1和2、1和3；依照上述方法能产生全排列。但当有重复元素时，就会出现重复的情况，比如对于nums=[1, 1, 2]，i=0的时候，遍历j从0到2，交换1和1、1和1、1和2，交换后的nums是一样的，这就会导致后续产生重复的序列。</span><br><span class="line"></span><br><span class="line">所以，问题在于如何避免处理相同的元素。这里使用一个哈希表记录已经交换过的元素，在每次遍历交换前，先查找其是否已经交换过，交换过的元素就跳过交换。比如对于nums=[1, 1, 2]，i=0时，遍历j从0到2，交换1和1、1和1、1和2，但是交换前，先查找其是否已经交换过，第一次交换1和1时，1不在哈希表中，所以进行交换；第二次交换1和1的时候，1已经在哈希表中，直接跳过；交换1和2的时候，2不在哈希表中，故进行交换。最终本轮产生的序列从原来的[1, 1, 2]、[1, 1, 2]、[2, 1, 1]变成[1, 1, 2]、[2, 1, 1]。</span><br><span class="line"></span><br><span class="line">下面是C++实现：</span><br><span class="line">```cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; path(nums);</span><br><span class="line">        perm(0, path, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void perm(int i, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123;</span><br><span class="line">        if (i == path.size())</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        else &#123;</span><br><span class="line">            unordered_set&lt;int&gt; used;</span><br><span class="line">            for (int j = i; j &lt; path.size(); ++j) &#123;</span><br><span class="line">                if (used.count(path[j]))</span><br><span class="line">                    continue;</span><br><span class="line">                used.insert(path[j]);</span><br><span class="line">                swap(path[j], path[i]);</span><br><span class="line">                perm(i+1, path, res);</span><br><span class="line">                swap(path[j], path[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><h3 id="时间复杂度">时间复杂度</h3><p>有重复元素时，时间复杂度的上限依然不变，所以时间复杂度为O(n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">×</span></span></span></span>n!)。其实可以更精确，实际生成的排列数为M=\frac{n!}{k_1!·k_2!·...·k_m!}，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是第i个重复元素出现的次数，时间复杂度为O(n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">×</span></span></span></span>M)。</p><h3 id="空间复杂度">空间复杂度</h3><p>空间复杂度依然为O(n)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题六：90. 子集 II</title>
      <link href="/2025/02/05/leetcode6/"/>
      <url>/2025/02/05/leetcode6/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II</a>。</p><h1>思路分析</h1><p>题目很好理解，基本思路是使用回溯法进行解决。这种方法其实是参考沙特的M. H. Alsuwaiyel的《算法设计技巧与分析》的生成排列算法，直接照着伪代码抄就行。由于数组中存在重复元素，因此先对其进行排序，方便排除重复元素。下面给出C++实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; cur &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, i<span class="number">+1</span>, path, res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>backtrack</code>函数是核心，它接受四个参数，输入数组、当前遍历到的数的下标cur、当前子集path以及输出数组。一开始时创建了一个path数组，其为空。</p><p>然后调用backtrack函数<code>backtrack(nums, 0, path, res)</code>。在backtrack函数中，先将path压入res中，此时path为空集，因而空集被包含进去了。然后进入循环体内部，每次循环先检查当前遍历元素是否是当前元素即<code>i &gt; start</code>，如果是则检查当前遍历元素是否与上一个元素相同即<code>nums[i] == nums[i-1]</code>，如果相同则跳过当前遍历元素，遍历下一个元素。这里说了一个当前遍历元素和当前元素，感觉容易让人混淆。当前元素即backtrack里参数cur对应下标的元素，而当前遍历元素是在backtrack函数内部的for循环体中遍历到的元素的下标。上述由代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>实现，用于排除重复元素。当前遍历元素是当前元素或者当前遍历元素与上一个元素不同时执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"><span class="built_in">backtrak</span>(nums, i<span class="number">+1</span>, path, res);</span><br></pre></td></tr></table></figure><p>path.push_back(nums[i])实现将选择当前遍历元素，然后调用backtrack函数，而backtrack函数所执行的第一件事是<code>res.push_back(path)</code>，也就是将一个子集压入了输出数组中。</p><p>回溯法的整个过程是从空集开始每次增加一个元素，并压入到输出数组中，直到nums数组中所有元素都包含进path中为止。然后开始回溯。用例子解释或许更直观。假设nums为[1,2,3,3,4]，则压入到输出数组中的子集依次为[]、[1]、[1、2]、[1、2、3]、[1、2、3、3]、[1、2、3、3、5]，此时已经将所有元素压入path中，最深一层的backtrack函数内先将[1、2、3、3、5]压入到res中，然后执行for (i = start; i &lt; nums.size(); i++)，但此时i = nums.size()故进入for循环时不满足i &lt; nums.size()直接退出循环后回溯。回溯后将最后一个元素弹出，path变为[1,2,3,3]。然后退出循环体回溯，再将最后一个元素弹出，path变为[1,2,3]。此时还满足循环条件将元素5压入path，path变为[1,2,3,5]。然后调用backtrack函数。接下来path依次变化为[1,2,5]、[1,3,3]、[1,3,3,5]、[1,5]。。。</p><h1>复杂度分析</h1><h2 id="时间复杂度">时间复杂度</h2><p>对于一个大小为n的数组，子集的长度为0~n。每次递归调用将path的副本加入到res中，每次将子集复制到输出数组中所需时间与子集的长度有关，但上界不变，因此将一个子集复制到输出数组的时间复杂度为O(n)。而输入数组的大小为n，如果不存在重复元素，也就是最坏情况，此时子集的数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。而当存在重复元素时，虽然可以通过剪枝操作减少递归调用的次数，但是执行次数的上界依然为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。因此时间复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n\times 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)。</p><h2 id="空间复杂度">空间复杂度</h2><p>在整个过程中，使用的空间主要是递归调用栈，其最大深度可以达到O(n)，即使在存在重复元素时其上界依然保持不变。因此空间复杂度为O(n)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题五：922. 按奇偶排序数组 II</title>
      <link href="/2025/02/04/leetcode5/"/>
      <url>/2025/02/04/leetcode5/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/sort-array-by-parity-ii/description/">922. 按奇偶排序数组 II</a>。</p><p>这道题比较简单，仅仅做一个记录。时间复杂度为O(n), 空间复杂度为O(1)。<br>以下是C++实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArrayByParityII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = x;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[j] = x;</span><br><span class="line">                j += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题四：680. 验证回文串 II</title>
      <link href="/2025/02/03/leetcode4/"/>
      <url>/2025/02/03/leetcode4/</url>
      
        <content type="html"><![CDATA[<p>今日Leecode每日一题为<a href="https://leetcode.cn/problems/valid-palindrome-ii/description/">680. 验证回文串 II</a>。</p><h1>思路分析</h1><p>提供一个字符串s，最多可以删除一个字符，如果s能成为回文串，返回true，否则返回false。先给出C++实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = low, j = high;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[low] == s[high]) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">                --high;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">checkPalindrome</span>(s, low, high - <span class="number">1</span>) || <span class="built_in">checkPalindrome</span>(s, low + <span class="number">1</span>, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中validPalindrome函数是要实现的函数，checkPalindrome函数是辅助函数。辅助函数checkPalindrome函数接收三个参数：字符串s、整型数low和high，检查字符串s从下标low到high之间的字符串是否是回文串。</p><p>validPalindrome函数使用low和high两个指针，初始化时low = 0, high = s.size() - 1。然后进入while循环，检查s[low] == s[high]是否成立，如果成立则low自增1、high自减1。如果不成立则需要删除s[low]或者s[high]，由于最多删除一个字符，所以直接返回删除s[low]或者s[high]后的结果就行即checkPalindrome(s, low, high - 1) || checkPalindrome(s, low + 1, high)。</p><p>看一个例子’abca’，开始时low=0， high = 3，s[low] == s[high]成立，low++得low=1,high–得high=2，此时s[low] == s[high]不成立，因此调用checkPalindrome(s, low+1, high)和checkPalindrome(s, low, high-1)，前者删除s[low]，后者删除s[high]，low+1=2,high=2，因此前者为true，因为是<code>||</code>符号，此时就直接返回true。如果执行后者，high-1=1，low=1，因此后者也为true。也就是说对于字符串’abca’，删除s[1]变成’aca’和删除s[2]变成’aba’都可以使其变成回文串。</p><h1>复杂度分析</h1><h2 id="时间复杂度">时间复杂度</h2><p>如果s是回文串，则不调用checkPalindrome函数，循环执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>次，此时时间复杂度为O(n)。<br>如果s不是回文串，假设执行第k次时需要删除字符时，仍然需要检查剩余n-2k-1个字符，最多需要循环<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mi>k</mi><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n-2k-1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>次，并且需要调用checkPalindrome两次，k无论取何值，循环次数的上界依然为2 * n，因此时间复杂度为O(n)。</p><h2 id="空间复杂度">空间复杂度</h2><p>使用常数个变量，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题三：598. 区间加法 II</title>
      <link href="/2025/02/02/leetcode3/"/>
      <url>/2025/02/02/leetcode3/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode的每日一题为<a href="https://leetcode.cn/problems/range-addition-ii/description/">598. 区间加法 II</a>。</p><h1>思路分析</h1><p>给一个整数m和一个整数n,对一个矩阵M，初始时矩阵中所有均为0。此外还提供一个操作数组ops，对于C++编程语言，提供的是一个二维vector数组vector&lt;vector<int>&gt;，通过for (auto&amp; op:ops)可以遍历该数组中的元素对，其中每个元素对op为一对数字(a,b)，执行将(0, 0)~(a-1, b-1)的所有元素进行加1操作。遍历完所有元素对后即执行完了操作，要求求出矩阵中最大的整数出现的次数。</p><p>使用模拟的方法的话即遍历操作数组ops对矩阵M进行操作后进行遍历统计，但这种方法的时间复杂度为O(mn)，空间复杂度为O(mn)，效率不高。</p><p>对于每次操作(a, b)影响的区域为(0, 0)~(a-1, b-1)，因而所有的操作共同影响的区域为这些区域的交集。只要求出所有的操作(a, b)中最小的a和最小的b即可，记作min_a和min_b，min_a和min_b决定了所有的操作共同影响的区域，最后很容易联想到最大整数出现的次数为<code>min_a * min_b</code>。</p><h1>复杂度分析</h1><p>这种方法主要是在遍历操作数组ops，ops为二维数组，设它为kX2的数组，那么时间复杂度为O(k)，k即操作的次数。使用了常数个变量，空间复杂度即O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题二：81. 搜索旋转排序数组 II</title>
      <link href="/2025/02/01/leetcode2/"/>
      <url>/2025/02/01/leetcode2/</url>
      
        <content type="html"><![CDATA[<p>今日Leetcode的每日一题为<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/">81. 搜索旋转排序数组 II</a>。</p><h1>思路分析</h1><p>这道题目大概意思是，原来有一个有序数组，按升序排列，但是该数组以一个未知下标进行了翻转，假如未知下标为k，那么数组从原来的下标[0,1,2,3,…,k,…n]变成了[k,k+1,k+2,…,n-1,0,1,2,3,…,k-1]。第一想法其实是遍历，虽然Leetcode官方并不会去排查你使用何种方法，但是咱们也不能拘泥于最简单的算法^o^。<br>Leetcode官方给该题的标签是二分查找，一直没明白是怎么个二分查找法？So我直接看的Leetcode官方题解，下面是Leetcode官方给的C++代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/search-in-rotated-sorted-array-ii/solutions/704686/sou-suo-xuan-zhuan-pai-xu-shu-zu-ii-by-l-0nmp/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="特殊情况处理">特殊情况处理</h2><p>首先是对特殊情况的处理，Leetcode官方将数组中没有元素和一个元素进行了特殊处理。对于数组中没有元素时进行特殊处理是合理的，因为避免了对数组中元素的访问。而当数组中元素只有一个时没有必要进行特殊化处理，直接一般化处理即可。因为在初始化左指针和右指针时，另左指针为0，右指针为数组长度-1，在数组中只有一个元素时，左右指针均初始化为了0。此时中间元素也就是数组中的唯一元素，判断其是否为目标元素即可。</p><h2 id="一般情况">一般情况</h2><p>一般情况下进入一个while循环，并计算中间位置</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">mid=\frac{left+right}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.37144em;"></span><span class="strut bottom" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">t</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>并判断中间位置对应的元素是否为target。否则又分为三种情况：</p><ul><li>无法判断判断哪一部分有序</li><li>左半部分有序</li><li>右半部分有序</li></ul><h3 id="无法判断那一部分有序">无法判断那一部分有序</h3><p>无法判断判断哪一部分有序即nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]。此时同时缩小左右指针即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l++</span><br><span class="line">r--</span><br></pre></td></tr></table></figure><h3 id="左半部分有序">左半部分有序</h3><p>左半部分有序，即nums[l] &lt;= nums[mid]，先判断target是否在左半部分；此时又分两种情况：</p><ul><li>target在左半部分</li><li>target不在左半部分</li></ul><p>条件nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]即target在左半部分，此时令右指针r = mid - 1以缩小范围，否则令l = mid + 1。</p><h3 id="右半部分有序">右半部分有序</h3><p>排查无法判断哪一部分有序和左半部分有序即右半部分有序，此时类似与左半部分有序，也分两种情况：</p><ul><li>target在右半部分</li><li>target不在右半部分</li></ul><h2 id="复杂度分析">复杂度分析</h2><h3 id="时间复杂度">时间复杂度</h3><p>在一般情况下，二分查找的时间复杂度是O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span></span></span></span>)。<br>而当数组中出现大量重复元素时，并且都不与target相等时，退化为线性搜索，每一次循环都执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l++</span><br><span class="line">r--</span><br></pre></td></tr></table></figure><p>循环次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>次，时间复杂度为O(n)。</p><h3 id="空间复杂度">空间复杂度</h3><p>使用常数个变量，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题一：541. 反转字符串 II</title>
      <link href="/2025/01/31/leetcode1/"/>
      <url>/2025/01/31/leetcode1/</url>
      
        <content type="html"><![CDATA[<p>从12月份开始到现在陆陆续续参加了几次Leetcode的周赛，从几天也开始决定参加Leetcode的每日一题。思来想去，感觉也进行记录一下比较好。虽然大半年前也在搞这个东西，但是当时不会用hexo，当时只是使用markdown在本地进行记录，日常查看不如hexo方便。现在决定将Leetcode的每一题、周赛以及双周赛等等，总之就是对自己的学习做一个记录，方便朝花夕拾。</p><p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II</a>。这里也使用官方题解作为参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + <span class="built_in">min</span>(i + k, n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/reverse-string-ii/solutions/946553/fan-zhuan-zi-fu-chuan-ii-by-leetcode-sol-ua7s/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1>思路分析</h1><p>官方题解的核心思想很简单，就是遍历字符串，每次跳过2k个字符串，然后翻转前k个,翻转字符串使用reverse函数。使用for循环进行遍历，i从0开始，每次增加2k即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>k)</span><br></pre></td></tr></table></figure><p>翻转前k个字符，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span> (s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br></pre></td></tr></table></figure><p>此外还有两种特殊情况：</p><ul><li>如果剩余字符少于k个，就将这些字符剩余字符全部翻转</li><li>如果剩余字符少于2k个，但是大于k个，仍然将前k个字符进行翻转，其余字符保持不变。</li></ul><p>所以下述代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span> (s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br></pre></td></tr></table></figure><p>要修改成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span> (s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + <span class="built_in">min</span>(i + k, n));</span><br></pre></td></tr></table></figure><p>使用min(i + k, n)就可以将一般情况和两种特殊情况包含进来。其实一般情况和剩余字符少于2k个但大于k个可以归为一种情况，因为它们都需要翻转前k个字符，此时min(i + k, n) = i + k。而第二种特殊情况则不同，此时剩余字符不足k个，因此min (i + k, n) = n。</p><h1>时间复杂度</h1><p>字符串的长度为n，对于一个输入参数k，循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k)</span><br></pre></td></tr></table></figure><p>的循环次数：</p><ul><li>当n为2k的整数倍时，循环次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi></mrow><mrow><mn>2</mn><mi>k</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></li><li>当n不是2k的整数倍时，循环次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi></mrow><mrow><mn>2</mn><mi>k</mi></mrow></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n}{2k}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>（向上取整）</li></ul><p>因此循环次数可以表示为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi></mrow><mrow><mi>k</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>)。在每次循环中，执行reverse函数，reverse函数的时间复杂度为O(k)，因为在每次循环中reverse需要交换<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>k</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>对字符。因此总的时间复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi></mrow><mrow><mi>k</mi></mrow></mfrac><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\frac{n}{k} \times k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>)即O(n)。</p><h1>空间复杂度</h1><p>使用了常数个变量，故空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收收心，开始学习算法：子集和DP</title>
      <link href="/2025/01/30/algorithm1/"/>
      <url>/2025/01/30/algorithm1/</url>
      
        <content type="html"><![CDATA[<h1>收心回顾</h1><p>假期过了一半了，从1月9日开始到现在，已经21天了，假期余额18天。前面21天基本上是在看书、学习stm32、编程以及play。</p><p>看的书有《嵌入式C语言的自我修养》和《编译原理》，前一本看的比较多了，后一本就看了编译的基本过程，还得继续推进。</p><p>学习stm32是一个很有意思的过程，江科大的stm32教程就很高质量，目前已经学习到了使用按键控制LED。父亲每天看到我的stm32开发套件都很兴奋，他自学了电工知识，很厉害。</p><p>说自己编程了感觉自己就是在刷题，leetcode、洛谷、codeforce等等。其实在放假前的两周自己的编程的热情高涨，不是指刷题，是参与开源等等，连专业课都不顾直接去参与开源项目。考算法设计技巧与分析的前一天在给某个Github仓库的16位操作系统写clear的shell命令，然后复习三个小时，其实俺也不想复习，那天舍友发疯，吵吵闹闹到了3点半，流泪复习到4点，然后去参加9点的考试QVQ。11点考完出来吃完饭就去开发free命令，然后参与其他的开源项目，当时下一场考试是机器学习，在三天后，用了两天半去编程，半天复习考试。放假回家后没有那么高得热情了，主要是因为网络的问题。Github的仓库clone不下来也push不上去，直接download下来也不行，崩溃了。目前笔者写的这篇文章估计也得在返校之后才能放到服务器上。玩comfyui的时候，都是靠朋友下载再通过wechat传过来。不知道网络是因为DNS劫持，还是因为地域的问题。</p><p>至于play就不用多说了。</p><p><img src="/images/zhen_zi_dan.jpg" alt="嘻嘻"></p><h1>余下假期打算</h1><p>后续的18天，决定用来学习一下算法、stm32并且精进一下C++。我发现了一个很好的网站<a href="https://oi-wiki.org">OI wiki</a>，用来学习算法正合适。stm32还是接着看B站江科大的视频，再从嘉立创找点项目做做感觉就行，但是目前还是先学完江科大的视频为先。精进C++不知道用什么办法比较好，目前用Github是不行了，看看网上游戏开发是否可行。</p><h1>今日算法</h1><p>今天就学了学子集和DP，DP就是动态规划（Dynamic programing），OI wiki讲的比较抽象，就看了博客园的一篇博客<a href="https://www.cnblogs.com/Tenshi/p/14520614.html">【DP】解析 SOSdp（子集和 dp）</a>，感觉挺不错的。</p><p>子集和DP用于处理前缀和问题。前缀和问题，在一维时就是数列的前n项和；在二维或者多维度情况下给了两种方法：</p><ul><li>容斥原理<br>容斥原理（可以参考OI wiki的<a href="https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/">容斥原理</a>）就比方说班上有30个人喜欢语文，20个人喜欢数学，40个人喜欢英语，问这个班上有多少个人。如果单纯地将这三个数字相加肯定是大于班上的总人数的，因为班上会有部分人喜欢其中的两门甚至三门。这个感觉还需要再去理解一下，通过韦恩图和集合能很好理解两类或者三类的情况，但是对于更多类没有理解透彻。OI wiki上还给了一道例题<a href="https://www.luogu.com.cn/problem/P1387">洛谷 P1387 最大正方形</a></li><li>逐维求和<br>逐维求和就是每次固定一个维度，求其它维度，直到固定完所有维度。</li></ul><p>而子集和DP主要是用于求高维前缀和问题，子集和即Sum Over Subsets。子集和问题的大致描述为：一个大小为n的集合上定义了一个函数f，要求出子集和函数g，且有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>T</mi><mo>⊆</mo><mi>S</mi></mrow></msub><mi>f</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(S)=\sum_{T \subseteq S}f(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.050005em;"></span><span class="strut bottom" style="height:2.43952em;vertical-align:-1.389515em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mrel">=</span><span class="mop op-limits"><span class="vlist"><span style="top:1.194336em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-0.000005000000000032756em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></span></p><p>其中T是集合S的所有子集。<br>这里直接引用OI wiki的<a href="https://oi-wiki.org/basic/prefix-sum/#%E7%89%B9%E4%BE%8B%E5%AD%90%E9%9B%86%E5%92%8C-dp">代码</a>吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span>&amp; x : a) std::cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy.</span></span><br><span class="line">  <span class="keyword">auto</span> ps = a;</span><br><span class="line">  <span class="comment">// Loop over dimensions.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// Loop over i-th dimension.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> st = <span class="number">0</span>; st &lt; (<span class="number">1</span> &lt;&lt; n); ++st) &#123;</span><br><span class="line">      <span class="comment">// This condition implies that i-th dimension is 1.</span></span><br><span class="line">      <span class="keyword">if</span> ((st &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ps[... 1 ...] += ps[... 0 ...]. (i-th dimension)</span></span><br><span class="line">        ps[st] += ps[st ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x : ps) std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n表示集合中有n个元素，a是二进制编码，表示在该点的取值。在两层for循环中，外层循环用于遍历二进制编码的每一位，内层循环用于遍历每一个状态。貌似有点说不清的感觉。。。如果n为2，则使用两位二进制编码，1 &lt;&lt; n即1 &lt;&lt; 2 = 4，也就是a有四个元素，a[0]就是a[00]，a[1]就是a[01],a[2]就是a[10]，a[3]就是a[11]。把a[00]看成a[0][0]或许更好理解一点。ps数组就是前缀和数组，ps[1][1]即a[0][0]+a[0][1]+a[1][0]+a[1][1]。这样感觉更容易理解。内层循环就是遍历二进制编码的每一位，内层循环遍历a中每一个元素即a[0][0]、a[0][1]、a[1][0]、a[1][1]，虽然循环里显示的是ps，但是使用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ps=a</span><br></pre></td></tr></table></figure><p>将a拷贝了一份给ps。两层循环实现了每次遍历a中每一个元素的每一位，最终遍历完所有位，也就是前面所说的逐维求和。注意在遍历时就像二进制变化一样，也就是先a[00]，然后a[01]，再然后a[10]、a[11]。在循环里还有一个判断条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st &gt;&gt; i &amp; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其实就是在遍历第i位二进制编码，判断其是否为1。如果其为1，就对其取反。'^'符号是按位异或符号，当为1时，与1异或得0，从而实现第i位取反。<br>还有一点就是a[00]的子集为a[00]，而a[10]的子集有a[10]和a[00]。简单点说就是如果某一位为1，就将该位置为0作为一个子集。再比如说a[101]的子集有a[100]、a[001]、a[000]和a[101]。当i=0时，也就是二进制的最低位，p[11]+=p[10]。<br>至于为什么要加下列判断条件呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st &gt;&gt; i &amp; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其实是为了正确求和。当有此判断条件时，可以使得p[10]+=p[00]，注意是&quot;+=&quot;，前面差点把+忘了，p[00]=a[00]，最终可得p[10]=a[10]+a[00]。如果没有此判断条件就会使得p[10]+=(p[11]+p[00])，也就是说把p[11]也当成了p[10]的子集＋上了，这就会与求ps[1][0]时，本来ps[1][0]=a[0][0]+a[0][1]+a[1][0]，但却错误地把a[1][1]也加进去了，并且其他元素也有重复计算。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改默认渲染器，加快渲染速度</title>
      <link href="/2025/01/29/hexo1/"/>
      <url>/2025/01/29/hexo1/</url>
      
        <content type="html"><![CDATA[<p>今天突然发现之前使用hexo部署的博客加载慢并不是因为网速或者服务器在国外。而是与渲染器有关。发现这个是因为发现markdown数学公式在部署后没有正确渲染，寻找解决办法时意外发现的。</p><p>首先在根目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><p>用来删除Hexo默认的渲染器，默认的渲染器不支持KaTex，因此需要更换为<code>hexo-renderer-markdown-it</code>作为渲染器并且安装<code>markdown-it-katex插件</code>，通过以下命令实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-markdown-it markdown-it-katex --save</span><br></pre></td></tr></table></figure><p>然后在Hexo的配置文件_config.yml中添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-katex</span></span><br></pre></td></tr></table></figure><p>以配置<code>markdown-it</code>和<code>markdown-it-katex</code>。</p><p>通过上述配置虽然没有正确渲染公式（公式虽然渲染出来了，但是有点偏移），但是发现网页加载的出奇得快，感觉是新的渲染器<code>hexo-renderer-markdown-it</code>渲染能力比较强。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pomopomo</title>
      <link href="/2024/12/25/Pomopomo/"/>
      <url>/2024/12/25/Pomopomo/</url>
      
        <content type="html"><![CDATA[<h1>番茄钟开发学习笔记</h1><h2 id="项目简介">项目简介</h2><p>在DataWhale活动中，我使用豆包AI编程助手基于HTML和JavaScript开发了一个番茄钟应用。番茄钟是一种时间管理工具，通过分割工作时间和休息时间，提高工作效率和专注度。</p><h2 id="项目目标">项目目标</h2><ul><li>设计简洁：界面简洁直观，用户友好。</li><li>功能完善：实现基本的番茄工作法功能，计时、暂停、重置和统计。</li><li>跨平台兼容：确保在不同浏览器和设备上正常运行。</li><li>代码优化：编写高效、可维护的代码，遵循最佳实践。</li></ul><h2 id="技术栈">技术栈</h2><ul><li>前端：<ul><li>HTML5</li><li>CSS3</li><li>JavaScript (ES6)</li></ul></li><li>开发工具：<ul><li>Visual Studio Code</li><li>豆包AI编程助手</li></ul></li></ul><h2 id="开发步骤">开发步骤</h2><ol><li>项目初始化<br>创建项目文件夹，初始化Git仓库。<br>结构如下：</li><li>设计界面<br>使用HTML构建基本结构，包括计时显示、控制按钮（开始、暂停、重置）。<br>使用CSS进行样式设计，确保界面响应式，适配不同屏幕尺寸。</li><li>实现计时功能<br>使用JavaScript实现倒计时逻辑。<br>处理开始、暂停、重置按钮的事件。</li><li>添加统计功能<br>记录完成的番茄钟次数。<br>使用localStorage保存数据，持久化统计信息。</li><li>优化用户体验<br>添加声音提醒。<br>实现暗模式和亮模式切换。<br>增加动画效果，提高交互性。</li></ol><h2 id="遇到的挑战与解决方案">遇到的挑战与解决方案</h2><ol><li>定时器精度问题<br>挑战：使用setInterval可能导致计时不够精确，特别是在浏览器标签页不活跃时。</li></ol><p>解决方案：改用基于Date的计算，通过记录开始时间和当前时间差来精准计算剩余时间。</p><ol start="2"><li>响应式设计实现<br>挑战：确保应用在不同设备和屏幕尺寸下都能良好显示。</li></ol><p>解决方案：使用CSS媒体查询和弹性布局（Flexbox）优化布局，确保元素自适应调整。</p><ol start="3"><li>数据持久化<br>挑战：如何在用户关闭页面后保留统计数据。</li></ol><p>解决方案：利用localStorage在浏览器中存储完成的番茄钟次数，实现数据的持久化。</p><h1>学习收获</h1><ul><li>前端技能提升：通过项目实践，深入理解HTML、CSS和JavaScript的基本用法和高级技巧。</li><li>项目管理：学会使用Git进行版本控制，合理分配开发任务，保持代码整洁。</li><li>问题解决能力：在开发过程中遇到问题，通过查阅文档、寻求社区帮助，掌握了有效的解决问题的方法。</li><li>用户体验设计：了解用户需求，优化界面和交互，提高应用的易用性和用户满意度。</li></ul><h1>未来改进</h1><p>多语言支持：添加多种语言选择，提升国际用户体验。<br>数据可视化：使用图表展示工作与休息时间的分配情况。<br>用户账户系统：允许用户注册和登录，保存个性化设置和统计数据。<br>移动应用开发：将Web版番茄钟转化为移动应用，扩展使用场景。</p><h1>总结</h1><p>通过本次项目，我不仅实践了前端开发的基本技能，还提高了我的项目管理和问题解决能力。通过使用豆包AI编程助手的辅助，我能够更高效地完成开发任务，为未来的项目打下了坚实的基础。未来，我计划在此基础上添加更多功能，进一步提升应用的实用性和用户体验。</p><h1>致谢</h1><p>感谢DataWhale提供的学习平台和资源，以及豆包AI编程助手在开发过程中的有力支持。</p><h1>参考资料</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95">番茄工作法</a></li><li><a href="https://www.datawhale.cn/activity/116/23/94?rankingPage=1">Datawhale</a></li><li><a href="https://www.marscode.cn/home?utm_source=school&amp;utm_medium=datawhalelearn&amp;utm_campaign=camp1">豆包AI编程助手</a></li></ul><h1>附录</h1><h2 id="完整代码">完整代码</h2><h3 id="index-html"><code>index.html</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>番茄时钟<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.tailwindcss.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 自定义样式 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.timer</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&#x27;Helvetica Neue&#x27;</span>, sans-serif;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">5rem</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-bottom</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.buttons</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition</span>: background-color <span class="number">0.3s</span> ease;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span><span class="selector-class">.start</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#4caf50</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span><span class="selector-class">.start</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#45a049</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span><span class="selector-class">.pause</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#ff9800</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span><span class="selector-class">.pause</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f57c00</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span><span class="selector-class">.reset</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f44336</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span><span class="selector-class">.reset</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#e53935</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#stats</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&#x27;Arial, sans-serif&#x27;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;bg-gray-100 flex items-center justify-center h-screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bg-white p-8 rounded shadow-md w-96&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-2xl font-semibold mb-4&quot;</span>&gt;</span>番茄时钟<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;timer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;timer text-4xl font-bold text-gray-700&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex mt-8 buttons&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button start&quot;</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;pause&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button pause&quot;</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;stats&quot;</span>&gt;</span>已完成番茄钟次数：0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="script-js"><code>script.js</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">let</span> isRunning = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> time = <span class="number">1500</span>; <span class="comment">// 25分钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timerDisplay = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;timer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> startBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pauseBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;pause&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> resetBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;reset&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> statsDisplay = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;stats&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateDisplay</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> minutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>(time / <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">const</span> seconds = time % <span class="number">60</span>;</span><br><span class="line">    timerDisplay.<span class="property">textContent</span> = <span class="string">`<span class="subst">$&#123;minutes.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>:<span class="subst">$&#123;seconds.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateStats</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;pomodoroCount&#x27;</span>) || <span class="number">0</span>;</span><br><span class="line">    statsDisplay.<span class="property">textContent</span> = <span class="string">`已完成番茄钟次数：<span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">startTimer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRunning) <span class="keyword">return</span>;</span><br><span class="line">    isRunning = <span class="literal">true</span>;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time--;</span><br><span class="line">            <span class="title function_">updateDisplay</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">            isRunning = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> count = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;pomodoroCount&#x27;</span>) || <span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;pomodoroCount&#x27;</span>, count);</span><br><span class="line">            <span class="title function_">updateStats</span>();</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;时间到！&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pauseTimer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    isRunning = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resetTimer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    isRunning = <span class="literal">false</span>;</span><br><span class="line">    time = <span class="number">1500</span>;</span><br><span class="line">    <span class="title function_">updateDisplay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, startTimer);</span><br><span class="line">pauseBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, pauseTimer);</span><br><span class="line">resetBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, resetTimer);</span><br><span class="line"></span><br><span class="line"><span class="title function_">updateDisplay</span>();</span><br><span class="line"><span class="title function_">updateStats</span>();</span><br></pre></td></tr></table></figure><h3 id="styles-css"><code>styles.css</code></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f4f4f4</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#timer</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.controls</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#stats</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> AI编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现 Shell 的 clear 命令</title>
      <link href="/2024/12/23/OS-32Bit/"/>
      <url>/2024/12/23/OS-32Bit/</url>
      
        <content type="html"><![CDATA[<h1>简述</h1><p> 在这篇博客中，我将分享如何在一个操作系统项目<a href="https://github.com/IlanVinograd/OS_32Bit">IlanVinograd/OS_32Bit</a>中实现 clear 命令，进行清屏，然后重置光标定位到左上角的问题。</p><h2 id="开始遇到的问题">开始遇到的问题</h2><p> 一开始我遇到的问题是 Docker，这个项目的作者提供了 Dockerfile 文件来帮助配置环境，但是国内就连不上 Docker ( QvQ 或许有，但是我暂时不知道怎么搞，放到后续去学吧)。所以我就按照 Dockerfile 文件在本地安装了依赖，在本地编译所需要的工具，像 binutils 和 gcc-i686-elf ，并配置好环境变量，很顺利地在本地运行起了项目，不得不说项目作者很有水平。</p><p> 在操作系统的 Shell 中，clear 命令用于清空屏幕并将光标重置到左上角。一开始我是在 Code/Kernel/Sources/shell.c 文件中的 handleBackgroundColor 函数中识别 clear 命令，然后调用 clearScreen 函数进行清屏，在调用 setCursorPosition 函数将光标重置到左上角。但是这样进行处理有一点问题。 输入 clear 命令后要按下回车，有一个专门的函数 handle_enter 函数会覆盖掉我对 setCursorPosition 函数的调用， handle_enter 函数会自动将光标定位到下一行开头。所以我就在这个函数里也对 clear 命令进行识别，然后刷新输入缓冲区，退出即可。</p><p> 正当我兴致勃勃的想要向项目作者申请 issue 的 assign 时，并发起 Pull request 时，我不小心在本地合并分支到了 main 分支。虽然我学习过 git 的使用，但是确实用的太少了，导致很多命令不熟悉，进行了误操作，后续写一篇博客总结总结。所以又重新 clone 了项目， 进行修改。这次我突然想到为何要在 handleBackgroundColor 函数里识别 clear 命令呢？直接在 handle_enter 统一处理所有的 shell 命令不就行了。这里补充一点，项目作者实现了这个 32 位操作系统的整体框架，大部分 shell 命令都没有实现。在我进行的时候仅仅只实现了一个 test 测试命令。当然正是这个命令启发了我，让我使用最少的代码、最小的修改完成了这个功能。一开始我还使用关中断的方式实现原子操作来实现清屏与光标重定位，虽然没成功，但 exp++，哈哈。</p><h2 id="修改内容">修改内容</h2><ol><li>更新 handle_enter 函数<br> 首先，我在 handle_enter 函数中添加了对 clear 命令的处理逻辑。具体来说，当检测到输入的命令不是 clear 时，将光标移动到下一行的开头。否则，清空屏幕并将光标重置到左上角。</li></ol><p>修改前：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> row = keyboard_cursor_position / VGA_COLS;</span><br><span class="line">    <span class="type">uint16_t</span> col = keyboard_cursor_position % VGA_COLS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the blinking cursor before processing</span></span><br><span class="line">    <span class="built_in">setCursorPosition</span>(row, col);</span><br><span class="line">    <span class="built_in">putc</span>(<span class="string">&#x27; &#x27;</span>, COLOR_BLACK_ON_WHITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shell Functions</span></span><br><span class="line">    <span class="built_in">scrollIfNeeded</span>(row);</span><br><span class="line">    <span class="built_in">handleBackgroundColor</span>(inputBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test temp</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>((<span class="type">uint8_t</span>*)inputBuffer, (<span class="type">uint8_t</span>*)<span class="string">&quot;test&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">create_task</span>((<span class="type">uintptr_t</span>)test);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// end test temp</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move cursor to the next line</span></span><br><span class="line">    row++;</span><br><span class="line">    <span class="keyword">if</span> (row &gt;= VGA_ROWS) &#123;</span><br><span class="line">        <span class="comment">// Scroll again if we&#x27;re still at the last row</span></span><br><span class="line">        <span class="built_in">scroll_screen</span>();</span><br><span class="line">        row = VGA_ROWS - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    keyboard_cursor_position = row * VGA_COLS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setCursorPosition</span>(row, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset input buffer to default size</span></span><br><span class="line">    <span class="built_in">free</span>(inputBuffer); <span class="comment">// Free the current buffer</span></span><br><span class="line">    inputBufferSize = <span class="number">256</span>; <span class="comment">// Reset the buffer size</span></span><br><span class="line">    inputBuffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputBufferSize); <span class="comment">// Allocate a new buffer</span></span><br><span class="line">    <span class="keyword">if</span> (!inputBuffer) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Could not reallocate input buffer.\n&quot;</span>, RED_ON_BLACK_WARNING);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inputBuffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// Initialize the buffer</span></span><br><span class="line">    inputBufferIndex = <span class="number">0</span>;  <span class="comment">// Reset the index</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> row = keyboard_cursor_position / VGA_COLS;</span><br><span class="line">    <span class="type">uint16_t</span> col = keyboard_cursor_position % VGA_COLS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the blinking cursor before processing</span></span><br><span class="line">    <span class="built_in">setCursorPosition</span>(row, col);</span><br><span class="line">    <span class="built_in">putc</span>(<span class="string">&#x27; &#x27;</span>, COLOR_BLACK_ON_WHITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shell Functions</span></span><br><span class="line">    <span class="built_in">scrollIfNeeded</span>(row);</span><br><span class="line">    <span class="built_in">handleBackgroundColor</span>(inputBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test temp</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>((<span class="type">uint8_t</span>*)inputBuffer, (<span class="type">uint8_t</span>*)<span class="string">&quot;test&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">create_task</span>((<span class="type">uintptr_t</span>)test);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// end test temp</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move cursor to the next line if it is not clear command</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>((<span class="type">uint8_t</span>*)inputBuffer, (<span class="type">uint8_t</span>*)<span class="string">&quot;clear&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        row++;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= VGA_ROWS) &#123;</span><br><span class="line">            <span class="comment">// Scroll again if we&#x27;re still at the last row</span></span><br><span class="line">            <span class="built_in">scroll_screen</span>();</span><br><span class="line">            row = VGA_ROWS - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keyboard_cursor_position = row * VGA_COLS;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setCursorPosition</span>(row, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">clearScreen</span>();</span><br><span class="line">        keyboard_cursor_position = <span class="number">2</span> * VGA_COLS;</span><br><span class="line">        <span class="built_in">setCursorPosition</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset input buffer to default size</span></span><br><span class="line">    <span class="built_in">free</span>(inputBuffer); <span class="comment">// Free the current buffer</span></span><br><span class="line">    inputBufferSize = <span class="number">256</span>; <span class="comment">// Reset the buffer size</span></span><br><span class="line">    inputBuffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputBufferSize); <span class="comment">// Allocate a new buffer</span></span><br><span class="line">    <span class="keyword">if</span> (!inputBuffer) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Could not reallocate input buffer.\n&quot;</span>, RED_ON_BLACK_WARNING);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inputBuffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// Initialize the buffer</span></span><br><span class="line">    inputBufferIndex = <span class="number">0</span>;  <span class="comment">// Reset the index</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>修复 clearScreen 函数<br> 接下来，我修复了 clearScreen 函数，使其从行索引 2 开始清除，而不是原先的行索引 3。从索引 2 开始清除是因为项目作者在前两行打印了系统的一些信息。这里估计是项目作者一时疏忽。</li></ol><p> 为了确保修改后的代码正常工作，我重新编译，使用 qemu 模拟器(有没有大佬教教我怎么掌握这玩意儿，网上教程好少)启动这个系统，接下来：</p><ul><li>在 Shell 中输入 clear 命令并按下回车。</li><li>验证屏幕是否被清空，并且光标是否正确定位到左上角。</li></ul><h2 id="总结">总结</h2><p> 通过上述修改，我成功实现了 Shell 的 clear 命令。现在，输入 clear 命令后，屏幕会被清空，光标正确定位到左上角，同时不影响其他命令的正常运行。<br> 简单总结一下 git 的使用。首先将项目仓库 fork 到自己的 GitHub，然后从自己的 Github 将项目 clone 到本地。创建新的分支 new_branch_name（随便取的名字，只是做一个例子），在这个分支上进行修改。修改完毕后 git add 提交修改的文件，然后 git commit -m 对所进行的修改进行描述，使用双引号 &quot; 开头，可以实现多行描述，最后使用双引号 &quot; 结尾即可。一般 commit 的第一行对实现的功能或者修改进行大致描述，然后空一行详细描述做出的修改，比如修改了那个文件的那个函数等等。空一行是为了在执行 git log --oneline 时只展示大致描述，而不展示详细描述。做完上述工作后执行 git push origin new_branch_name 命令，然后登陆 Github 到自己的仓库页面，就可以看到 Create pull request 按钮提示你有一个合并请求。点击后像 commit 一样填写 decription 即可。如果你的 commit 只有一个它会自动帮你填写成你的 commit 。否则不会帮你自动填写。这样就算是一个完整的 PR 啦！<br> 总结一句话就是收获满满！<br> 希望这篇博客对您有所帮助。如果您有任何问题或建议，欢迎在评论区留言（评论区还没搓好，待续啦）。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell命令 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, this is Malone!</title>
      <link href="/2024/12/18/Hello-this-is-Malone/"/>
      <url>/2024/12/18/Hello-this-is-Malone/</url>
      
        <content type="html"><![CDATA[<h1>欢迎来到我的个人博客</h1><p>大家好！我是Malone，欢迎来到我的个人博客。在这里，我将分享我对人工智能和编程的热情与探索。</p><h1>关于我</h1><p>从小我就对计算机充满了好奇心，尤其是AI和编程。随着时间的推移，我不断学习和实践，逐渐积累了一些经验和知识。现在，我希望通过这个博客，与大家分享我的学习心得和项目经验。</p><h1>博客目标</h1><p>这个博客的主要目标是：</p><ul><li><strong>分享知识</strong>：无论你是初学者还是有经验的开发者，我都希望我的文章能对你有所帮助。</li><li><strong>记录学习过程</strong>：通过记录我的学习过程，我希望能更好地理解和掌握AI和编程相关的知识。</li><li><strong>交流互动</strong>：我非常期待与大家交流，互相学习，共同进步。</li></ul><h1>未来计划</h1><p>在接下来的时间里，我计划撰写以下几个方面的内容：</p><!-- - **AI基础**：介绍AI的基本概念和原理。 --><ul><li><strong>编程教程</strong>：分享一些编程语言（主要是Python、C、C++）的教程和技巧。</li><li><strong>项目实战</strong>：展示一些实际项目的开发过程和心得体会。</li><li><strong>最新动态</strong>：分享AI和编程领域的最新研究成果和技术动态。</li></ul><h1>互动交流</h1><p>我非常欢迎大家在文章下方留言，提出问题或建议。你也可以通过邮箱favorite.vampire@qq.com与我取得联系，让我们一起交流和探讨。</p><h1>ending</h1><p>感谢你读到这里！希望我的博客能对你有所帮助。下一篇文章，我将介绍AI的基本概念，敬请期待！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
