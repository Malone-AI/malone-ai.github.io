<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零一世界</title>
  
  
  <link href="http://malone-ai.github.io/atom.xml" rel="self"/>
  
  <link href="http://malone-ai.github.io/"/>
  <updated>2025-03-16T10:10:47.808Z</updated>
  <id>http://malone-ai.github.io/</id>
  
  <author>
    <name>Malone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Springboot3 + Vue3 实现数据的编辑与删除</title>
    <link href="http://malone-ai.github.io/2025/03/16/project-test7/"/>
    <id>http://malone-ai.github.io/2025/03/16/project-test7/</id>
    <published>2025-03-16T06:45:40.000Z</published>
    <updated>2025-03-16T10:10:47.808Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 编辑数据</h1><h2 id="1-1-流程">1.1 流程</h2><ol><li>在编辑的按钮上面加上点击事件</li><li>定义弹窗和表单的页面代码</li><li>点击触发弹窗打开(将行对象的数据 row 深度拷贝给 form 对象)</li><li>表单做一下数据绑定以及表单验证</li><li>后台要有对应的修改的接口来接受数据</li><li>修改的接口负责把数据更新到数据库里面</li><li>表单输入数据后点击确认按钮，把表单的数据传给后台接口</li><li>在修改成功之后再次加载表格的数据，关闭弹窗</li></ol><h2 id="1-2-前端添加按钮并绑定事件">1.2 前端添加按钮并绑定事件</h2><p>在前端的表单中添加编辑和删除按钮，编辑该表单项或者直接删除。</p><p>先在前端添加按钮：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table :data=<span class="string">&quot;data.tableData&quot;</span> style=<span class="string">&quot;width: 100%&quot;</span> :header-cell-style=<span class="string">&quot;&#123;color: &#x27;#333&#x27;, backgroundColor: &#x27;#eaf4FF&#x27;&#125;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;selection&quot;</span> <span class="attr">width</span>=<span class="string">&quot;55&quot;</span>/&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;username&quot;</span> <span class="attr">label</span>=<span class="string">&quot;账号&quot;</span>/&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;名称&quot;</span>/&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">label</span>=<span class="string">&quot;电话&quot;</span>/&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;email&quot;</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span>/&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;Edit&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;Delete&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line">&lt;/el-table&gt;</span><br></pre></td></tr></table></figure><p>中的这两行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=<span class="string">&quot;primary&quot;</span> icon=<span class="string">&quot;Edit&quot;</span> circle&gt;&lt;/el-button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;Delete&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后前端：<br><img src="image.png" alt="alt text"><br><img src="/images/project-test7_1.png" alt=""></p><p>给编辑按钮添加点击事件<code>@click=&quot;handlerEdit()&quot;</code>，并且需要将那一行的数据拿过来。</p><p>Element Plus 的 el-table 在每一行都会为其 slot 提供一个作用域对象（scope），该对象包含了当前行的数据（即 scope.row），以及当前列信息。使用 &lt;template #default=“scope”&gt; 就能拿到包含一行数据的 scope 对象，然后通过 scope.row 获取该行的完整数据信息</p><p>因此修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template #<span class="keyword">default</span>=<span class="string">&quot;scope&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;Edit&quot;</span> <span class="attr">circle</span> @<span class="attr">click</span>=<span class="string">&quot;handlerEdit(scope.row)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;Delete&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>并将 scope.row 也就是将那行数据传递给 handlerEdit 。</p><p>然后定义 handlerEdit 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const handlerEdit = (row) =&gt; &#123;</span><br><span class="line">  data.form = row</span><br><span class="line">  data.formVisible = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把行对象row赋值给data的form对象，然后通过form对象传递给后端接口。但是存在问题。</p><p>当点下编辑按钮时，去编辑后，没按下保存，前端渲染的数据就发生变化了。这是因为<strong>浅拷贝</strong>的问题。</p><p>点击编辑按钮时直接将 tableData 中某一行对象的引用赋值给了 data.form，而对象是<strong>引用类型</strong>。如果在未保存前修改了表单数据，由于它们<strong>引用同一个对象</strong>，表格中的数据也会随之变化。为避免这种情况，因使用<strong>深拷贝</strong>，在赋值时创建一个副本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handlerEdit</span> = (<span class="params">row</span>) =&gt; &#123;</span><br><span class="line">  data.<span class="property">form</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(row))</span><br><span class="line">  data.<span class="property">formVisible</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>JSON.parse(JSON.stringify(row))</code>通过 JSON 的序列化和反序列化创建了一个<strong>深拷贝</strong>，生成了一个全新的对象，这个对象与原始对象完全独立。</p><h2 id="1-3-添加后端接口">1.3 添加后端接口</h2><p>现在如果点击编辑按钮，编辑后点击保存按钮时触发的后端接口是<code>add</code>接口。也就是新增了一个数据，而不是更新。因此后端添加一个<code>update</code>接口。</p><p>controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Admin admin)</span> &#123;</span><br><span class="line">    adminService.update(admin);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Admin admin)</span> &#123;</span><br><span class="line">    adminMapper.updateById(admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateById</span><span class="params">(Admin admin)</span>;</span><br></pre></td></tr></table></figure><p>XML映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateById&quot;</span>&gt;</span></span><br><span class="line">    update `admin` set username = #&#123;username&#125;, password = #&#123;password&#125;, name = #&#123;name&#125;, phone = #&#123;phone&#125;, email = #&#123;email&#125;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XML映射里最后的<code>where id = #&#123;id&#125;</code>很关键，因为修改一定会有一个主键ID，没有就不能修改数据。</p><h2 id="1-4-前端添加绑定的事件">1.4 前端添加绑定的事件</h2><p>新增数据时点击保存按钮后，调用了前端中定义的<code>add</code>方法去向后端发送请求。</p><p>和新增数据类似，修改时也如此。前端添加一个update方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">update</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  formRef.<span class="property">value</span>.<span class="title function_">validate</span>(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (valid) &#123; <span class="comment">// 验证通过时</span></span><br><span class="line">      request.<span class="title function_">put</span>(<span class="string">&quot;/admin/update&quot;</span>, data.<span class="property">form</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">          data.<span class="property">formVisible</span> = <span class="literal">false</span></span><br><span class="line">          <span class="title class_">ElMessage</span>.<span class="title function_">success</span>(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">          <span class="title function_">load</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          data.<span class="property">formVisible</span> = <span class="literal">false</span></span><br><span class="line">          <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里向后端提交请求使用的是<code>put</code>而不是<code>post</code>，这是因为：<br>在 RESTful 风格中，向后台提交请求时通常使用不同的 HTTP 方法来表达不同的操作语义：</p><ul><li>POST 用于新增数据，因为新增操作是创建一个新的资源。</li><li>PUT 用于修改数据，因为修改操作是更新已存在的资源。<br>这种区分不仅让接口设计更符合 HTTP 标准，也让代码更具可读性。</li></ul><p>接下来还有一个问题，点击编辑按钮后进行修改，然后点击保存按钮。这个保存按钮绑定的事件是<code>add</code>，怎么让新增的保存按钮和编辑的保存按钮绑定不同的事件。</p><p>让保存按钮<strong>绑定save事件</strong>，然后重新定义一个save方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">save</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  data.<span class="property">form</span>.<span class="property">id</span> ? <span class="title function_">update</span>() : <span class="title function_">add</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>save方法判断form对象里的id属性来判断，如果id不为空就执行update否则执行add。这样就让保存按钮同时兼容了update和add。</p><p>此时再去编辑数据后保存，提示<code>未找到接口</code>，状态码为404。</p><p>原因是前端调用的是 PUT 请求，而后端的 <code>AdminController.update</code> 接口使用的是 @PostMapping。HTTP 方法不匹配导致路由找不到，从而返回 404。修改后端映射为 @PutMapping 即可。</p><h1>2. 删除数据</h1><h2 id="2-1-绑定事件并定义前端接口">2.1 绑定事件并定义前端接口</h2><p>将删除按钮绑定事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=<span class="string">&quot;danger&quot;</span> icon=<span class="string">&quot;Delete&quot;</span> circle <span class="meta">@click</span>=<span class="string">&quot;del(scope.row.id)&quot;</span>&gt;&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p>绑定<code>del</code>事件，接收一个参数，就是那行数据的id。</p><p>然后定义del方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">del</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">ElMessageBox</span>.<span class="title function_">confirm</span>(<span class="string">&quot;该操作不可逆，您确认删除改行数据吗？&quot;</span>, <span class="string">&#x27;删除确认&#x27;</span>, &#123;<span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    request.<span class="title function_">delete</span>(<span class="string">&#x27;/admin/delete/&#x27;</span> + id).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">success</span>(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">        <span class="title function_">load</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-定义后端接口">2.2 定义后端接口</h2><p>先是controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    adminService.delete(admin);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加<code>@DeleteMapping</code>注解，表示该方法专门处理 HTTP DELETE 请求；后面的<code>/&#123;id&#125;</code>是路径参数的占位符，它允许客户端通过 URL 传递一个具体的 id 值。</p><p>方法参数上的 <code>@PathVariable Integer id</code> 表示将 URL 中对应位置的参数解析并赋值给 <code>id</code> 参数，从而在方法内部使用。</p><p>例如，当请求 DELETE <code>/admin/delete/5</code> 时，Spring 会将 5 赋值给参数 <code>id</code>。</p><p>然后service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    adminMapper.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后mapper层，直接用<strong>注解式SQL</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete(&quot;delete from `admin` where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p>这样就实现了单行删除。</p><h1>3. 批量删除</h1><h2 id="3-1-绑定事件">3.1 绑定事件</h2><p>el-table有一个事件<code>@selection-change</code>，这个就是多选事件。</p><p>因此给el-table添加<code>@selection-change=&quot;handlerSelectionChange(rows)&quot;</code>，然后定义handlerSelectionChange方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handlerSelectionChange</span> = (<span class="params">rows</span>) =&gt; &#123;</span><br><span class="line">    data.<span class="property">rows</span> = rows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了选中多行，然后就是点击<code>批量删除</code>按钮删除。</p><p>因此<code>批量删除</code>按钮也要绑定事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=<span class="string">&quot;danger&quot;</span> @click=<span class="string">&quot;deleteBatch&quot;</span>&gt;批量删除&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p>然后定义deleteBatch方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deleteBatch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">rows</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title class_">ElMessage</span>.<span class="title function_">warning</span>(<span class="string">&#x27;请选择后再进行此操作&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">ElMessageBox</span>.<span class="title function_">confirm</span>(<span class="string">&quot;该操作不可逆，您确认删除吗？&quot;</span>, <span class="string">&#x27;删除确认&#x27;</span>, &#123;<span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    request.<span class="title function_">delete</span>(<span class="string">&#x27;/admin/deleteBatch/&#x27;</span>, &#123;<span class="attr">data</span>: data.<span class="property">rows</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">success</span>(<span class="string">&#x27;批量删除成功&#x27;</span>)</span><br><span class="line">        <span class="title function_">load</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一开始先是判断有没有进行选择。否则，不选择任何行数据也能进行操作，这显然是不合适的。</p><p>发送请求时就不能像单个删除一样发送一个id了，得发送成批的id。这里其实是将要删除的数据对象的所有属性都发过去了。</p><p>Axios 的 delete 方法允许在配置对象中通过 data 属性传递请求体，从而实现将多个 id 作为 JSON 数据发送到后端，从而完成批量删除操作</p><p>deleteBatch 通过 Axios 的 delete 方法传递了一个配置对象，其中配置项 data 包含了所有选中的数据。Axios 会将 { data: data.rows } 中的 data 作为请求体发送出去，且按照 JSON 格式传输。后端就可以通过<code>@RequestBody List&lt;Admin&gt; admin</code>来接收这一批要删除的数据对象。</p><h2 id="3-2-定义后端接口">3.2 定义后端接口</h2><p>controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/deleteBatch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">deleteBatch</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Admin&gt; list)</span> &#123;</span><br><span class="line">    adminService.deleteBatch(list);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBatch</span><span class="params">(List&lt;Admin&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Admin admin : list) &#123;</span><br><span class="line">        adminMapper.deleteById(admin.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接调用mapper层定义好的单个删除的接口。</p><p>这样就实现了批量删除了。</p><p>另外，必须给Admin.vue的data对象中添加一个<code>rows: []</code>属性，注意是方括号，不是花括号。</p><p><code>data.rows</code> 用于存储选中的多行数据，这些数据需要作为一个集合处理。数组 (<code>[]</code>) 是一种适合存储多个元素的数据结构，并且具有 <code>length</code> 属性和常用的数组方法（如 <code>push</code>, <code>splice</code> 等），便于判断数据数量和操作数据集合。而 <code>&#123;&#125;</code> 表示一个对象，不具备这些特性，所以不能正确判断选中行的数量，也无法作为一个列表进行迭代和删除操作。因此，必须使用数组 <code>[]</code> 来存储多个选中行的数据。</p><h1>声明</h1><p>本文是对B站视频<a href="https://www.bilibili.com/video/BV1w3PuewEfk?spm_id_from=333.788.videopod.sections&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】06. Springboot3+vue3实现增删改查、分页查询、批量删除（下）</a>的学习记录，侵权联系删。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1. 编辑数据&lt;/h1&gt;
&lt;h2 id=&quot;1-1-流程&quot;&gt;1.1 流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在编辑的按钮上面加上点击事件&lt;/li&gt;
&lt;li&gt;定义弹窗和表单的页面代码&lt;/li&gt;
&lt;li&gt;点击触发弹窗打开(将行对象的数据 row 深度拷贝给 form 对象)&lt;/li&gt;</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 + Vue3 实现表单验证</title>
    <link href="http://malone-ai.github.io/2025/03/15/project-test6/"/>
    <id>http://malone-ai.github.io/2025/03/15/project-test6/</id>
    <published>2025-03-15T12:00:54.000Z</published>
    <updated>2025-03-16T06:44:06.458Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 新增数据</h1><ul><li>基本步骤：<ol><li>在新增的按钮上面加上点击事件</li><li>定义弹窗和表单</li><li>点击触发弹窗打开</li><li>表单做一下数据绑定以及表单验证</li><li>后台要有对应的新增的接口来接受数据</li><li>新增的接口负责把数据插入到数据库里面</li><li>表单输入数据后点击确认按钮，把表单的数据传给后台接口</li><li>在新增成功后重新加载表格</li></ol></li></ul><hr><h1>2. 按钮绑定事件</h1><p>一共有三个按钮需要绑定事件：</p><ul><li>新增按钮<ul><li>点击弹出表单</li></ul></li><li>点击新增按钮后的弹窗中的保存和取消按钮<ul><li>保存按钮<ul><li>点击保存调用后台接口插入数据</li><li>清空前端用于接收数据的对象</li><li>刷新加载</li></ul></li><li>取消按钮<ul><li>点击取消</li><li>清空前端用于接收数据的对象</li></ul></li></ul></li></ul><p>在Admin.vue中的“新增”按钮中添加<code>@click=&quot;handlerAdd&quot;</code>，hanleAdd函数是需要我们实现的一个函数，用于新增。</p><hr><h1>3. 定义弹窗和表单</h1><p>从Element-Plus官网直接找一个改一改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog title=<span class="string">&quot;新增管理员信息&quot;</span> v-model=<span class="string">&quot;data.formVisible&quot;</span> width=<span class="string">&quot;500&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">&quot;data.form&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;80px&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;账号&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.username&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.name&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;电话&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.phone&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.email&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog-footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;data.formVisible = false&quot;</span>&gt;</span>取 消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;data.formVisible = false&quot;</span>&gt;</span>保 存<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><p>直接粘贴到Admin.vue中最后一个<code>&lt;/div&gt;</code>的前面，并将<code>v-model</code>设置为<code>data.formVisible</code>（在 Vue 中，v-model 是一种用于实现表单元素和组件数据的双向绑定的语法糖。也就是说，当你在模板中使用 v-model 时，Vue会自动将组件的值与你的响应式数据进行绑定，并在数据或视图变化时自动同步更新。例如，在 Admin.vue 中：</p><p>在<code>&lt;el-input v-model=&quot;data.username&quot;&gt;</code>中，输入框的内容会和 data.username 绑定。<br>在<code>&lt;el-pagination v-model:current-page=&quot;data.pageNum&quot;&gt;</code>中，当前页码会和 data.pageNum 同步，当用户翻页时，data.pageNum 自动更新。<br>这种双向绑定可以减少手动监听事件和更新数据的代码量，使得数据与视图的同步更加简洁和高效）。</p><p>然后在data中新增一个<code>formVisible</code>属性，并设置默认值为false，以及一个form空对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">pageNum</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">pageSize</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">total</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">tableData</span>: [],</span><br><span class="line">  <span class="attr">formVisible</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">form</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>formVisible设置为false意为弹窗默认不可见。因此要显示弹出只需在handlerAdd函数里设置formVisible为true即可。</p><p>form对象是用来绑定数据的，它可以在弹窗打开时接收数据。<code>el-form-item</code>组件里的<code>v-model</code>属性就是用来绑定对应的属性的。</p><p>在弹窗关闭后要手动清空form对象，不然下一次在打开弹窗时会有上一次的信息的残留。</p><p>因此<code>handlerAdd</code>函数为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handlerAdd</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  data.<span class="property">formVisible</span> = <span class="literal">true</span></span><br><span class="line">  data.<span class="property">form</span> = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再去点击新增按钮会弹出：<br><img src="image.png" alt="alt text"><br><img src="/images/project-test6_1.png" alt=""></p><hr><h1>4. 新增接口</h1><h2 id="4-1-controller层">4.1 controller层</h2><p>在controller接口层src/main/java/com/example/controller/AdminController.java中定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Admin admin)</span> &#123;</span><br><span class="line">    adminService.add(admin);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@PostMapping</code>注解告诉spring这是一个POST请求。POST 请求一般用于向服务器提交数据，创建资源。而 GET 请求通常用于查询数据，不适合用于数据新增。使用 POST 更符合 HTTP 协议设计原则。</p><p><code>@RequestBody</code>注解告诉 Spring 从请求体中解析 JSON 数据，并将其转换为 Admin 对象。（因为在 POST 请求中，新增的资源数据通常较多且结构复杂，将数据放在请求体中以 JSON 格式传递更为合理。使用 @RequestBody 注解，Spring 会自动将请求体中的 JSON 数据<strong>反序列化</strong>为 Admin 对象，从而更方便地处理复杂对象）</p><h2 id="4-2-service层">4.2 service层</h2><p>接下来在src/main/java/com/example/service/AdminService.java中添加service层接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Admin admin)</span> &#123;</span><br><span class="line">    adminMapper.insert(admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-mapper层">4.3 mapper层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/mapper/AdminMapper.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Admin admin)</span> &#123;</span><br><span class="line">        adminMapper.insert(admin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后XML映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// src/main/resources/mapper/AdminMapper.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">    insert into `admin` (username,  password, name, phone, email)</span><br><span class="line">    values(#&#123;username&#125;, #&#123;password&#125;, #&#123;name&#125;, #&#123;phone&#125;, #&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1>5. 保存按钮绑定事件</h1><p>将保存按钮绑定点击事件<code>@click=&quot;add&quot;</code>，然后去创建add方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span>= (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  request.<span class="title function_">post</span>(<span class="string">&quot;/admin/add&quot;</span>, data.<span class="property">form</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">      data.<span class="property">formVisible</span> = <span class="literal">false</span></span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">success</span>(<span class="string">&#x27;新增成功&#x27;</span>)</span><br><span class="line">      <span class="title function_">load</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      data.<span class="property">formVisible</span> = <span class="literal">false</span></span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数里通过request对象中的post请求将数据发给后端，然后后端将请求成功与否的结果传回来作返回值。前端根据这个结果来判断请求是否成功：</p><ul><li>返回的状态码为200，请求成功<ul><li>关闭弹窗</li><li>弹出新窗口提示成功</li><li>重新加载表格</li></ul></li><li>不为200，请求失败<ul><li>关闭弹窗</li><li>弹窗提示失败</li></ul></li></ul><hr><h1>6. 表单验证</h1><p>做表单验证是因为在前端插入数据时需要填四条信息，但是发现填一条信息也能新增数据。</p><p>dialog弹窗：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog title=<span class="string">&quot;新增管理员信息&quot;</span> v-model=<span class="string">&quot;data.formVisible&quot;</span> width=<span class="string">&quot;500&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog-footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;data.formVisible = false&quot;</span>&gt;</span>取 消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>保 存<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><p>表单项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog title=<span class="string">&quot;新增管理员信息&quot;</span> v-model=<span class="string">&quot;data.formVisible&quot;</span> width=<span class="string">&quot;500&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">&quot;data.form&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;80px&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding: 20px 30px 10px 0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;账号&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.username&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.name&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;电话&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.phone&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;data.form.email&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog-footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;data.formVisible = false&quot;</span>&gt;</span>取 消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>保 存<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><p>表单验证步骤如下：</p><ol><li>el-form 上必须有三个属性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref=&quot;formRef&quot; :model=&quot;data.form&quot; :rules=&quot;data.rules&quot;</span><br></pre></td></tr></table></figure><p>rules是data中的一个对象，用来描述表单规则</p><ol start="2"><li><p>在el-form-item上写上表单项的prop属性<br>prop属性要与数据的属性名称一致</p></li><li><p>在data的rules里定义验证规则<br>比如：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">  <span class="attr">username</span>: [</span><br><span class="line">    &#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;请填写账号`, trigger: &#x27;</span>blur<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><code>required: true</code>表示username项为必填项，<code>message: '请填写账号'</code>表示没填这一项时的提示信息，<code>trigger</code>是验证的时机，<code>trigger: blur</code>表示在表单失焦时验证。</p><p>其他四个属性也如法炮制即可。</p><p>进行验证发现，虽然做了表单验证但是即使不填写依然可以提交。</p><p>刚刚只是做了<strong>表单验证</strong>，但是并没有<strong>拦截</strong>。</p><ol start="4"><li>定义formRef对象</li></ol><p>这时候就需要用到el-form中绑定的<code>ref=formRef</code>。</p><p>现在定义这个formRef对象，先导入ref。ref是从vue中引用的，把原来的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive, ref&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br></pre></td></tr></table></figure><p>然后定义formRef对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formRef = <span class="title function_">ref</span>()</span><br></pre></td></tr></table></figure><ol start="5"><li>通过formRef对象验证<br>然后在add方法中使用formRef来进行验证：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span>= (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  formRef.<span class="property">value</span>.<span class="title function_">validate</span>(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (valid) &#123; <span class="comment">// 验证通过时</span></span><br><span class="line">      request.<span class="title function_">post</span>(<span class="string">&quot;/admin/add&quot;</span>, data.<span class="property">form</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">          data.<span class="property">formVisible</span> = <span class="literal">false</span></span><br><span class="line">          <span class="title class_">ElMessage</span>.<span class="title function_">success</span>(<span class="string">&#x27;新增成功&#x27;</span>)</span><br><span class="line">          <span class="title function_">load</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          data.<span class="property">formVisible</span> = <span class="literal">false</span></span><br><span class="line">          <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再去验证发现成功。</p><ol start="6"><li>其他问题1</li></ol><p>当点击新增按钮出发表单验证后有信息提示，但是按下取消按钮再点击新增按钮发现<strong>前一次表单验证信息还在</strong>。</p><p>只需要给el-dialog添加<strong>destroy-on-close</strong>即可，它可以重置dialog。</p><ol start="7"><li>其他问题2</li></ol><p>现在新增一个数据，去数据库查看发现这一项的password项是null。因此可以在后端进一步进行验证。</p><p>在service层修改add方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Admin admin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (admin.getPassword() == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(admin.getPassword())) &#123;</span><br><span class="line">        admin.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    adminMapper.insert(admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于判断<code>if (admin.getPassword() == null || &quot;&quot;.equals(admin.getPassword()))</code>可以通过Java的工具类Hutool来简化。</p><p>在springboot下的pom.xml中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Java 工具类 Hutool --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后add方法可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Admin admin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(admin.getPassword())) &#123;</span><br><span class="line">        admin.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    adminMapper.insert(admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以设置默认密码为<code>admin</code>。</p><p>还可以进一步优化，就是在插入之前查询一下账号是否重复，再进行插入。</p><p>在mapper层定义新的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Admin <span class="title function_">selectByUsername</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure><p>之前都是在mapper层定义接口后进行<strong>XML映射</strong>。</p><p>这一次使用<strong>注解式SQL</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from `admin` where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">Admin <span class="title function_">selectByUsername</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure><p>注解式SQL与XML映射实现的功能是一样的，二者只需要实现一个就可以了。</p><p>现在mapper层的add方法可以优化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Admin admin)</span> &#123;</span><br><span class="line">    <span class="type">Admin</span> <span class="variable">dbAdmin</span> <span class="operator">=</span> adminMapper.selectByUsername(admin.getUsername());</span><br><span class="line">    <span class="keyword">if</span> (dbAdmin != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomerException</span>(<span class="string">&quot;账号重复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(admin.getPassword())) &#123;</span><br><span class="line">        admin.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    adminMapper.insert(admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>7. 声明</h1><p>本文是对B站视频<a href="https://www.bilibili.com/video/BV1w3PuewEfk?spm_id_from=333.788.videopod.sections&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】06. Springboot3+vue3实现增删改查、分页查询、批量删除（下）</a>的学习记录，侵权联系删。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1. 新增数据&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;基本步骤：
&lt;ol&gt;
&lt;li&gt;在新增的按钮上面加上点击事件&lt;/li&gt;
&lt;li&gt;定义弹窗和表单&lt;/li&gt;
&lt;li&gt;点击触发弹窗打开&lt;/li&gt;
&lt;li&gt;表单做一下数据绑定以及表单验证&lt;/li&gt;
&lt;li&gt;后台要有对应的新增的接口来接受</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>C语言进程与线程的创建</title>
    <link href="http://malone-ai.github.io/2025/03/14/embedded2/"/>
    <id>http://malone-ai.github.io/2025/03/14/embedded2/</id>
    <published>2025-03-14T03:44:38.000Z</published>
    <updated>2025-03-14T16:59:48.160Z</updated>
    
    <content type="html"><![CDATA[<p><strong>进程</strong>是操作系统资源分配的基本单位，每个进程有独立的内存空间，进程间通信需要额外的机制。</p><p><strong>线程</strong>是CPU调度的基本单位，线程共享进程的内存空间，线程间通信更高效，但需要处理同步问题。</p><hr><h1>1. 创建新进程</h1><p>Linux 使用 fork 系统调用来创建一个进程，函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>fork 通过复制调用进程（父进程）来创建一个新进程（子进程）。新进程称为<strong>子进程</strong>，原调用进程称为<strong>父进程</strong>。</p><p>子进程和父进程运行在独立的内存空间中。在 fork() 执行时，两者的内存空间内容完全一致。但后续任一进程对内存的修改（写入）、文件映射（mmap(2)）或解除映射（munmap(2)）操作，均不会影响另一个进程。</p><p>fork() 执行之后，整个程序就分成了两路执行。</p><p>可以通过检查 fork() 的返回值，可以控制父子进程的行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 错误处理（如内存不足或进程数超限）</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程代码（pid 为子进程的PID）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，父进程需通过 wait() 或 waitpid() 回收子进程资源，防止僵尸进程。</p><p>fork() 常与 exec() 系列函数配合使用，实现“创建子进程 → 替换子进程程序”的经典模式（如Shell执行命令）。</p><!-- # 2. 创建新线程创建新线程使用pthread_create，函数原型为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p>使用该函数时需要 --&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;是操作系统资源分配的基本单位，每个进程有独立的内存空间，进程间通信需要额外的机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;是CPU调度的基本单位，线程共享进程的内存空间，线程间通信更高效，但需要处理同步问题。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://malone-ai.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://malone-ai.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="进程与线程的创建" scheme="http://malone-ai.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>C语言文件IO常用函数</title>
    <link href="http://malone-ai.github.io/2025/03/14/embedded1/"/>
    <id>http://malone-ai.github.io/2025/03/14/embedded1/</id>
    <published>2025-03-14T02:31:23.000Z</published>
    <updated>2025-03-14T08:06:39.178Z</updated>
    
    <content type="html"><![CDATA[<p>系统调用IO函数都是围绕着文件描述符fd进行相关操作的</p><hr><h1>1. fopen打开流</h1><p>FILE *stream， 文件指针，FILE结构体又被称作流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>path：指定文件路径,如：“./test.txt”</li><li>mode：指定文件的打开方式</li></ul></li><li>返回值<ul><li>成功，返回指向该文件的文件指针</li><li>若失败，返回NULL</li></ul></li></ul><p>mode参数：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>“r”</td><td>打开文本文件用于读</td></tr><tr><td>“w”</td><td>创建文本文件用于写，并删除已存在的内容(如果有的话)</td></tr><tr><td>“a”</td><td>添加；打开或创建文本文件用于在文件末尾写</td></tr><tr><td>“rb”</td><td>打开二进制文件用于读</td></tr><tr><td>“wb”</td><td>创建二进制文件用于写，并删除已存在的内容(如果有的话)</td></tr><tr><td>“ab”</td><td>添加；打开或创建二进制文件用于在文件末尾写</td></tr><tr><td>“r+”</td><td>打开文本文件用于更新(即读和写)</td></tr><tr><td>“w+”</td><td>创建文本文件用于更新，并删除已存在的内容(如果有的话)</td></tr><tr><td>“a+”</td><td>添加；打开或创建文本文件用于更新和在文件末尾写</td></tr><tr><td>“rb+”</td><td>打开二进制文件用于更新(即读和写)</td></tr><tr><td>“r+b”</td><td>打开二进制文件用于更新(即读和写)</td></tr><tr><td>“wb+”</td><td>创建二进制文件用于更新，并删除已存在的内容(如果有的话)</td></tr><tr><td>“w+b”</td><td>创建二进制文件用于更新，并删除已存在的内容(如果有的话)</td></tr><tr><td>“ab+”</td><td>添加；打开或创建二进制文件用于更新和在文件末尾写</td></tr><tr><td>“a+b”</td><td>添加；打开或创建二进制文件用于更新和在文件末尾写</td></tr></tbody></table><hr><h1>2. fclose关闭流</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>stream：文件指针（流）</li></ul></li><li>返回值<ul><li>成功，返回0</li><li>若失败，返回EOF</li></ul></li></ul><p>在该文件被关闭之前，冲洗缓冲中的输出数据。<br>缓冲区中的任何输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放此缓冲区。<br>当一个进程正常终止时（直接调用exit函数，或从main函数返回），则所有带未写缓冲数据的标准IO流都被冲洗，所有打开的标准IO流都被关闭</p><hr><h1>3. fwrite对打开的流写入</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>ptr：指向要写入数据的指针</li><li>size：指定写入的每个数据项的字节数，如调用sizeof(char)</li><li>nmemb：指定写入的数据项的个数</li><li>stream：要写入的文件流</li></ul></li><li>返回值<ul><li>返回实际写入的数据项的个数</li></ul></li></ul><p>假设我们有一个包含学生信息的结构体数组，我们想将这些信息写入一个文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    Student students[<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>, <span class="number">88.5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">21</span>, <span class="number">92.0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">19</span>, <span class="number">85.5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件以写入二进制数据</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;students.dat&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将学生信息写入文件</span></span><br><span class="line">    <span class="type">size_t</span> num_written = <span class="built_in">fwrite</span>(students, <span class="built_in">sizeof</span>(Student), <span class="number">3</span>, file);</span><br><span class="line">    <span class="keyword">if</span> (num_written != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;写入文件时出错&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据成功写入文件。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>打开文件：使用 <code>fopen</code> 函数以二进制写入模式 (<code>&quot;wb&quot;</code>) 打开文件 <code>students.dat</code>。如果文件打开失败，程序会输出错误信息并退出。</p></li><li><p>写入数据：使用 <code>fwrite</code> 函数将 <code>students</code> 数组中的数据写入文件。<code>sizeof(Student)</code> 表示每个学生信息的大小，<code>3</code> 表示要写入的学生数量。</p></li><li><p>检查写入结果：<code>fwrite</code> 返回成功写入的数据项数量。如果返回值不等于预期的数量（这里是 3），则说明写入过程中出现了错误。</p></li><li><p>输出结果：如果一切顺利，程序会输出“数据成功写入文件”。</p></li></ol><hr><h1>4. fread对打开的流进行读取</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>ptr：指向要存储数据内存的指针</li><li>size：指定读取的每个数据项的字节数</li><li>nmemb：指定要读取的数据项的个数</li><li>stream：要读取的文件流</li></ul></li><li>返回值<ul><li>返回实际读取数据项的个数</li></ul></li></ul><p>现在使用现在用 fread 读取由 fwrite 生成的 student.dat 二进制文件的学生信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    Student students[<span class="number">3</span>]; <span class="comment">// 用于存储读取的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以二进制读模式打开文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;students.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取数据到 students 数组</span></span><br><span class="line">    <span class="type">size_t</span> num_read = <span class="built_in">fread</span>(students, <span class="built_in">sizeof</span>(Student), <span class="number">3</span>, file);</span><br><span class="line">    <span class="keyword">if</span> (num_read != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;读取文件时出错&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功读取的学生信息：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学生 %d:\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, students[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;年龄: %d\n&quot;</span>, students[i].age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成绩: %.1f\n\n&quot;</span>, students[i].grade);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>打开文件：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">fopen</span>(<span class="string">&quot;students.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>“rb” 表示以二进制读模式打开文件。</li><li>如果文件不存在或权限不足，fopen 会返回 NULL，此时需要处理错误。</li></ul><ol start="2"><li>读取数据：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> num_read = <span class="built_in">fread</span>(students, <span class="built_in">sizeof</span>(Student), <span class="number">3</span>, file);</span><br></pre></td></tr></table></figure><ul><li>students 是存储数据的数组。</li><li>sizeof(Student) 是每个学生结构体的大小（58 字节）。</li><li>3 表示要读取 3 个学生数据。</li><li>num_read 是实际成功读取的数据项数量。如果 num_read &lt; 3，说明文件可能已损坏或读取失败。</li></ul><ol start="3"><li>打印信息</li></ol><ul><li>读取完成后，遍历数组并打印每个学生的信息：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">成功读取的学生信息：</span><br><span class="line">学生 1:</span><br><span class="line">姓名: Alice</span><br><span class="line">年龄: 20</span><br><span class="line">成绩: 88.5</span><br><span class="line"></span><br><span class="line">学生 2:</span><br><span class="line">姓名: Bob</span><br><span class="line">年龄: 21</span><br><span class="line">成绩: 92.0</span><br><span class="line"></span><br><span class="line">学生 3:</span><br><span class="line">姓名: Charlie</span><br><span class="line">年龄: 19</span><br><span class="line">成绩: 85.5</span><br></pre></td></tr></table></figure><hr><h1>5. fseek定位流</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>stream：指定重定位文件指针</li><li>offset：指定偏移量，整数表示正向偏移，负数表示负向偏移</li><li>whence：指定偏移基准位置<ul><li>宏SEEK_CUR（当前位置）</li><li>SEEK_END（文件结尾）</li><li>SEEK_SET（文件开头）</li></ul></li></ul></li><li>返回值<ul><li>成功，返回0</li><li>若失败，返回-1，且不改变指针位置。</li></ul></li></ul><p>假如我们想通过 fseek 直接定位到 student.dat 中某个学生的记录并读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    Student student;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以二进制读模式打开文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;students.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到第 2 个学生的记录（索引从 0 开始）</span></span><br><span class="line">    <span class="type">int</span> student_index = <span class="number">1</span>; <span class="comment">// 第 2 个学生</span></span><br><span class="line">    <span class="type">long</span> offset = student_index * <span class="built_in">sizeof</span>(Student);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fseek</span>(file, offset, SEEK_SET) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fseek 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取第 2 个学生的数据</span></span><br><span class="line">    <span class="type">size_t</span> num_read = <span class="built_in">fread</span>(&amp;student, <span class="built_in">sizeof</span>(Student), <span class="number">1</span>, file);</span><br><span class="line">    <span class="keyword">if</span> (num_read != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;读取文件时出错&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个学生的信息：\n&quot;</span>, student_index + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, student.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;年龄: %d\n&quot;</span>, student.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成绩: %.1f\n&quot;</span>, student.grade);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>打开文件<br>以二进制读模式打开文件 students.dat。</p></li><li><p>计算偏移量</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> offset = student_index * <span class="keyword">sizeof</span>(Student);</span><br></pre></td></tr></table></figure><ul><li>student_index 是要访问的学生的索引（从 0 开始）。</li><li>sizeof(Student) 是每个学生结构体的大小（58 字节）。</li><li>偏移量 offset 是从文件开头到目标学生记录的字节数。</li></ul><ol start="3"><li>定位文件指针</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fseek(file, offset, SEEK_SET) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fseek 失败&quot;</span>);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 fseek 将文件指针移动到目标学生的起始位置。</li><li>SEEK_SET 表示从文件开头计算偏移量。</li></ul><ol start="4"><li>读取数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> num_read = fread(&amp;student, <span class="keyword">sizeof</span>(Student), <span class="number">1</span>, file);</span><br></pre></td></tr></table></figure><ul><li>从当前位置读取一个 Student 结构体到 student 变量中。</li></ul><ol start="5"><li>打印数据：</li></ol><ul><li>打印读取的学生信息：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第 2 个学生的信息：</span><br><span class="line">姓名: Bob</span><br><span class="line">年龄: 21</span><br><span class="line">成绩: 92.0</span><br></pre></td></tr></table></figure><hr><h1>6. fputc写一个字符到文件</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li>ch：要写入的字符（以 int 形式传递，但实际写入的是其低 8 位）。</li><li>stream：指向文件流的指针（由 fopen 打开的文件）。</li></ul></li><li><p>返回值</p></li><li><p>成功时返回写入的字符。</p></li><li><p>失败时返回 EOF。</p></li></ul><p>使用 fputc 将一个字符串逐字符写入文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写模式打开文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串逐字符写入文件</span></span><br><span class="line">    <span class="keyword">while</span> (text[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fputc</span>(text[i], file) == EOF) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;写入文件时出错&quot;</span>);</span><br><span class="line">            <span class="built_in">fclose</span>(file);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符成功写入文件。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>打开文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>以写模式打开文件 output.txt。如果文件不存在，则创建它；如果文件已存在，则清空其内容。</li></ul><ol start="2"><li>逐字符写入文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (text[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fputc(text[i], file) == EOF) &#123;</span><br><span class="line">        perror(<span class="string">&quot;写入文件时出错&quot;</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 fputc 将字符串 text 中的每个字符写入文件。</li><li>如果 fputc 返回 EOF，说明写入失败，程序会输出错误信息并退出。</li></ul><ol start="3"><li>关闭文件：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><ul><li>关闭文件。</li></ul><ol start="4"><li>运行结果</li></ol><ul><li>如果程序运行成功，文件 output.txt 中将包含字符串 “Hello, World!”。</li></ul><hr><h1>7. fputs写一个字符串到文件中去</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str,FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>str：要写入的字符串（以 \0 结尾的 C 字符串）。</li><li>stream：指向文件流的指针（由 fopen 打开的文件）。</li></ul></li><li>返回值<ul><li>成功时返回非负值。</li><li>失败时返回 EOF。</li></ul></li></ul><p>使用 fputs 将一个字符串写入文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;Hello, World!\nThis is a test file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写模式打开文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串写入文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fputs</span>(text, file) == EOF) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;写入文件时出错&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串成功写入文件。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>打开文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>以写模式打开文件 output.txt。如果文件不存在，则创建它；如果文件已存在，则清空其内容。</li></ul><ol start="2"><li>写入字符串</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fputs</span>(text, file) == EOF) &#123;</span><br><span class="line">    perror(<span class="string">&quot;写入文件时出错&quot;</span>);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 fputs 将字符串 text 写入文件。</li><li>如果 fputs 返回 EOF，说明写入失败，程序会输出错误信息并退出。</li></ul><ol start="3"><li>关闭文件：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><p>关闭文件，确保所有数据写入磁盘。</p><ol start="4"><li>运行结果</li></ol><ul><li>如果程序运行成功，文件 output.txt 中将包含以下内容：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">This is a test file.</span><br></pre></td></tr></table></figure><hr><h1>8. fprinf往文件中写入格式化数据</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format,...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li>stream：指向文件流的指针（由 fopen 打开的文件）。</li><li>format：格式化字符串，指定如何格式化后续参数。</li><li><strong>…</strong>：可变参数列表，根据 format 字符串中的格式说明符进行格式化。</li></ul></li><li><p>返回值</p><ul><li>成功时返回写入的字符数。</li><li>失败时返回负值。</li></ul></li></ul><p>使用 fprintf 将格式化数据写入文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> grade = <span class="number">88.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写模式打开文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;student.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 fprintf 将格式化数据写入文件</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">fprintf</span>(file, <span class="string">&quot;姓名: %s\n年龄: %d\n成绩: %.1f\n&quot;</span>, name, age, grade);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;写入文件时出错&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;格式化数据成功写入文件。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序运行成功，文件 student.txt 中将包含以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名: Alice</span><br><span class="line">年龄: 20</span><br><span class="line">成绩: 88.5</span><br></pre></td></tr></table></figure><hr><h1>9. fgetc函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li>stream：指向文件流的指针（由 fopen 打开的文件）。</li></ul></li><li><p>返回值</p><ul><li>成功时返回读取的字符（以 int 形式返回）。</li><li>如果到达文件末尾或发生错误，返回 EOF。</li></ul></li></ul><p>使用 fgetc 逐字符读取文件内容并打印到控制台：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以读模式打开文件</span></span><br><span class="line">    file = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字符读取文件内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(file)) != EOF) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch); <span class="comment">// 将字符输出到控制台</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否因错误结束</span></span><br><span class="line">    <span class="keyword">if</span> (ferror(file)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;读取文件时出错&quot;</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n文件读取完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果文件 input.txt 的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">This is a test file.</span><br></pre></td></tr></table></figure><p>程序运行后，控制台输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件内容：</span><br><span class="line">Hello, World!</span><br><span class="line">This is a test file.</span><br><span class="line">文件读取完成。</span><br></pre></td></tr></table></figure><hr><h1>10. fgets从标准输入或文件中读取字符串。</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>str：指向存储读取数据的字符数组（缓冲区）。</li><li>n：要读取的最大字符数（包括结尾的空字符 \0）。</li><li>stream：指向文件流的指针（由 fopen 打开的文件）。</li></ul></li><li>返回值<ul><li>成功时返回 str。</li><li>如果到达文件末尾或发生错误，返回 NULL。</li></ul></li></ul><p>使用 fgets 逐行读取文件内容并打印到控制台：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>]; <span class="comment">// 用于存储每行内容的缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以读模式打开文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer); <span class="comment">// 将每行内容输出到控制台</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否因错误结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ferror</span>(file)) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;读取文件时出错&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件读取完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (fgets(buffer, sizeof(buffer), file) != NULL) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中：</p><ul><li>使用 fgets 逐行读取文件内容。</li><li>buffer 是用于存储每行内容的字符数组。</li><li>sizeof(buffer) 指定每次读取的最大字符数（包括结尾的 \0）。</li><li>如果成功读取一行，fgets 返回 buffer；如果到达文件末尾或发生错误，返回 NULL。</li><li>使用 printf 将每行内容输出到控制台。</li></ul><p>如果文件 input.txt 的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">This is a test file.</span><br><span class="line">Welcome to C programming.</span><br></pre></td></tr></table></figure><p>程序运行后，控制台输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件内容：</span><br><span class="line">Hello, World!</span><br><span class="line">This is a test file.</span><br><span class="line">Welcome to C programming.</span><br><span class="line">文件读取完成。</span><br></pre></td></tr></table></figure><hr><h1>11. fscanf从文件流中读取数据</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="type">const</span> <span class="type">char</span> * format, [argument...])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>stream：指向文件流的指针（由 fopen 打开的文件）。</li><li>format：格式化字符串，指定如何解析文件中的数据。</li><li><strong>…</strong>：可变参数列表，用于存储解析后的数据。</li></ul></li><li>返回值<ul><li>成功时返回成功匹配并赋值的输入项数。</li><li>如果到达文件末尾或发生错误，返回 EOF</li></ul></li></ul><p>使用 fscanf 从文件中读取格式化数据并打印到控制台：<br>假设文件 data.txt 的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice 20 88.5</span><br><span class="line">Bob 21 92.0</span><br><span class="line">Charlie 19 85.5</span><br></pre></td></tr></table></figure><p>我们希望读取每行的姓名、年龄和成绩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以读模式打开文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 fscanf 读取格式化数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%s %d %f&quot;</span>, name, &amp;age, &amp;grade) == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;姓名: %s, 年龄: %d, 成绩: %.1f\n&quot;</span>, name, age, grade);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否因错误结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ferror</span>(file)) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;读取文件时出错&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件读取完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 fscanf 从文件中读取格式化数据。</p><ul><li>格式化字符串 “%s %d %f” 指定了数据的格式：<ul><li>%s：读取一个字符串（姓名）。</li><li>%d：读取一个整数（年龄）。</li><li>%f：读取一个浮点数（成绩）。</li></ul></li><li>fscanf 返回成功匹配并赋值的输入项数。如果返回值等于 3，说明成功读取了一行数据。</li></ul><p>程序运行后，控制台输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件内容：</span><br><span class="line">姓名: Alice, 年龄: 20, 成绩: 88.5</span><br><span class="line">姓名: Bob, 年龄: 21, 成绩: 92.0</span><br><span class="line">姓名: Charlie, 年龄: 19, 成绩: 85.5</span><br><span class="line">文件读取完成。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;系统调用IO函数都是围绕着文件描述符fd进行相关操作的&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;1. fopen打开流&lt;/h1&gt;
&lt;p&gt;FILE *stream， 文件指针，FILE结构体又被称作流。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://malone-ai.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://malone-ai.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="文件IO" scheme="http://malone-ai.github.io/tags/%E6%96%87%E4%BB%B6IO/"/>
    
  </entry>
  
  <entry>
    <title>LeNet 推导</title>
    <link href="http://malone-ai.github.io/2025/03/13/LeNet/"/>
    <id>http://malone-ai.github.io/2025/03/13/LeNet/</id>
    <published>2025-03-13T12:58:42.000Z</published>
    <updated>2025-03-13T13:19:09.660Z</updated>
    
    <content type="html"><![CDATA[<p>LeNet-5是LeNet系列的最终稳定版，它被美国银行用于手写数字识别，该网络有以下特点：</p><ul><li>所有卷积核均为5x5，步长为1</li><li>所有池化方法为平均池化</li><li>所有激活函数采用Sigmoid</li></ul><hr><h1>1. LeNet 损失函数</h1><p>LeNet 的损失函数使用 <strong>交叉熵损失（Cross-Entropy Loss）</strong>，这是分类任务中最常用的损失函数之一。交叉熵损失用于衡量模型输出的概率分布与真实标签之间的差异。</p><hr><h2 id="1-1-交叉熵损失的数学公式">1.1 交叉熵损失的数学公式</h2><p>对于多分类问题，假设：</p><ul><li>模型的输出是一个概率分布 ( \hat{y} = (\hat{y}_1, \hat{y}_2, \dots, \hat{y}_C) )，其中 ( C ) 是类别数（LeNet 中 ( C = 10 )）。</li><li>真实标签是一个 one-hot 编码的向量 ( y = (y_1, y_2, \dots, y_C) )，其中只有一个元素为 1，其余为 0。</li></ul><p>交叉熵损失的公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">L</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">s</mi></mtext><mo>=</mo><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>C</mi></mrow></msubsup><msub><mi>y</mi><mi>i</mi></msub><mi>log</mi><mo>(</mo><msub><mover accent="true"><mrow><mi>y</mi></mrow><mo>^</mo></mover><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{Loss} = -\sum_{i=1}^{C} y_i \log(\hat{y}_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.8283360000000002em;"></span><span class="strut bottom" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="base displaystyle textstyle uncramped"><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">s</span></span><span class="mrel">=</span><span class="mord">−</span><span class="mop op-limits"><span class="vlist"><span style="top:1.1776689999999999em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.000005000000000143778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span style="top:-1.2500050000000003em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span><span style="top:0em;margin-left:0.11112em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>^</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是真实标签的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个元素。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mrow><mi>y</mi></mrow><mo>^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{y}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span><span style="top:0em;margin-left:0.11112em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>^</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是模型预测的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个类别的概率。</li></ul><hr><h2 id="1-2-LeNet-的输出层和损失函数">1.2 LeNet 的输出层和损失函数</h2><p>LeNet 的输出层是一个全连接层，输出 10 个值（对应 0-9 的数字类别）。为了将这些值转换为概率分布，通常使用 <strong>softmax 激活函数</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mrow><mi>y</mi></mrow><mo>^</mo></mover><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow></msup></mrow><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>C</mi></mrow></msubsup><msup><mi>e</mi><mrow><msub><mi>z</mi><mi>j</mi></msub></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat{y}_i = \frac{e^{z_i}}{\sum_{j=1}^{C} e^{z_j}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.341392em;"></span><span class="strut bottom" style="height:2.5098409999999998em;vertical-align:-1.1684489999999998em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span><span style="top:0em;margin-left:0.11112em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>^</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.7323309999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:-0.30997em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.07142857142857144em;margin-left:-0.04398em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.04398em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.04398em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是输出层的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个值。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mrow><mi>y</mi></mrow><mo>^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{y}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span><span style="top:0em;margin-left:0.11112em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>^</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个类别的预测概率。</li></ul><p>然后，使用交叉熵损失计算模型输出与真实标签之间的差异。</p><hr><h1>1.3 交叉熵损失的特点</h1><p>交叉熵损失是分类任务中最常用的损失函数之一，它直接衡量模型输出的概率分布与真实分布之间的差异。此外，它与 softmax 结合时，梯度计算简单且稳定，适合反向传播。</p><p>LeNet 的损失函数使用 <strong>交叉熵损失</strong>，用于衡量模型输出与真实标签之间的差异。通过最小化交叉熵损失，模型可以学习到更好的参数，从而提高分类准确率。交叉熵损失与 softmax 激活函数结合，是分类任务中的经典组合。</p><h1>2. 网络架构</h1><p>网络架构图：</p><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><h1>2.1 输入层</h1><p>LeNet-5 的输入是 <strong>32x32 的灰度图像</strong>，通道数为 1（因为是灰度图）。输入张量的形状为 <code>(1, 32, 32)</code>。</p><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><hr><h1>2.2 卷积层 C1</h1><ul><li><strong>卷积核大小</strong>：5x5</li><li><strong>卷积核数量</strong>：6</li><li><strong>步长（stride）</strong>：1</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>卷积操作的输出尺寸公式为：</p>\text{输出尺寸} = \frac{\text{输入尺寸} - \text{卷积核大小} + 2 \times \text{填充}}{\text{步幅}} + 1<p>对于 C1 层：</p>\text{输出尺寸} = \frac{32 - 5 + 2 \times 0}{1} + 1 = 28<p>因此，C1 层的输出是 <strong>6 个 28x28 的特征图</strong>，形状为 <code>(6, 28, 28)</code>。</p><hr><h1>2.3 池化层 S2</h1><ul><li><strong>池化类型</strong>：平均池化</li><li><strong>池化核大小</strong>：2x2</li><li><strong>步幅（stride）</strong>：2</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>池化操作的输出尺寸公式为：</p>\text{输出尺寸} = \frac{\text{输入尺寸} - \text{池化核大小}}{\text{步幅}} + 1<p>对于 S2 层：</p>\text{输出尺寸} = \frac{28 - 2}{2} + 1 = 14<p>因此，S2 层的输出是 <strong>6 个 14x14 的特征图</strong>，形状为 <code>(6, 14, 14)</code>。</p><hr><h1>2.4 卷积层 C3</h1><ul><li><strong>卷积核大小</strong>：5x5</li><li><strong>卷积核数量</strong>：16</li><li><strong>步幅（stride）</strong>：1</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>对于 C3 层：</p>\text{输出尺寸} =\frac{\text{输入尺寸} - \text{卷积核大小} + 2 \times \text{填充}}{\text{步幅}} + 1 = \frac{14 - 5 + 2 \times 0}{1} + 1 = 10<p>因此，C3 层的输出是 <strong>16 个 10x10 的特征图</strong>，形状为 <code>(16, 10, 10)</code>。</p><hr><h1>2.5 池化层 S4</h1><ul><li><strong>池化类型</strong>：平均池化</li><li><strong>池化核大小</strong>：2x2</li><li><strong>步幅（stride）</strong>：2</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>对于 S4 层：</p>\text{输出尺寸} = \frac{\text{输入尺寸} - \text{池化核大小}}{\text{步幅}} + 1 = \frac{10 - 2}{2} + 1 = 5<p>因此，S4 层的输出是 <strong>16 个 5x5 的特征图</strong>，形状为 <code>(16, 5, 5)</code>。</p><hr><h1>2.6 全连接层 C5</h1><ul><li><strong>输入</strong>：将 S4 层的输出展平为一维向量。</li><li><strong>输入大小</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>6</mn><mo>×</mo><mn>5</mn><mo>×</mo><mn>5</mn><mo>=</mo><mn>4</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">16 \times 5 \times 5 = 400</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mbin">×</span><span class="mord mathrm">5</span><span class="mbin">×</span><span class="mord mathrm">5</span><span class="mrel">=</span><span class="mord mathrm">4</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span></li><li><strong>输出大小</strong>：120</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>C5 层是一个全连接层，将 400 维的输入映射到 120 维的输出：</p>\text{输出} = W \cdot \text{输入} + b<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">W</span></span></span></span> 是权重矩阵，形状为 <code>(120, 400)</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span> 是偏置向量，形状为 <code>(120,)</code>。</p><hr><h1>2.7 全连接层 F6</h1><ul><li><strong>输入大小</strong>：120</li><li><strong>输出大小</strong>：84</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>F6 层将 120 维的输入映射到 84 维的输出：</p>\text{输出} = W \cdot \text{输入} + b<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">W</span></span></span></span> 是权重矩阵，形状为 <code>(84, 120)</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span> 是偏置向量，形状为 <code>(84,)</code>。</p><hr><h1>2.8 输出层</h1><ul><li><strong>输入大小</strong>：84</li><li><strong>输出大小</strong>：10（对应 0-9 的数字类别）</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>输出层将 84 维的输入映射到 10 维的输出。其计算为：</p>\text{输出} = W \cdot \text{输入} + b<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">W</span></span></span></span> 是权重矩阵，形状为 <code>(10, 84)</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span> 是偏置向量，形状为 <code>(10,)</code>。</p><p>最后，使用 <strong>softmax 激活函数</strong> 将输出转换为概率分布。</p><hr><h1>总结</h1><p>LeNet 通过卷积层提取局部特征，通过卷积核共享权重减少参数。使用池化层降低特征图维度，增强平移不变性。最后通过全连接层整合特征，输出分类结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LeNet-5是LeNet系列的最终稳定版，它被美国银行用于手写数字识别，该网络有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有卷积核均为5x5，步长为1&lt;/li&gt;
&lt;li&gt;所有池化方法为平均池化&lt;/li&gt;
&lt;li&gt;所有激活函数采用Sigmoid&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
      
    
    
    
    <category term="深度学习" scheme="http://malone-ai.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="http://malone-ai.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LeNet" scheme="http://malone-ai.github.io/tags/LeNet/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 + vue3 实现分页查询</title>
    <link href="http://malone-ai.github.io/2025/03/12/project-test5/"/>
    <id>http://malone-ai.github.io/2025/03/12/project-test5/</id>
    <published>2025-03-12T09:58:12.000Z</published>
    <updated>2025-03-16T06:41:48.761Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 插件安装与问题引出</h1><p>在vue工程目录打开cmd，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios -S</span><br></pre></td></tr></table></figure><p>安装插件</p><p>在vue/src/views/Home.vue中<code>&lt;script&gt;&lt;/script&gt;</code>之间添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#x27;http://localhost:9999/admin/selectAll&#x27;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行vue工程后进入manager/home路由，右键检查，在控制台里就发现了请求错误。</p><p>这个错误，其实是因为vue项目的端口和上面使用的端口不一样，这种情况下浏览器默认会有一个跨域的限制，不允许在不一样的端口号里请求数据：</p><pre><code>Failed to load resource: net::ERR_CONNECTION_REFUSED</code></pre><h2 id="1-2-处理跨域限制">1.2 处理跨域限制</h2><p>需要在springboot里设置统一的跨域处理。</p><p>在springboot工程的com.example.common里新建CorsConfig类，并对这个类添加<code>@Configuration</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">cosConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行springboot工程、vue工程，访问前端的manager/home，右键检查，查看控制台，就会发现有数据传过来了。</p><p>但是有时去请求并不一定会成功，所以可以判断一下状态码：<br>把在vue/src/views/Home.vue中<code>&lt;script&gt;&lt;/script&gt;</code>之间添加的代码改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#x27;http://localhost:9999/admin/selectAll&#x27;).then(res =&gt; &#123;</span><br><span class="line">  if (res.code != 200) &#123;</span><br><span class="line">    // 错误提示</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>2. 封装统一的请求工具 request.js</h1><p>在vue/src中新建一个utils目录，在这个目录下在创建request.js，内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ElMessage</span>&#125; <span class="keyword">from</span> <span class="string">&quot;element-plus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:9999&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">request.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">request.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> res = response.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> res == <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            res = res ? <span class="title class_">JSON</span>.<span class="title function_">parse</span>(res) : res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> === <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;未找到请求接口&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> === <span class="number">500</span>) &#123;</span><br><span class="line">            <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;系统异常，请查看后端控制台报错&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request</span><br></pre></td></tr></table></figure><ol><li>导入axios</li><li>导入了ElMessage（element-plus提供的弹窗提示的组件）</li><li>创建request对象<ul><li>通过axios的create方法创建了request对象</li><li>在request对象里设置了后端地址以及后台接口的超时时间（30s）</li></ul></li><li>请求开始做拦截器处理<ul><li>拦截器开始时设置统一的请求头为<strong>application/json</strong>，字符集为utf-i</li></ul></li><li>请求数据做拦截器处理<ul><li>先拿出结果（let res = response.data）</li><li>判断一下res的类型，如果是String就转换成json</li><li>当有错误时，<ul><li>如果状态码为404提示未找到请求接口</li><li>500，系统异常</li><li>其他交给控制台打印</li></ul></li></ul></li><li>返回request对象<ul><li>最后一行代码<strong>export default request</strong>用于返回request对象</li></ul></li></ol><p>然后就可以把在vue/src/views/Home.vue中<code>&lt;script&gt;&lt;/script&gt;</code>之间添加的代码改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="title function_">get</span>(<span class="string">&#x27;/admin/selectAll&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">ElMessage</span>(res.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>3. 分页查询</h1><p>不同于selectAll接口，分页查询selectPage接口返回的是分页对象，它包含：</p><ul><li>total：数据库表所有数据总的个数</li><li>list：返回的数据数组</li><li>pageNum：当前的页码</li><li>pageSize：每页展示的个数</li></ul><h2 id="3-1-添加依赖">3.1 添加依赖</h2><p>使用分页插件pageHelper来完成这个功能。<br>在springboot工程的pom.xml下添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页插件pageHelper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="image.png" alt="alt text"><br><img src="/images/project-test5_1.png" alt=""></p><p>加载依赖后就可以去实现selectPage接口了。</p><h2 id="3-2-接口实现">3.2 接口实现</h2><p>在springboot工程的com/example/controller/AdminController.java下添加分页查询的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/selectPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">selectPage</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer pageNum,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize)</span> &#123;</span><br><span class="line">    PageInfo&lt;Admin&gt; adminPageInfo = adminService.selectPage(pageNum, pageSize);</span><br><span class="line">    <span class="keyword">return</span> Result.success(adminPageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selectPage最少两个参数：</p><ul><li>pageNum：当前的页码</li><li>pageSize</li></ul><p><strong>@RequestParam</strong>是参数的路径，**(defaultValue = “1”)**是设置默认值为1。</p><p>这个接口主要是通过注入的类的具体对象adminService并调用这个对象的selectPage方法来实现的，adminService里我们还没有实现这个方法，因此我们得去adminService所属的类AdminService，也就是service层的一个类中去实现这个方法。</p><p>在springboot工程下的com/example/service/AdminService.java中添加selectPage方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageInfo&lt;Admin&gt; <span class="title function_">selectPage</span><span class="params">(Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 开启分页查询</span></span><br><span class="line">    PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">    List&lt;Admin&gt; adminList = adminMapper.selectAll();</span><br><span class="line">    <span class="keyword">return</span> PageInfo.of(adminList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以后访问前端的/manager/admin就可以获得数据了，但是还需要在前端渲染这个数据。</p><h2 id="3-3-数据渲染">3.3 数据渲染</h2><p>把vue/src/views/Home.vue更名为Admin.vue，然后在<code>&lt;script&gt;&lt;/script&gt;</code>之间添加的代码改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">load</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  request.<span class="title function_">get</span>(<span class="string">&#x27;/admin/selectPage&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    data.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">list</span></span><br><span class="line">    data.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">total</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">load</span>()</span><br></pre></td></tr></table></figure><p><code>const load = () =&gt; &#123;&#125;</code>部分是定义一个方法，<code>load()</code>是调用这个方法。</p><p>现在去访问前端的/manager/admin接口就可以实现数据渲染，但是无法实现分页。</p><p>我们在service层和controller层的接口都是带两个默认参数的，但是我们在Admin.vue中并没有传递任何参数，只使用了默认参数。应传递参数。</p><p>所以将<code>load</code>方法改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">load</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  request.<span class="title function_">get</span>(<span class="string">&#x27;/admin/selectPage&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">pageNum</span>: data.<span class="property">pageNum</span>,</span><br><span class="line">      <span class="attr">pageSize</span>: data.<span class="property">pageSize</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    data.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">list</span></span><br><span class="line">    data.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">total</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">load</span>()</span><br></pre></td></tr></table></figure><p>现在去访问前端的/manager/admin接口发现之前是一次性展示了所有数据，这次是展示了5个数据（data.pageSize=5）。但是切换页面没有什么变化。</p><p>把el-table组件下有一行代码是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@current-change=<span class="string">&quot;handleCurrentChange&quot;</span></span><br></pre></td></tr></table></figure><p>把参数改成&quot;load&quot;，意为切换页码时触发load方法调用，这样就实现了分页查询。</p><p>再添加请求成功与否判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">load</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  request.<span class="title function_">get</span>(<span class="string">&#x27;/admin/selectPage&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">pageNum</span>: data.<span class="property">pageNum</span>,</span><br><span class="line">      <span class="attr">pageSize</span>: data.<span class="property">pageSize</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">      data.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">list</span></span><br><span class="line">      data.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">total</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">load</span>()</span><br></pre></td></tr></table></figure><h2 id="3-4-查询">3.4 查询</h2><p>前面实现了分页，现在实现查询。</p><p>那么需要在load方法里再添加一个参数<code>name</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">load</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  request.<span class="title function_">get</span>(<span class="string">&#x27;/admin/selectPage&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">pageNum</span>: data.<span class="property">pageNum</span>,</span><br><span class="line">      <span class="attr">pageSize</span>: data.<span class="property">pageSize</span>,</span><br><span class="line">      <span class="attr">name</span>: data.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">      data.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">list</span></span><br><span class="line">      data.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">total</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">load</span>()</span><br></pre></td></tr></table></figure><p>这里load调用的是后端controller层的接口，然后controller层再调用service层，service层又通过mapper层，所以controller层和service层的接口也要添加一个参数，mapper层也要进行修改。</p><p>先是controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/selectPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">selectPage</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer pageNum,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(required = false)</span> String name)</span> &#123;</span><br><span class="line">    PageInfo&lt;Admin&gt; adminPageInfo = adminService.selectPage(pageNum, pageSize, name);</span><br><span class="line">    <span class="keyword">return</span> Result.success(adminPageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在参数中添加了<code>@RequestParam(required = false) String name</code>,required = false就是不强制接收这个参数。</li><li>在adminService的selectPage方法调用里添加name参数</li></ul><p>然后是service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Admin&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> adminMapper.selectAll(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> PageInfo&lt;Admin&gt; <span class="title function_">selectPage</span><span class="params">(Integer pageNum, Integer pageSize, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 开启分页查询</span></span><br><span class="line">    PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">    List&lt;Admin&gt; adminList = adminMapper.selectAll(name);</span><br><span class="line">    <span class="keyword">return</span> PageInfo.of(adminList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>selectAll中调用AdminMapper类对象adminMapper的方法selectAll时添加null参数，表示不进行查询</li><li>在selectPage中调用adminMapper.selectAll的调用添加name参数</li></ul><p>接着修改mapper层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdminMapper</span> &#123;</span><br><span class="line">    List&lt;Admin&gt; <span class="title function_">selectAll</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着还需要修改mapper对应的src/main/resources/mapper/AdminMapper.xml中的SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.AdminMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.Admin&quot;</span>&gt;</span></span><br><span class="line">        select * from `admin`</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">        order by id desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中原来的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `admin` order by id desc</span><br></pre></td></tr></table></figure><p>变成了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from `admin`</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">order by id desc</span><br></pre></td></tr></table></figure><p><code>&lt;where&gt;...&lt;/where&gt;</code>部分是做判断：</p><ul><li>当name != null时相当于语句<code>select * from </code>admin<code> where name = #&#123;&#125; order by id desc</code></li><li>当name == null时相当于语句<code>select * from </code>admin<code> order by id desc</code></li><li><code>name = #&#123;name&#125;</code>是精确查询</li><li><code>name like concat('%', #&#123;name&#125;, '%')</code>是模糊查询</li><li>这其实是MyBatic的支持</li></ul><p>另外前端还需要在查询按钮绑定点击事件<code>@click=&quot;load&quot;</code></p><h1>4. 声明</h1><p>本文是对B站视频<a href="https://www.bilibili.com/video/BV1wNPNeSEEQ?spm_id_from=333.788.videopod.sections&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】05. Springboot3+vue3实现增删改查、分页查询、批量删除（上）</a>的学习记录，侵权联系删。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1. 插件安装与问题引出&lt;/h1&gt;
&lt;p&gt;在vue工程目录打开cmd，运行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>YOLO</title>
    <link href="http://malone-ai.github.io/2025/03/11/yolo1/"/>
    <id>http://malone-ai.github.io/2025/03/11/yolo1/</id>
    <published>2025-03-11T03:35:43.000Z</published>
    <updated>2025-03-13T12:59:25.744Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 目标检测综述</h1><p>目标检测分为：</p><ul><li>one-stage detector（单阶段模型）<ul><li>代表有Yolo、SSD、Retina-net</li></ul></li><li>two-stage detector（两阶段模型）<ul><li>先从图像提取若干候选框，再逐一对这些候选框做分类、甄别以及调整它们的坐标。</li><li>代表有RCNN、SPPNet、Fast RCNN</li></ul></li></ul><p>R-CNN——Regions with CNN features</p><ol><li>输入图像</li><li>提取候选区域（~2k）</li><li>计算CNN特征</li><li>将区域分类</li></ol><p>YOLO论文链接<a href="https://arxiv.org/pdf/1506.02640">You Only Look Once:Unifed, Real-Time Obiect Detection</a></p><h1>2. 预测阶段（前向推断）</h1><p>此时模型是已经训练好的，输入未知图片进行预测，此时没有反向传播，只有前向推断。</p><h2 id="2-1-Yolo-网络架构">2.1 Yolo 网络架构</h2><p><img src="/images/yolo1_1.png" alt=""><br><img src="image.png" alt="alt text"></p><p>24层卷积层提取图像特征，2层全连接层回归得到7x7x30的向量。</p><p>输入是448x448x3的图像，也就是先将一张彩色图片缩放成448x448像素的图片，3是3通道RGB。然后经过若干个卷积层、池化层，最后变成一个7x7x1024维的feature map。再把它拉直，喂到一个4096个神经元的全连接层中输出4096维的向量。再把这个4096维向量喂到1470（7x7x30）个神经元的全连接层中，输出1470维的向量（其实最后是把这个1470维的向量Reshape成了7x7x30的向量）。最后输出的7x7x30维的向量包含就包含了所有预测框的坐标、置信度和类别结果。我们只需要解析这个向量就可以获得最终的结果。这个就是整个黑箱子的框架。</p><h2 id="2-2-为什么是7x7x30呢？">2.2 为什么是7x7x30呢？</h2><p>因为网络先把图像划分为SxS个grid cell（也就是网格），在YOLOV1中S=7。每个grid cell预测出B个bounding box（预测框），YOLOV1中B=2。每个grid cell预测出的两个bounding box可能很大也可能很小，也可能与其他的bounding box存在重叠，但是无所谓，只要bounding box的中心点落在这个grid cell里，就说明这个bounding box是由这个grid cell生成的。</p><p><img src="/images/yolo1_2.png" alt=""><br><img src="image-1.png" alt="alt text"></p><p>7x7=49个grid cell，每个grid cell生成两个bounding box，那么就生成了98个bounding box。bounding box包含x、y、h、w这四个坐标，由这四个坐标可以确定bounding box的位置。另外bounding box还包含一个它含不含有一个object的置信度（我理解为这个bounding box中含有物体的概率P(object)），在图像中置信度由bounding box边框线的粗细来表示，越粗置信度越高。这样一个bounding box可以由四个位置参数和一个置信度参数组成的(x,y,h,w,c)来表示。可视化出来就是上面图中由密密麻麻黑线的这幅图。</p><p>另外，每个grid cell还能生成所有类别的条件概率。也就是，假设输入在包含object的情况下，这些object是某个类别的概率。也就是上面图中有彩色块的图。把每个bounding box的置信度乘以类别条件概率，就能获得每个bounding box属于各类别的概率。7x7x30中的30为SxSx(5xB+C)。</p><p>再详细解释一些这个30。</p><p>每个grid cell包含2（即B）个预测框，每个预测框有5个参数，然后在Pascal VOC中包含20（即C）个类别。这一个30就是一个grid cell的信息，总共7x7个grid cell，所以是7x7x30维的向量。</p><p><img src="/images/yolo1_3.png" alt=""><br><img src="image-2.png" alt="alt text"><br>注：图中的box即bounding box</p><p>总结一下就是，输入一张图像，YOLO就能SxS个grid cell的信息，每个grid cell包含2个bounding box和20个类别，每个bounding box又包含4个位置参数和一个置信度参数。</p><h2 id="2-3-可视化过程">2.3 可视化过程</h2><ol><li><p>首先把图像分成SxS个grid cell，这里S=7：<br><img src="/images/yolo1_4.png" alt=""><br><img src="image-3.png" alt="alt text"></p></li><li><p>每个grid cell预测出两个bounding box（包含四个位置参数和一个置信度参数）</p></li></ol><p>比如对于下面图中这个红色的grid cell：<br><img src="/images/yolo1_5.png" alt=""><br><img src="image-4.png" alt="alt text"></p><p>它预测出两个bounding box，这两个bounding box一个置信度比较高，一个比较低（由线的粗细表示）：</p><p><img src="/images/yolo1_6.png" alt=""><br><img src="image-5.png" alt="alt text"></p><p>不管如何，输入图像都能预测出SxSx2=98个bounding box，只不过有些bounding box的置信度高，我们将其保留；有些低我们将其忽略。</p><ol start="3"><li>每个grid cell还能生成20个类别的条件概率：</li></ol><p><img src="/images/yolo1_7.png" alt=""><br><img src="image-6.png" alt="alt text"></p><p>这个图就展示了条件概率最高的几个类别所占有的框。比如紫色的grid cell是Bicycle这个类别的条件概率高的区域。每一个grid cell只能有一个类别，它是20个类别中条件概率最高的那一个。因此也说明了一个grid cell最多预测出一个一物体。7x7的grid cell最多预测出49个物体。这也是YOLOV1对小目标和密集目标识别性能差的原因。</p><ol start="4"><li>后处理<br>每个grid cell只有一个条件概率最高的代表类别，把这个grid cell的两个bounding box都赋予这个类别，再进行一系列后处理就得到了最终的目标检测结果。</li></ol><p><img src="/images/yolo1_8.png" alt=""><br><img src="image-7.png" alt="alt text"></p><p>把上面图中用红色部分标出来的部分，也就是所有的bounding box和所有grid cell的代表类别。每个类别赋予不同的颜色，把所有的bounding box的边框都用代表类别的颜色来表示，就得到了下面这幅图：</p><p><img src="/images/yolo1_9.png" alt=""><br><img src="image-8.png" alt="alt text"></p><p>总共98个bounding box，每个bounding box都有最高条件概率所对应的类别，再进行一系列后处理，比如过滤掉低置信度的bounding box，然后再去除掉重复的预测框，就获得了最终的目标检测结果。</p><h1>3. 预测阶段后处理</h1><p>总共98个bounding box，过滤掉低置信度的bounding box，然后再去除掉重复的预测框，就获得了最终的目标检测结果，这个过程称为<strong>NMS非极大值抑制</strong>。</p><p>现在想要讲解的就是YOLOV1输出的7x7x30的向量是如何变为最后的目标检测结果的。</p><p>7x7x30中的7x7即7x7个grid cell，取出其中一个grid cell来看，也就是30个数字。这30个数字是5+5+20。第一个5是第一个bounding box的4个位置坐标和1个置信度坐标，第二个5是第二个bounding box的4个位置坐标和1个置信度坐标，20是这个grid cell中的物体是20个类别的条件概率即P(ci|object)（P(object)是这个grid cell包含物体的概率，这其实就是置信度，ci是第i个类别）。</p><p>第一个bounding box的置信度乘以该grid cell的20个类条件概率：<br><img src="/images/yolo1_10.png" alt=""><br><img src="image-9.png" alt="alt text"><br>得到第一个bounding box的后验概率。</p><p>第二个bounding box的置信度乘以该grid cell的20个类条件概率：<br><img src="/images/yolo1_11.png" alt=""><br><img src="image-10.png" alt="alt text"><br>得到第二个bounding box的后验概率。</p><p>每个grid cell就能获得2个<strong>20个后验概率</strong>：<br><img src="/images/yolo1_12.png" alt=""><br><img src="image-11.png" alt="alt text"></p><p>7x7=49个grid cell就能获得7x7x2=98个<strong>20个后验概率</strong>：<br><img src="/images/yolo1_13.png" alt=""><br><img src="image-12.png" alt="alt text"></p><p>也就是我们获得了这个可视化图：<br><img src="/images/yolo1_9.png" alt=""><br><img src="image-8.png" alt="alt text"></p><p>接下来就是进行后处理得到目标检测结果图。</p><p>98个<strong>20个后验概率</strong>，称其为98个向量，每个向量是20x1的。假设这98个向量每个的第一个值为是狗的后验概率，也就是说是狗的后验概率的值有98个，在这些后验概率中有可能有很多接近于0的，设置一个阈值，假如设为0.2，那么小于0.2的值直接置为0。然后基于上一步处理后的是狗的后验概率对这98个后验概率进行降序排序，然后使用<strong>NMS非极大值抑制</strong>算法再次进行处理。</p><p><img src="/images/yolo1_14.png" alt=""><br><img src="image-13.png" alt="alt text"></p><p>先把第一个后验概率值取出来，也就是最大的后验概率，把它与其他97个后验概率值进行比较，计算它们的IoU（交并比，也就是度量它们的重叠程度）大于某个阈值，那么就认为它们重复识别了一个物体，就把低后验概率的值过滤掉也就是置为0。</p><ul><li>如果这个阈值设得很低，那么NMS非极大值抑制是很强的，它把IoU压得很低，稍微有一点重合就被过滤了</li><li>如果这个阈值设得很高，那么它们的IoU在更大的情况下才可能被过滤掉</li></ul><p>因此如果想增强NMS非极大值抑制就可以设置低阈值。</p><p>然后经过一轮后，第一个后验概率与其他97个后验概率经过了一轮比较，有部分已经被置为0了。然后去找下一个未被置为0的后验概率，接着与后面的后验概率进行比较，与上面相同。</p><p>上面只是对狗这个类别进行了NMS非极大值抑制，对于其他类别也要进行此操作。</p><p>上面的后处理<strong>只在预测阶段进行</strong>，在<strong>训练阶段不需要进行后处理</strong>，因为每一个bounding box都需要在损失函数中占据一席之地，它会影响损失函数。</p><h1>4. 训练阶段（重点）</h1><p>目标检测是一个典型的<strong>监督学习</strong>的过程，训练集已经进行了人工标注，它有点类似于bounding box，但是称它为ground truth（也就是正确打标记的数据）。我们的算法就是要去拟合这些ground truth，使得损失函数最小化。</p><p>ground truth是标准答案，它的中心点落在哪个grid cell，就有哪个grid cell预测出的两个bounding box中的一个负责去拟合这个ground truth，并且这个grid cell输出的类别也应该是这个ground truth的类别（每一个grid cell中有20个类别的类条件概率，这20个类条件概率乘以每一个bounding box的置信度获得后验概率，其中最大的后验概率对应的那个类应与ground truth的类别相同）。每一个grid cell只能预测出一个物体，7x7个grid cell只能预测出49个物体（YOLO在预测小目标和密集目标性能差的原因，前面提过了，再重复一遍）。</p><p>一个grid cell预测出两个bounding box，那由哪个去负责拟合ground truth呢？由和ground truth交并比IoU更大的那个bounding box。因此损失函数设计就要做到让负责拟合ground truth的那个bounding box与ground truth尽可能得一致。</p><p>刚刚说的grid cell是有ground truth的中心点落在里面的grid cell。没有ground truth中心点落入的grid cell，其预测出的两个bounding box就都被忽略了。</p><p>接下来的工作就是构建YOLOV1的损失函数。</p><h2 id="4-1-损失函数">4.1 损失函数</h2><p>损失函数包含5项：<br><img src="/images/yolo1_15.png" alt=""><br><img src="image-14.png" alt="alt text"></p><p>这5项都是残差平方和的回归问题的损失函数。因此YOLO是把目标检测问题当作了回归问题解决。</p><p>第一项是负责预测物体的bounding box<strong>中心点定位的误差</strong>，也就是负责预测物体的bounding box的横纵坐标要和ground truth的横纵坐标尽可能的一致。</p><p>第二项是负责预测物体的bounding box<strong>宽高定位的误差</strong>，也就是负责预测物体的bounding box的宽高要和ground truth的宽高尽可能的一致。加根号是为了使得小框对误差更敏感（也就是同样的偏差小框造成的损失更大，大框造成的损失更小）。</p><p>第三项是负责检测物体的bounding box的<strong>置信度误差</strong>。标签值是bounding box与ground truth的IoU，预测值即置信度。</p><p>第四项是<strong>不</strong>负责检测物体的bounding box的<strong>置信度误差</strong>。也就是所有被忽略的bounding box它们的置信度最好都为0，即标签值最好为0。不负责检测物体的bounding box包含两类：</p><ul><li>负责检测物体的grid cell中被忽略的bounding box</li><li>本身就不负责检测物体的grid cell预测出的bounding box</li></ul><p>第五项是负责检测物体的grid cell的<strong>分类误差</strong>。也就是ground truth的中心点落入的那个grid cell，它的20个类条件概率的最大值所对应的类别应与ground truth相同，并且这个概率越接近1越好。</p><p>前两项是<strong>坐标回归误差</strong>，第三、四项是<strong>置信度Confidence回归误差</strong>，最后一项是<strong>类别预测误差</strong>。</p><h1>声明</h1><p>本文是学习<a href="https://www.bilibili.com/video/BV15w411Z7LG/?spm_id_from=333.1245.0.0">【精读AI论文】YOLO V1目标检测，看我就够了</a>的记录，点击即可跳转视频链接。</p><p>注：本文图片来源于视频以及论文中，侵权联系删。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1. 目标检测综述&lt;/h1&gt;
&lt;p&gt;目标检测分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one-stage detector（单阶段模型）
&lt;ul&gt;
&lt;li&gt;代表有Yolo、SSD、Retina-net&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;two-stage detector</summary>
      
    
    
    
    <category term="Yolo" scheme="http://malone-ai.github.io/categories/Yolo/"/>
    
    
    <category term="深度学习" scheme="http://malone-ai.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Yolo" scheme="http://malone-ai.github.io/tags/Yolo/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 配置 MyBatis</title>
    <link href="http://malone-ai.github.io/2025/03/10/project-test4/"/>
    <id>http://malone-ai.github.io/2025/03/10/project-test4/</id>
    <published>2025-03-10T10:17:01.000Z</published>
    <updated>2025-03-14T17:00:38.494Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1AQAZeNEUJ/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】04. Springboot3整合MyBatis实现数据库操作</a>。</p><p>MyBatis 是一个持久层的框架，它可以连接数据库，实现数据库的增删查改。</p><h1>1. 创建数据库</h1><p><a href="https://malone-ai.github.io/2025/03/01/mysql1/">MySQL一：MySQL环境配置</a>。之前学习MySQL时的学习记录。</p><p>UP用的时Navicat，我用的是SQLyog</p><p>创建一个数据库，名称为code2025。<br>字符集选<code>utf8mb4</code>，排序规则选<code>utf8mb4_unicode_ci</code>。</p><p><img src="/images/project-test4_1.png" alt=""></p><p>新建一个表admin。另外注意，所有表的主键名称叫id，都是自动递增的，删除后无法再填充回去。比如删除id=2的数据，那么id=2就永远没有了。</p><p><img src="/images/project-test4_2.png" alt=""></p><p>还需要添加其他项，最终表如下：<br><img src="/images/project-test4_3.png" alt=""></p><p>找到表的DDL信息，复制下来：</p><p><img src="/images/project-test4_4.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `admin` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci COMMENT<span class="operator">=</span><span class="string">&#x27;管理员信息&#x27;</span></span><br></pre></td></tr></table></figure><p>这就是admin表的结构。</p><p>通过以下操作设置账号唯一：<br><img src="/images/project-test4_5.png" alt=""></p><p>向表中插入两条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+----------+---------+-------------+-----------------+</span><br><span class="line">| id | username | password | name    | phone       | email           |</span><br><span class="line">+----+----------+----------+---------+-------------+-----------------+</span><br><span class="line">|  1 | admin    | admin    | 管理员  | 13877886677 | admin@code.com  |</span><br><span class="line">|  2 | admin1   | admin1   | 管理员1 | 13877886678 | admin1@code.com |</span><br><span class="line">+----+----------+----------+---------+-------------+-----------------+</span><br></pre></td></tr></table></figure><h1>2. 添加工程依赖</h1><p><a href="https://mybatis.net.cn/index.html">MyBatis中文官网</a>。</p><p>在springboot工程下的pom.xml添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后点击：<br><img src="/images/project-test4_4.png" alt=""></p><p>即可加载新增的依赖。</p><p>在springboot工程下的src/main/resources/application.yml添加数据库配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 数据库配置</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: &#x27;123456&#x27;</span><br><span class="line">    url: jdbc:mysql://localhost:3306/code2025?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2b8</span><br></pre></td></tr></table></figure><p>其中username、password是自己设定的，url中3306/后的code2025是数据库的名称。</p><p>接着添加MyBatis配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 配置mybatis实体和xml映射</span><br><span class="line">mybatis:</span><br><span class="line">  # 映射xml</span><br><span class="line">  mapper-locations: classpath:mapper/*xml # classpath表示resources目录</span><br><span class="line">  configuration:</span><br><span class="line">    # 配置日志</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">    map-underscore-to-camel-case: true</span><br></pre></td></tr></table></figure><p>然后在resources目录下新建mapper目录。</p><h1>3. 添加实体类</h1><h2 id="3-1-新建Admin实体类">3.1 新建Admin实体类</h2><p>在springboot工程下的com.example里新建entity包（entity即实体类，它跟我们数据库的表所对应的一个java类，这个java类里面它的所有属性名字跟我们数据库表里面的属性名字是一致的），在这个包下再新建Admin实体类。</p><p>在这个Admin实体类里添加private属性，这些属性同前面我们创建的数据库中的表的属性一致，然后按住ALT+Insert快速添加setter和getter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id; <span class="comment">// 用Integer是因为可以允许null，但int不允许null</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-创建AdminMapper-xml文件">3.2 创建AdminMapper.xml文件</h2><p>在springboot工程下的src/main/resources/mapper目录下新建AdminMapper.xml文件，编辑内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.example.mapper.AdminMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.example.entity.Admin&quot;&gt;</span><br><span class="line">        select * from `admin` order by id desc</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/project-test4_7.png" alt=""></p><p>上面图中标注的部分对于mapper目录下的所有文件都是一样的。然后接下来的一行的namespace与接口层映射。</p><p>下载MyBatisX插件。</p><h2 id="3-3-创建AdminMapper接口">3.3 创建AdminMapper接口</h2><p>在springboot下的com.example下新建mapper包，再在这个包下创建AdminMapper接口。这个AdminMapper与前面创建的AdminMapper.xml对应。</p><p>在这个类下添加一个<code>selectAll</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdminMapper</span> &#123;</span><br><span class="line">    List&lt;Admin&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实对应于AdminMapper.xml文件中的<code>selectAll</code>，它提供了一个对外查询的接口。</p><p>这个接口是定义在mapper层，不能直接使用，得通过controller层来进行访问。</p><h2 id="3-4-在启动类中扫描mapper接口层">3.4 在启动类中扫描mapper接口层</h2><p>在springboot工程目录下的src/main/java/com/example/SpringbootApplication.java中添加<code>@MapperScan(&quot;com.example.mapper&quot;)</code>（这意为在主类中扫描mapper接口层）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-将接口从mapper传递到controller层">3.5 将接口从mapper传递到controller层</h2><p>在com.example.Service中的AdminService中添加方法<code>public List&lt;Admin&gt; selectAll</code>（先通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AdminMapper adminMapper;</span><br></pre></td></tr></table></figure><p>注入com/example/service/AdminService.java中的AdminService，便于通过它来调用mapper里的selectAll）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminMapper adminMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomerException</span>(<span class="string">&quot;账号错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Admin&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adminService.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在service层有了数据查询的方法。</p><p>接下来需要交给controller层使用。</p><p>在com.example.controller下新建AdminController类，并将这个类注册为controller（添加<code>@RestController</code>），通过<code>@Resource</code>将com.example.service下的AdminService注入，然后定义一个<strong>selectAll</strong>接口，并注册selectAll路由：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.example.controller.AdminController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/selectAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Admin&gt; admins = adminService.selectAll();</span><br><span class="line">        <span class="keyword">return</span> Result.success(admins);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面添加了<code>RequsetMapping(&quot;/admin&quot;)</code>是为了便于区分，为 它使得 AdminController 中的所有方法提供一个公共的 URL 前缀 /admin。</p><p>这样selectAll就被传递到了controller接口层，访问路径为<code>localhost:9999/admin/selectAll</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1AQAZeNEUJ/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>手撕线程池</title>
    <link href="http://malone-ai.github.io/2025/03/09/cpp-interview4/"/>
    <id>http://malone-ai.github.io/2025/03/09/cpp-interview4/</id>
    <published>2025-03-09T04:24:58.000Z</published>
    <updated>2025-03-10T08:37:12.484Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>学习一下线程池，主要参考Github代码仓库<a href="https://github.com/progschj/ThreadPool">https://github.com/progschj/ThreadPool</a></p><h1>1. 为什么需要线程池</h1><p>在多线程编程中，频繁创建和销毁线程会导致以下问题：</p><ul><li>资源开销大：线程创建需要分配栈空间、寄存器等资源。</li><li>调度开销高：操作系统频繁切换线程上下文。</li><li>管理复杂：线程数量过多时难以控制。</li></ul><p>因此引入线程池来解决这些问题。线程池的核心思想是<code>预先创建一组线程，通过任务队列管理待执行的任务。线程循环从队列中获取任务执行，避免频繁创建和销毁线程的开销</code>。</p><h1>2. 设计思想与关键机制</h1><ol><li>核心组件</li></ol><ul><li>任务队列（Task Queue）：存储待执行的任务（封装为std::function&lt;void()&gt;）。</li><li>工作线程（Workers）：多个线程循环从任务队列中获取任务。</li><li>同步机制：互斥锁（std::mutex）保护队列，条件变量（std::condition_variable）实现线程等待/唤醒。</li></ul><ol start="2"><li>工作流程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   [主线程]        |       [工作线程]</span><br><span class="line">      |            |            |</span><br><span class="line">提交任务到队列      |      等待任务到来</span><br><span class="line">      |            |            |</span><br><span class="line">  任务入队         |      从队列取任务</span><br><span class="line">      |            |            |</span><br><span class="line"> 唤醒工作线程       |      执行任务</span><br><span class="line">      |            |            |</span><br></pre></td></tr></table></figure><h1>3. 任务队列与enqueue函数</h1><h1>3.1 任务队列</h1><p>在实现线程池时，任务队列是核心组件之一。它的作用是存放待执行的任务，线程池中的工作线程会从队列中取出任务并执行。那么，什么是任务呢？</p><p>从编程的角度来看，任务本质上就是一个<code>函数</code>。</p><p>因此使用一个队列，并且队列存储的类型是函数，来组成任务队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt; std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br></pre></td></tr></table></figure><p>std::function是一个通用的函数封装器，其中的void代表没有返回值（或者返回值类型为void），圆括号表示没有参数。再比如<code>std::function&lt;int(int, int)&gt;</code>代表接收两个int类型参数并且返回值为int。</p><p>但是有一个问题？线程池需要支持<code>任意类型</code>的任务：</p><ul><li>可以是普通函数、类成员函数、Lambda表达式等</li><li>可以携带任意参数和返回值</li></ul><p>但为什么这里却使用了无参无返回值的<code>std::function&lt;void()&gt;</code>当作任务队列的成员的基本类型呢？</p><p>这看似矛盾的设计背后，实际上体现了<code>类型擦除</code>和<code>任务适配</code>的巧妙结合。</p><p>为了统一管理任务，必须将这些任务<code>适配</code>为一个统一的接口。std::function&lt;void()&gt;就是这个统一的接口。</p><ol><li>为什么选择void()？</li></ol><ul><li>最小接口：void()是最简单的函数签名，不涉及参数和返回值。</li><li>通用性：任何任务都可以通过<code>适配器</code>转换为void()类型。</li><li>执行与结果分离：线程池只负责<code>执行任务</code>，结果通过其他机制返回。</li></ul><ol start="2"><li>如何适配？<br>通过<code>任务包装器</code>将任意类型的任务转换为void()类型。具体来说：</li></ol><ul><li>使用std::bind绑定任务和参数，生成一个无参的可调用对象。</li><li>使用std::packaged_task将任务包装为void()类型，也就是没有返回值。如何获取返回值呢？使用该对象的get_future成员函数获取一个std::future对象，后续在调用这个对象的get成员函数即可。</li></ul><p>总的来说，就是为了方便管理才使用<code>std::function&lt;void()&gt;</code>当作任务队列的成员的基本类型，并且线程池只是执行这些任务，而任务的执行结果线程池并不在乎，使用其他办法来返回这个结果。</p><p>更具体的，我觉得应该结合成员函数enqueue来说明，</p><h1>3.2 成员函数enqueue</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用了C++11的模板（template&lt;class F, class… Args&gt;）和尾置返回类型（由<code>-&gt;</code>指明，<code>-&gt;</code>后即为返回值类型）。<code>F</code>是一个可调用对象的类型，<code>Args</code>是参数包的类型（<code>...</code>是 参数包展开的语法，用于处理可变模板参数）。<code>enqueue</code>函数的作用是将任务<code>f</code>和参数<code>args</code>打包成一个任务，放入线程池的任务队列中，并返回一个<code>std::future</code>以便获取任务执行的结果。</p><p>接下来，函数内部的第一行是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure><p>这里有几个关键点：</p><ol><li><p>std::result_of<br><code>std::result_of</code>是一个类型萃取工具（Type Trait），用于推导可调用对象（函数、Lambda、函数对象等）在给定参数类型下的返回类型。</p></li><li><p>typename<br><code>typename</code>在这里的作用是告诉编译器<code>std::result_of&lt;F(Args...)&gt;::type</code>是一个 类型，而不是一个静态成员变量或其他东西。这是C++模板编程中的一个常见语法规则，称为<code>依赖名称解析</code>。</p></li><li><p>using<br><code>using</code>在这里用于定义类型别名，类似于typedef。</p></li></ol><p>这里使用了<code>std::result_of</code>来推导调用<code>F</code>类型对象使用<code>Args...</code>参数后的返回类型。这行代码定义了<code>return_type</code>作为任务执行后的返回类型，用于后续的<code>std::packaged_task</code>和<code>std::future</code>的模板参数。</p><p>然后，创建了一个<code>std::packaged_task</code>对象，并将其包装在<code>std::shared_ptr</code>中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br></pre></td></tr></table></figure><p>它的核心目的是将用户提交的任务（可能带有参数和返回值）适配为线程池可以处理的统一形式（void()类型），同时保留任务的返回值以便异步获取。</p><p>这里有几个关键点：</p><ol><li>std::packaged_task</li></ol><p>std::packaged_task 是一个模板类，用于 包装一个可调用对象，并将其与一个 std::future 关联起来，从而支持 异步获取任务的返回值。它的核心功能包括：</p><ul><li>任务包装：将任意可调用对象（函数、Lambda、函数对象等）包装为一个可以延迟执行的任务。</li><li>结果关联：通过 get_future() 方法生成一个 std::future 对象，用于异步获取任务的返回值。</li></ul><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;)</span></span>;  <span class="comment">// 包装一个任务</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();         <span class="comment">// 获取 future</span></span><br><span class="line"><span class="built_in">task</span>();                                              <span class="comment">// 执行任务</span></span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;              <span class="comment">// 获取结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li>std::bind</li></ol><p><code>std::bind</code>用于将函数<code>f</code>和参数<code>args...</code>绑定在一起，生成一个新的可调用对象，它位于<code>&lt;functional&gt;</code>头文件中。<br>假设有一个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure><p>使用std::bind绑定参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_task = std::<span class="built_in">bind</span>(add, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>此时，bound_task是一个无参的可调用对象，调用bound_task()会返回5。</p><ol start="3"><li><p>完美转发<br><code>std::forward</code>用于保持参数的左值或右值属性，避免不必要的拷贝，实现完美转发。</p></li><li><p>std::make_shared<br>使用智能指针管理<code>std::packaged_task</code>的生命周期，确保任务在需要时不会被提前销毁。</p></li></ol><p>接下来获取<code>std::future</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure><p><code>std::packaged_task::get_future</code>返回一个与任务结果关联的<code>std::future</code>对象，通过它可以在未来某个时间点获取任务的返回值。</p><p>然后进入一个作用域块，锁定互斥量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(stop)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个关键点：</p><ol><li><p>互斥锁：使用<code>std::unique_lock</code>锁定互斥量，确保对任务队列的访问是线程安全的，当离开作用域时自动解锁。</p></li><li><p>停止检查：如果线程池已经停止（<code>stop</code>为<code>true</code>），则抛出异常，防止新任务被加入已停止的线程池。</p></li><li><p>任务入队：将任务包装成一个lambda表达式，并放入任务队列<code>tasks</code>中。lambda捕获了<code>task</code>的共享指针，当lambda被执行时，会调用<code>(*task)()</code>，即执行绑定的任务。</p></li></ol><p>之后，通知一个等待的线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure><p>通过条件变量<code>condition</code>的<code>notify_one</code>方法，唤醒一个正在等待的工作线程，让它从任务队列中取出并执行新加入的任务。</p><p>最后，返回之前获取的<code>std::future</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>用户可以通过这个<code>std::future</code>对象获取任务的执行结果，或者等待任务完成。</p><p>在整个过程中，需要注意的几个关键点：</p><ol><li><p><strong>完美转发</strong>：在<code>std::bind</code>中使用<code>std::forward</code>保持参数的值类别，确保无论是左值还是右值都能正确传递，避免不必要的拷贝。</p></li><li><p><strong>类型擦除</strong>：任务队列中的元素类型是<code>std::function&lt;void()&gt;</code>，而通过lambda表达式将具体的<code>std::packaged_task</code>包装成无参数、无返回值的函数，实现了类型擦除，使得不同类型的任务可以统一存储在同一个队列中。</p></li><li><p><strong>异常安全</strong>：在互斥锁的保护下检查<code>stop</code>标志，确保线程池停止后不再接受新任务，并且通过智能指针管理任务对象的生命周期，避免资源泄漏。</p></li><li><p><strong>异步结果处理</strong>：通过<code>std::packaged_task</code>和<code>std::future</code>的结合，实现了任务的异步执行和结果的获取，用户可以在适当的时候调用<code>future::get()</code>来等待任务完成并获取结果，或者检查任务是否完成。</p></li></ol><ul><li><strong><code>std::result_of</code>和<code>std::invoke_result</code>的区别？</strong></li></ul><p>C++17中<code>std::result_of</code>被废弃，改用<code>std::invoke_result</code>。但在C++11/14中，<code>std::result_of</code>是推导可调用对象返回类型的方式。其模板参数是一个函数类型，表示调用<code>F</code>类型对象使用<code>Args...</code>参数时的返回类型。</p><h1>4. 线程池的构造与析构</h1><h1>4.1 构造函数：工作线程的启动</h1><p>构造函数的核心任务是初始化线程池并启动指定数量的工作线程。</p><p>其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span></span></span><br><span class="line"><span class="function">    :   stop(false)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的基本流程：</p><ol><li>线程启动</li></ol><ul><li>循环创建 threads 个工作线程，每个线程执行一个 无限循环。</li><li>线程启动后立即进入等待状态（通过条件变量 condition）。</li></ul><ol start="2"><li>同步机制</li></ol><ul><li>条件变量等待：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure><ul><li>线程在以下两种情况下被唤醒：<ul><li>有新任务加入队列（tasks 非空）。</li><li>线程池被要求停止（stop == true）。</li></ul></li><li>当任务队列为空（tasks.empty()）且线程池未收到停止信号（stop == false）时，工作线程会进入阻塞状态，避免空转消耗 CPU 资源。</li><li><code>[this]&#123; return stop || !tasks.empty(); &#125;</code> 这个 Lambda 表达式是唤醒线程的条件判断</li><li>在调用 condition.wait() 时，锁会被自动释放，允许其他线程修改共享资源（例如添加任务或设置停止标志）。</li><li>当线程被唤醒时，会重新尝试获取锁，获取锁后继续操作，保证后续操作（如取任务 tasks.pop()）的线程安全</li><li>防止虚假唤醒<ul><li>条件变量的 wait() 方法可能因系统原因被虚假唤醒（即使条件未满足）。通过传入的 Lambda 表达式，线程在唤醒后必须重新检查条件，确保只有在条件真正满足时才会继续执行。</li></ul></li></ul><ol start="3"><li>任务执行流程：</li></ol><ul><li>从队列头部取出任务（tasks.front()），并通过 std::move 转移所有权。</li><li>在锁外执行任务（task()），避免长时间占用锁。</li></ul><h1>4.2 析构函数：安全关闭线程池</h1><p>析构函数负责停止线程池并等待所有工作线程退出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; worker : workers) &#123;</span><br><span class="line">        worker.<span class="built_in">join</span>();  <span class="comment">// 等待线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有如下关键点：</p><ol><li>停止信号</li></ol><ul><li>设置 stop = true，通知所有工作线程退出循环。</li><li>通过 condition.notify_all() 唤醒所有等待的线程。</li></ul><ol start="2"><li>线程回收：</li></ol><ul><li>使用 join() 等待所有线程自然退出，确保任务队列中的剩余任务被执行完毕。</li><li>析构函数的 异常安全：即使某个线程抛出异常，join() 仍能保证所有线程被正确回收。</li></ul><h1>5. 线程池的工作流程</h1><p>我个人感觉，线程池由多个线程组成，而多线程最重要的就是线程同步，因此同步机制就是线程池中核心中的核心。</p><p>主要解决的问题就是<code>多个线程对共享资源的安全访问</code>。这里的共享资源是任务队列。我们采用经典的<code>生产者-消费者模型</code>来解决这个问题：</p><ul><li>生产者（主线程）：通过enqueue添加任务</li><li>消费者（工作线程）：从队列获取任务执行</li></ul><h1>5.1 生产者-消费者模型</h1><p>其工作流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [生产者线程]                            [消费者线程]</span><br><span class="line">      |                                      |</span><br><span class="line">提交任务到队列                                |</span><br><span class="line">      |                                      |</span><br><span class="line">      |-- 任务入队 --&gt; [任务队列] --&gt; 任务出队 --|</span><br><span class="line">      |                                      |</span><br><span class="line">      |-- 唤醒消费者线程 ----------------------&gt;|</span><br><span class="line">      |                                      |</span><br><span class="line">      |                                执行任务</span><br></pre></td></tr></table></figure><h1>5.2 关键机制</h1><table><thead><tr><th>机制</th><th>作用</th></tr></thead><tbody><tr><td>互斥锁</td><td>保护任务队列的线程安全访问</td></tr><tr><td>条件变量</td><td>协调线程的等待与唤醒，避免忙等待</td></tr><tr><td>任务适配</td><td>将任意任务转换为统一接口（std::function&lt;void()&gt;）</td></tr><tr><td>异步结果反馈</td><td>通过 std::future 实现任务结果的异步获取</td></tr></tbody></table><h1>6. 完整代码</h1><p>完整代码可见代码仓库，这里也附上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>);</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// need to keep track of threads so we can join them</span></span><br><span class="line">    std::vector&lt; std::thread &gt; workers;</span><br><span class="line">    <span class="comment">// the task queue</span></span><br><span class="line">    std::queue&lt; std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronization</span></span><br><span class="line">    std::mutex queue_mutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span></span></span><br><span class="line"><span class="function">    :   stop(false)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">for</span>(std::thread &amp;worker: workers)</span><br><span class="line">        worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;学习一下线程池，主要参考Github代码仓库&lt;a href=&quot;https://github.com/progschj/ThreadPool&quot;&gt;https://github.com/progschj/ThreadPool&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;1. </summary>
      
    
    
    
    <category term="C/C++ 面试" scheme="http://malone-ai.github.io/categories/C-C-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
    <category term="线程池" scheme="http://malone-ai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>她的算法，我解不开</title>
    <link href="http://malone-ai.github.io/2025/03/09/my-feelings3/"/>
    <id>http://malone-ai.github.io/2025/03/09/my-feelings3/</id>
    <published>2025-03-09T03:42:35.000Z</published>
    <updated>2025-03-09T03:43:11.964Z</updated>
    
    
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>动态规划八：区间DP</title>
    <link href="http://malone-ai.github.io/2025/03/08/dp8/"/>
    <id>http://malone-ai.github.io/2025/03/08/dp8/</id>
    <published>2025-03-08T13:01:24.000Z</published>
    <updated>2025-03-08T16:47:22.407Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今日学习灵茶山艾府的<a href="https://www.bilibili.com/video/BV1Gs4y1E7EU/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">区间 DP：最长回文子序列【基础算法精讲 22】</a>。</p><p>前面的几个课程都是在数组的前缀或者后缀上转移的，这类DP叫做线性DP。</p><p>对于区间DP，会把问题规模缩小到数组中间的区间上，而不仅仅是前缀或者后置了。这是区间DP和线性DP的最大区别。</p><p>灵茶山艾府主要通过两道Leetcode题目<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列</a>和<a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/">1039. 多边形三角剖分的最低得分</a>来进行讲解。</p><h1>1. 最长回文子序列</h1><h1>1.1 题目描述</h1><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例 1：</p><pre><code>输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</code></pre><h1>1.2 基本思路</h1><h1>1.2.1 思路一</h1><p>由于回文子序列从左往右读和从右往左读都是一样的，所以可以求s和反转后的s的最长公共子序列，从而可以得到最长回文子序列的长度。</p><h1>1.2.2 思路二</h1><p>选或不选的思路来解决这道题。</p><p>只需要看第一个字母选或不选以及最后一个字母选或不选。</p><p><img src="/images/dp8_1.png" alt=""></p><p>定义dfs(i, j)表示从s[i]到s[j]的最长回文子序列的长度。</p><ul><li>如果s[i] == s[j]，那么就可以都选，i递归到i+1，j递归到j - 1。</li><li>如果s[i] != s[j]，那么要么不选s[i]，要么不选s[j]。</li></ul><p>那么状态转移方程：</p><pre><code>dfs(i, j) = dfs(i+1, j-1) + 2, s[i] == s[j]dfs(i, j) = max(dfs(i+1, j), dfs(i, j-1)), s[i] != s[j]</code></pre><p>如果递归到一个字母的时候，它一个字母也是一个回文子序列，所以返回1。如果没有字母就返回0</p><ul><li>递归边界<ul><li>dfs(i, i) = 1</li><li>dfs(i + 1, i) = 0</li></ul></li><li>递归入口<ul><li>dfs(0, n-1)</li></ul></li></ul><h1>1.3 具体实现</h1><h1>1.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = s[i] == s[j] ? <span class="built_in">dfs</span>(i<span class="number">+1</span>, j<span class="number">-1</span>) + <span class="number">2</span> : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">+1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.2 递推</h1><p>递归翻译成递推，需要注意一下循环顺序。</p><ul><li>由于f[i]从f[i+1]转移过来，所以i要<code>倒序</code>枚举。</li><li>由于f[i][j]从f[i][j-1]转移过来，所以i要<code>倒序</code>枚举。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    f[i][j] = f[i<span class="number">+1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            f[i%<span class="number">2</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    f[i%<span class="number">2</span>][j] = f[(i<span class="number">+1</span>)%<span class="number">2</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i%<span class="number">2</span>][j] = <span class="built_in">max</span>(f[(i<span class="number">+1</span>)%<span class="number">2</span>][j], f[i%<span class="number">2</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2. 多边形三角剖分的最低得分</h1><h1>2.1 题目描述</h1><p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。</p><p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p><p>返回 多边形进行三角剖分后可以得到的最低分 。</p><h1>2.2 基本思路</h1><p>数组values记为v。</p><p>定义<code>从i到j</code>表示沿着边从顶点i顺时针到顶点j的所有顶点（顶点i和顶点j除外），再加上直接从j到i的这条边所组成的多边形（三个顶点组成一个三角形）。</p><p><img src="/images/dp8_2.png" alt=""></p><p>子问题：</p><ul><li>计算从i到j的最低得分 =&gt; 枚举顶点k</li></ul><p>下一个子问题：</p><ul><li>计算从i到k的最低得分</li><li>计算从k到j的最低得分</li></ul><p>定义dfs(i, j)表示从i到j的多边形的最低得分</p><ul><li><p>dfs(i, j) = min{dfs(i, k) + dfs(k, j) + v[i] * v[j] * v[k]}, k = i + 1 ~ j - 1</p></li><li><p>递归边界</p><ul><li>dfs(i, i+1) = 0</li></ul></li><li><p>递归入口</p><ul><li>dfs(0, n-1)</li></ul></li></ul><h1>2.3 具体实现</h1><h1>2.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res = INT_MAX / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i, k) + <span class="built_in">dfs</span>(k, j) + values[i] * values[j] * values[k]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.2 递推</h1><p>状态转移方程为：</p><pre><code>f[i][j] = max&#123;f[i][k] + f[k][j] + v[i] * v[j] * v[k]&#125;, k = i + 1 ~ j - 1</code></pre><p>这里也需要注意循环顺序：</p><pre><code>i &lt; k，f[i]从f[k]转移过来，i需要倒序枚举j &gt; k, f[i][j]从f[i][k]转移过来，j需要正序枚举</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span>&amp; res = f[i][j];</span><br><span class="line">                res = INT_MAX / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, f[i][k] + f[k][j] + values[i] * values[j] * values[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>为什么 i 从 n-3 开始？</li></ul><ol><li><p>三角形的顶点要求</p><ul><li>要形成一个三角形，至少需要 3 个顶点。因此，i 和 j 之间至少要有 2 个顶点（即 j &gt;= i + 2）。</li><li>如果 i 从 n-1 或 n-2 开始，j 的范围会超出数组的边界，无法形成有效的三角形。</li></ul></li><li><p>边界条件</p><ul><li>当 i = n-3 时，j 可以从 i+2 = n-1 开始，这样 i、j 和中间的 k 可以形成一个有效的三角形。</li><li>如果 i 从 n-2 开始，j 只能从 n 开始，这已经超出了数组的边界。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;今日学习灵茶山艾府的&lt;a href=&quot;https://www.bilibili.com/video/BV1Gs4y1E7EU/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f4fa318d</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 项目框架搭建</title>
    <link href="http://malone-ai.github.io/2025/03/07/project-test3/"/>
    <id>http://malone-ai.github.io/2025/03/07/project-test3/</id>
    <published>2025-03-07T13:36:48.000Z</published>
    <updated>2025-03-11T15:46:40.951Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1uZAoeGEqM/?spm_id_from=333.1245.0.0">【带小白做毕设】03. Springboot3框架的快速搭建以及项目工程的讲解</a>并进行一个学习记录。</p><h1>1. 新建工程</h1><p>在idea新建一个工程（注意新建工程页面在左边生成器中选择springboot），工程名为springboot，存放工程的文件夹为存放vue工程的文件夹。语言选Java，类型选Maven，组填com.example，工件填springboot，软件包名称填com.example，jdk选jdk21，java选21，打包选jar。然后选择下一步。</p><p><img src="/images/project-test3_1.png" alt=""></p><p>然后springboot选3.4.3，依赖项中从Web中选择Spring Web，然后点击创建即可。springboot工程就创建完毕了。</p><p><img src="/images/project-test3_2.png" alt=""></p><h1>2. 工程精简</h1><h1>2.1 删除无用文件</h1><p><img src="/images/project-test3_3.png" alt=""></p><p>删除图中画红线的文件。把src/test文件夹、src/main/resources下的static和templates文件夹也删除了。</p><h1>2.2 配置Maven</h1><p>打开设置，直接搜索Maven，配置Maven主路径（也就是Maven的解压路径，我的解压路径为D:\ProgramFiles\apache-maven-3.9.9）。勾选两个重写，然后指定用户设置文件为Maven解压路径下的conf文件夹下的settings.xml。在Maven解压路径下创建repo文件夹，然后选择本地仓库为这个repo文件夹。然后点击确定即可。</p><p><img src="/images/project-test3_4.png" alt=""></p><h1>2.3 pom.xml 文件精简</h1><p>pom.xml文件定义了一些依赖。</p><p><img src="/images/project-test3_5.png" alt=""></p><p><img src="/images/project-test3_6.png" alt=""></p><p>把pom.xml中的上述内容（如上两幅图片所示）删除。</p><h1>2.3 工程目录分析</h1><pre><code>.idea —— idea软件的配置文件src —— 源码目录src/main/java/com/example/SpringbootApplication —— 工程的启动类（文件后缀为.java），main函数就定义在这里。src/main/resources/application.properties —— 整个springboot的配置文件，将其重命名为application.yml，方便编辑    将其编辑为：        server:          port: 9999    以重新设置转发端口号target文件夹 —— 源码编译后的文件pom.xml —— 定义了springboot工程所有的依赖项，springboot加载的时候会扫描这个文件里面所有的依赖项，然后下载</code></pre><h1>2.4 运行工程出现的问题</h1><h1>2.4.1 Error：java 错误 不支持发行版本 5</h1><p>参考链接<a href="https://blog.csdn.net/weixin_43553694/article/details/104118190">Spring项目 Error：java 错误 不支持发行版本 5 IDEA解决办法</a></p><p><img src="/images/project-test3_7.png" alt=""></p><p><img src="/images/project-test3_8.png" alt=""></p><h1>2.4.2 org.springframework.boot不存在</h1><p>参考链接<a href="https://blog.csdn.net/Asa_Prince/article/details/127986463">解决java: 程序包org.springframework.boot不存在的解决方法</a>。</p><p>以及</p><p>File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven -&gt; Runner -&gt; Delegate IDE build/run actions to Maven</p><h1>3. 重启工程</h1><p>关闭这个springboot工程，打开springboot工程和vue工程共存的工程目录。将springboot工程目录下的.idea删除。</p><h1>3.1 重新加载springboot依赖</h1><p>右键springboot工程目录下的pom.xml，选择最下面的添加为Maven项目。</p><p><img src="/images/project-test3_9.png" alt=""></p><h1>3.2 设置编码</h1><p>设置编码为UTF-8。</p><p><img src="/images/project-test3_10.png" alt=""></p><p>然后运行springboot工程，运行成功则配置成功。</p><h1>4. 写一个测试接口</h1><h1>4.1 接口层</h1><p>右键springboot工程下的src/main/java/com/example，选择新建 -&gt; 软件包<br><img src="/images/project-test3_11.png" alt=""></p><p>包名设为controller（controller是对外提供接口的包，在这个包里定义的所有文件，都是对外提供接口数据的，叫接口层controller）。</p><p>springboot一般会分为三层：</p><ul><li>controller<ul><li>提供数据接口</li></ul></li><li>service<ul><li>处理业务逻辑</li></ul></li><li>mapper<ul><li>对接数据库</li></ul></li></ul><p>在controller包里再创建一个WebController，此时它默认会有以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在public class WebController上新增一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br></pre></td></tr></table></figure><p>回车自动补全，会帮助把需要的包也导进来。</p><p>这个行为就是将这个类定义为一个controller。</p><p>在WebController类下写一个get接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键入<code>@GetMapping</code>时按回车自动补全，会自动导包。</p><p>在<code>@GetMapping</code>后键入<code>(&quot;/hello&quot;)</code>定义路由。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口定义的基本格式：</p><ul><li>@GetMapping 表示这是一个get请求接口</li><li>括号里的路径是路由（路由全局唯一）</li></ul><p>此时运行springboot工程在网址<code>localhost:9999/hello</code>下就可以看到&quot;Hello World&quot;。</p><h1>4.2 查看网络请求</h1><p>在网址<code>localhost:9999/hello</code>下按F12，然后：<br><img src="/images/project-test3_12.png" alt=""></p><p>一开始可能不显示，按F5刷新一下即可~</p><h1>4.3 定义接口统一返回的对象</h1><p>前面我们定义的接口返回值类型为String，但也可能是其他数据类型，每个接口返回的数据类型不一样就会造成混乱。为了防止混乱，可以定义一个对象，把我们实际需要返回的数据，包裹在这个对象里面，作为这个对象的一个属性。</p><p>在com.example下新建一个common包（即通用包）。在common下再新建一个Result类。在其中定义三个属性：</p><ul><li>private String code<ul><li>状态码（使用String更通用，既可以返回数字，也可以返回其他等等）</li></ul></li><li>private Object data<ul><li>我们实际返回的数据类型</li></ul></li><li>private String msg<ul><li>当请求错误时返回错误信息（如返回账号或者密码错误）</li></ul></li></ul><p>然后按ALT+Insert，会出现：<br><img src="/images/project-test3_13.png" alt=""></p><p>选择Getter和Setter，接着出现：<br><img src="/images/project-test3_14.png" alt=""></p><p>全选后确定，这样就设置了上述三个private属性的setter和getter方法。</p><p>以上就是Result包装类。</p><h1>4.4 如何使用Result包装类</h1><p>如果我们想在Web类中统一返回这个Result包装类该如何做？</p><p>原来的接口返回的是String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在应该返回一个Result类，并且应该在函数中new一个Result的对象，并调用3.5中定义的setter方法设置这个类的三个属性后返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;200&quot;</span>);</span><br><span class="line">    result.setData(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在修改返回值类型为Result的时候一定要选择com.example.common里的Result类，选它会帮我们自动导包：<br><img src="/images/project-test3_15.png" alt=""></p><p>此时再访问网址<code>localhost:9999/hello</code>：<br><img src="/images/project-test3_16.png" alt=""></p><p>这里的msg为null，也就是为空，因为没有错误消息。</p><p>在前端与后端数据交互的时候，如果拿到消息后判断状态码是否为200，为200则说明请求成功，错误消息就应该为null。如果状态码不为200，说明请求失败，并获取msg来打印错误消息。</p><p>总结一下就是，对于Result包装类：</p><ul><li>code 作为前端判断请求是否成功的依据</li><li>msg 是错误信息</li><li>data 是返回给前端的数据</li></ul><h1>4.5 优化Result包装类</h1><p>如果我们每次写一个接口，都new一个Result类，然后再调用setter方法去设置成员属性，有点繁琐。</p><p>有没有更简单的方法？那就是在Result里写一个静态方法，接收一个参数为Object data：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;200&quot;</span>);</span><br><span class="line">    result.setData(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那使用这样一个静态方法有什么好处呢？就是简化了接口中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是成功的情况，如果是失败的情况呢？那就定义一个error静态方法，此时因为请求失败所有就没有数据了，接收的参数就从Object data变成了String msg（错误消息），并且在方法中将状态码code设置为500：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;500&quot;</span>);</span><br><span class="line">    result.setMsg(msg);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想自定义code呢？那就重载error静态方法，再额外接收一个String code参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String code, String msg)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(code);</span><br><span class="line">    result.setMsg(msg);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5. 异常处理</h1><h1>5.1 500错误</h1><p>如果在定义接口函数hello的时候：<br><img src="/images/project-test3_17.png" alt=""></p><p>也就是主动去引出一个除0异常，但是这里并没有报错，并且编译也能通过，这个就叫<code>运行时异常</code>，只有在运行时才会发现异常。此时运行springboot工程，访问这个接口会发现：<br><img src="/images/project-test3_18.png" alt=""></p><p>也就是抛出了500错误。</p><p>抛出这些错误非常的用户不友好，我们应该用统一的处理方式（用Result包装类处理）。</p><p>Result怎么去处理它呢？我们可以定义一个全局异常处理GlobalExceptionHandler。在com.example里新建一个包exception，再在这个包里创建GlobalExceptionHandler类。这个类就是全局异常捕获器，它负责把代码里的错误进行捕获，并统一通过Result类返回。</p><p>在public class GlobalExceptionHandler上面一行添加<code>@ControllerAdvice</code>，依然是回车自动补全（这样自动导包）。然后还要提供Controller类的路径，<code>@ControllerAdvice(&quot;com.example.controller&quot;)</code>。</p><p>在GlobalExceptionHandler类内部键入<code>@ExceptionHandler</code>（回车自动补全自动导包），然后圆括号键入Exception.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br></pre></td></tr></table></figure><p>这里的Exception就是Java中所有异常的基类。</p><p>然后换行键入<code>@ResponseBody</code>，@ResponseBody的作用其实是将java对象转为json格式的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br></pre></td></tr></table></figure><p>然后接着换行写error方法，返回值为Result对象，接收一个参数Exception e。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再运行springboot项目，访问接口：<br><img src="/images/project-test3_19.png" alt=""></p><p>就不会在返回500错误了。</p><p>出现异常了看控制台，跳转到出错的代码进行debug。</p><p>也可以使用一个log在控制台打印错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比原来新增两行代码，一个是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br></pre></td></tr></table></figure><p>还有一行是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br></pre></td></tr></table></figure><p>此时运行工程并访问接口，在控制台：<br><img src="/images/project-test3_20.png" alt=""></p><h1>5.2 自定义异常</h1><p>什么是自定义异常呢？比如前端传了一个账号密码过来，但是账号或者密码错了，怎么告诉前端账号或者密码错了呢？假设它在service层，而不是在controller层。</p><p>也就是在service往外抛出错误。不能直接return一个Result对象，因为Result对象是在controller层进行封装的。</p><p>其实就是不在controller层时，如何抛出错误？</p><p>这里就展示如何验证管理员页面也就是admin路由下登陆的账户名是否为&quot;admin&quot;。</p><p>在com.example新建一个service包，再在这个包下创建AdminService类。然后给AdminServie加Servie注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把这个AdminService类注册为了Springboot的一个bean。</p><p>然后在这个类中添加admin方法，接收一个String name参数的方法，如果name与&quot;admin&quot;相等就返回&quot;admin&quot;（也就是admin接口只接受&quot;admin&quot;账号），其他返回错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里先留着</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们到com/example/controller/WebController.java中写一个admin接口，并给这个接口传一个参数String name。这个时候我们需要去访问service中的方法。先通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AdminService adminService;</span><br></pre></td></tr></table></figure><p>注入这个service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在admin接口中通过这个adminService调用它的admin方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/admin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">admin</span> <span class="operator">=</span> adminService.admin(name);</span><br><span class="line">        <span class="keyword">return</span> Result.success(admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前端调用admin接口传来一个name，当name等于&quot;admin&quot;时，返回&quot;admin&quot;；当不等于&quot;admin&quot;的时候返回错误。</p><p>不能在AdminService中的admin方法中直接返回&quot;账号错误&quot;，因为这个admin方法是通过admin接口调用的，这个&quot;账号错误&quot;返回后被admin接收，然后又通过<code>Result.success(admin)</code>返回，但此时状态码code还是200（请求成功）。</p><p>那么该如何返回错误呢？考虑自定义异常。</p><p>在com/example/exception类中新建一个CustomerException类，然后让这个类继承RuntimeException类（Java通过extends继承）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给这个类添加两个private属性，String code 和 String msg，也就是错误状态码和错误信息。继续利用ALT+Insert来快速实现他们的getter和setter方法以及构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">(String code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = <span class="string">&quot;500&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以完善AdminService类里的admin方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomerException</span>(<span class="string">&quot;账号错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在全局捕获器中捕获我们的自定义异常（原来只捕获Exception基类异常）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/example/exception/GlobalExceptionHandler.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(CustomerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">customerError</span><span class="params">(CustomerException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;自定义错误&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(), e.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中customerError中一定要把CustomerException对象e中包含的msg通过getMsg拿出来。</p><p>现在访问<code>localhost:9999/admin?name=1111</code>，其中<code>?name=1111</code>就是传递参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1uZAoeGEqM/?spm_id_from=333.1245.0.0&quot;&gt;【带小白做毕设】03. Springboot3框架的快速</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>动态规划七：状态机DP</title>
    <link href="http://malone-ai.github.io/2025/03/06/dp7/"/>
    <id>http://malone-ai.github.io/2025/03/06/dp7/</id>
    <published>2025-03-06T12:12:25.000Z</published>
    <updated>2025-03-10T07:24:37.815Z</updated>
    
    <content type="html"><![CDATA[<p>今日学习灵茶山艾府的<a href="https://www.bilibili.com/video/BV1ho4y1W7QK/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">买卖股票的最佳时机【基础算法精讲 21】</a>。</p><h1>1. 买卖股票的最佳时机 II</h1><p>Leetcode 官方题目<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a>。</p><h1>1.1 题目描述</h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p>示例 1：</p><pre><code>输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。最大总利润为 4 + 3 = 7 。</code></pre><p>示例 2：</p><pre><code>输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。最大总利润为 4 。</code></pre><p>示例 3：</p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</code></pre><h1>1.2 思路</h1><p><code>启发思路</code>：最后一天发生了什么？</p><p>对于 prices = [7,1,5,3,6,4]</p><pre><code>从第0天开始到第5天结束时的利润= 从第0天开始到第4天结束时的利润 + 第5天的利润= 。。。</code></pre><p>如果第5天什么也没做，那么利润是0。如果买入4块钱的股票，那么利润是-4。如果4块钱卖掉股票，那么利润是4（即赚了4块钱，但是这里说的赚了4块钱没有考虑买入股票花的钱）。假如第5天卖掉的股票是花6块钱买入的，那么这个利润-6需要算在第0天开始到第4天结束时的利润里面。</p><p>那么第i天我们可以做哪些事儿呢？看这张图：<br><img src="/images/dp7_1.png" alt=""></p><ul><li>什么也不做<ul><li>状态不变</li></ul></li><li>买入股票<ul><li>那么就从第i-1天未持有股票的状态，变成第i天结束时持有股票的状态</li></ul></li><li>卖出股票<ul><li>那么就从第i-1天持有股票的状态，变成第i天结束时未持有股票的状态</li></ul></li></ul><p>从图中可以看出状态转移一共有四种状态，其中持有股票或者未持有股票时，既不买入也不卖出是两种状态。</p><ul><li>定义 dfs(i,0)表示到第i天结束时，未持有股票，最大利润</li><li>定义 dfs(i,1)表示到第i天结束时，持有股票，最大利润</li></ul><p>（这里的参数0/1是一个bool类型的值。）</p><p>由于第i-1天的结束就是第i天的开始dfs(i-1,·)也表示到第i天开始时的最大利润。</p><p>继而可以得到以下图：<br><img src="/images/dp7_2.png" alt=""></p><p>从每个状态可以转移到其他状态，将这些其他状态取最大值就可以得到：</p><pre><code>dfs(i, 0) = max(dfs(i-1, 0) + dfs(i-1, 1) - prices[i])dfs(i, 1) = max(dfs(i-1, 1) + dfs(i-1, 0) + prices[i])</code></pre><p>递归边界：</p><pre><code>dfs(-1, 0) = 0  第0天`开始时`未持有股票，利润为0dfs(-1, 1) = 0  第0天`开始时`不可能持有股票</code></pre><p>递归入口：</p><pre><code>max(dfs(n-1, 0), dfs(n-1, 1))= dfs(n-1, 0)</code></pre><p>看上去枚举最后一天是否持有股票就可以了，但是如果最后一天结束时还持有股票，这个股票在后面就卖不出去了（或者说不在题目考虑的范围内）。所以dfs(n-1, 1)是不会比dfs(n-1, 0)大的，故从dfs(n-1, 0)开始递归即可。</p><h1>1.3 具体实现</h1><h1>1.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = j == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.2 递推 空间复杂度O(n)</h1><p>递归很容易翻译成递推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.3 递推 空间复杂度O(1) 两个数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(1) 两个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[(i + <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i % <span class="number">2</span>][<span class="number">0</span>], f[i % <span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[(i + <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i % <span class="number">2</span>][<span class="number">1</span>], f[i % <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.4 递推 空间复杂度O(1) 不用数组</h1><p>这种貌似难想，但其实画个图再对照一下两个数组的代码就很容易想到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(1) 不用数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f1 = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> f0_tmp = f0;</span><br><span class="line">            f0 = <span class="built_in">max</span>(f0, f1 + prices[i]);</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1, f0_tmp - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4 变形题目：309. 买卖股票的最佳时机含冷冻期</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期</a>。</p><h1>1.4.1 题目描述</h1><p>给定一个整数数组prices，其中 prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><pre><code>输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><p>示例 2:</p><pre><code>输入: prices = [1]输出: 0</code></pre><h1>1.4.2 思路</h1><p>这道题有冷冻期，就是在卖出后不能立刻买入股票。换句话就是买入股票的时候，前一天不能有卖出操作。这其实和和<a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍</a>很像。在打家劫舍中，从右往左思考，如果选第i个房子，那么第i-1个房子不能选，所以直接递归到第i-2个房子。</p><p>这道题也是一样的。<br>状态转移：</p><ul><li>如果今天不持有股票，那么有两种可能：<ul><li>前一天也不持有股票，今天什么都不做。</li><li>前一天持有股票，今天卖出股票。</li><li>因此，状态转移方程为：dfs(i, 0) = max(dfs(i-1, 0), dfs(i-1, 1) + prices[i])</li></ul></li><li>如果今天持有股票，那么有两种可能：<ul><li>前一天也持有股票，今天什么都不做。</li><li>前两天不持有股票，今天买入股票（因为有冷冻期，所以不能在前一天卖出后立即买入）。</li><li>因此，状态转移方程为：dfs(i, 1) = max(dfs(i-1, 1), dfs(i-2, 0) - prices[i])</li></ul></li></ul><p>当hold为1的时候，当前状态是持有股票。那这个状态可以来自两种情况：要么在i-1天已经持有，继续持有；要么在第i天买入。但买入的话，必须满足之前处于未持有状态，并且没有在i-1天卖出。因为如果有卖出的话，i天不能买入。</p><p>所以，当在第i天买入的话，那么必须保证i-1天处于冷却期，也就是i-1天没有操作。那么i-1天不操作的情况下，说明i-2天的时候可能已经卖出了，这样i-1天是冷却期，i天就可以买入。这就是为什么递归到i-2天的原因。</p><h1>1.4.3 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = j == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-2</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4.4 递推 空间复杂度 O(n)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度 O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i<span class="number">+2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][<span class="number">0</span>], f[i<span class="number">+1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i<span class="number">+2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4.5 递推 空间复杂度 O(1)</h1><p>这个空间复杂度为O(1)的是真想不明白😂。</p><p>现在是3.10，今天复习把这个想出来了，还得是画图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f2 = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> f1_tmp = f1;</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1, f2 + prices[i]);</span><br><span class="line">            f2 = <span class="built_in">max</span>(f2, f0 - prices[i]);</span><br><span class="line">            f0 = f1_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2. 买卖股票的最佳时机 IV</h1><p>Leetcode 官方题目<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV</a>。</p><h1>2.1 题目描述</h1><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1：</p><pre><code>输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</code></pre><p>示例 2：</p><pre><code>输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</code></pre><h1>2.2 基本思路</h1><p>定义 dfs(i,j,0) 表示到第 i 天<code>结束</code>时完成<code>至多</code> j 笔交易，未持有股票的最大利润。<br>定义 dfs(i,j,1) 表示到第 i 天<code>结束</code>时完成<code>至多</code> j 笔交易，持有股票的最大利润。</p><p>状态转移图如下图：</p><p><img src="/images/dp7_3.jpg" alt=""></p><p>既然有次数限制，就应当在递归过程中记录次数。所以在无限次交易的基础上增加一个参数j，表示<code>至多</code>完成j笔交易。转移方程需要修改的地方就是在买入或者卖出的地方把交易次数减1，如果买入减1，后面卖出的时候就不用减1。</p><pre><code>dfs(i,j,0) = max(dfs(i-1,j,0), dfs(i-1,j,1) + prices[i])dfs(i,j,1) = max(dfs(i-1,j,1), dfs(i-1,j-1,0) - prices[i])</code></pre><p>递归边界：</p><pre><code>dfs(·, -1, ·) = -∞, 任何情况下，j都不能为负dfs(-1, j, 0) = 0, 第 0 天开始未持有股票，利润为 0dfs(-1, j, 1) = -∞，第 0 天开始不可能持有股票</code></pre><h1>2.3 具体实现</h1><h1>2.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">memo</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>)));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> l)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> l == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j][l];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = l == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.2 递推 空间复杂度O(n*k)</h1><ul><li><p>为什么第二维度的大小是 k+2？</p><ul><li>在记忆化搜索中，j 的范围是 [−1,k]，这一共有 k+2 个数。1:1 翻译成递推就需要 k+2 的数组大小。</li></ul></li><li><p>f 数组中的 j=0 表示什么意思？</p><ul><li>这对应着记忆化搜索中的 j=−1 的状态，也就是交易 −1 次的状态。注意这是不合法的，所以初始值一定是 −∞。</li></ul></li><li><p>f 的初始值怎么确定？</p><ul><li>f 的初始值来自记忆化搜索的递归边界，递归边界怎么写，初始值就怎么写。</li></ul></li></ul><p>作者：灵茶山艾府<br>链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(n*k)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN / <span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j)</span><br><span class="line">            f[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">0</span>], f[i][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                f[i<span class="number">+1</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">1</span>], f[i][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][k<span class="number">+1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.3 递推 空间复杂度O(k)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(k)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN / <span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j)</span><br><span class="line">            f[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i%<span class="number">2</span>][j][<span class="number">0</span>], f[i%<span class="number">2</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i%<span class="number">2</span>][j][<span class="number">1</span>], f[i%<span class="number">2</span>][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][k<span class="number">+1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日学习灵茶山艾府的&lt;a href=&quot;https://www.bilibili.com/video/BV1ho4y1W7QK/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a&quot;&gt;</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>总结一下最近</title>
    <link href="http://malone-ai.github.io/2025/03/06/my-feelings2/"/>
    <id>http://malone-ai.github.io/2025/03/06/my-feelings2/</id>
    <published>2025-03-06T10:01:04.000Z</published>
    <updated>2025-03-06T12:28:59.197Z</updated>
    
    <content type="html"><![CDATA[<p>回顾一下最近的一个月。2.6号还在家，天天刷着leetcode，看看github上的一些源码，偶尔自己写写，再有空写写博客。</p><p>2.13准备返校，但是突发了一些意外，请假了，最后放了同学鸽子（本来说好一起返校的），不过好在返校后请人家吃了一顿，应该也消气了。</p><p>2.24开始返校，返校后一直在修改简历，想要投递个实习。基本上每天都在学C++的一些新特性以及一些八股文相关，然后刷刷leetcode，写写博客。</p><p>中间甚至在学java和前端🤣。java不难，因为两年前学过，并且java的很多语法与C++类似，只不过java也有很多高级的特性，比如垃圾回收机制等等，当时一度感觉就是因为java的垃圾回收机制，C++才会有智能指针。前端主要是vue3，感觉它比html要强大太多了。</p><p>还有就是，目前写的不少博客，内容基本上是B站上视频的学习的记录或者学习其他的博客，然后进行一个整理。整理和记录视频是因为看视频来进行复习回顾确实费时费力不讨好。整理其他人的博客也是一个很费时的事，说他是造轮子感觉太高大上了，说是搬运工感觉更合适。不过不可否认自己学到了很多东西。</p><p>目前的想法是，对于其他人博客的学习，只提出转载声明然后提供跳转链接，不做过多的整理。但是貌似也不是一件容易的事儿，最怕的还是版权问题。自己消化理解后再撰写博客和那完全是两码事儿。目前没有更好的解决方案了😵。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回顾一下最近的一个月。2.6号还在家，天天刷着leetcode，看看github上的一些源码，偶尔自己写写，再有空写写博客。&lt;/p&gt;
&lt;p&gt;2.13准备返校，但是突发了一些意外，请假了，最后放了同学鸽子（本来说好一起返校的），不过好在返校后请人家吃了一顿，应该也消气了。&lt;/</summary>
      
    
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>CMake 保姆级教程[转载]</title>
    <link href="http://malone-ai.github.io/2025/03/06/chores3/"/>
    <id>http://malone-ai.github.io/2025/03/06/chores3/</id>
    <published>2025-03-06T05:48:34.000Z</published>
    <updated>2025-03-06T05:51:01.455Z</updated>
    
    <content type="html"><![CDATA[<p>提供一下一个优秀的个人博客网站中写的CMake教程的跳转链接（侵权删）：</p><ul><li><a href="https://subingwen.cn/cmake/CMake-primer/">CMake 保姆级教程（上）</a></li><li><a href="https://subingwen.cn/cmake/CMake-advanced/">CMake 保姆级教程（下）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提供一下一个优秀的个人博客网站中写的CMake教程的跳转链接（侵权删）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://subingwen.cn/cmake/CMake-primer/&quot;&gt;CMake 保姆级教程（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
    <category term="CMake" scheme="http://malone-ai.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>GDB 调试</title>
    <link href="http://malone-ai.github.io/2025/03/06/chores2/"/>
    <id>http://malone-ai.github.io/2025/03/06/chores2/</id>
    <published>2025-03-06T03:16:07.000Z</published>
    <updated>2025-03-06T05:24:08.695Z</updated>
    
    <content type="html"><![CDATA[<p>GDB是Linux下非常好用且强大的调试工具。GDB可以调试C、C++等多种语言。</p><h1>1. 判断文件是否带有调试信息</h1><p>C/C++的编译文件有两种版本：</p><ul><li>release版本</li><li>debug版本</li></ul><p>gcc和g++默认编译生成的是release版本，release版本不带有调试信息，通常体积更小。</p><p>而如果在编译时带上&quot;-g&quot;参数，那么编译生成的就是debug版本。debug版本带有调试信息，体积通常会更大。</p><p>如果你想对一个C/C++的编译文件进行调试，那么它必须是debug版本，也就是编译时带了&quot;-g&quot;参数，带有调试信息的二进制可执行文件。</p><p>有一个编译好的二进制文件，你不确定是不是debug版本，是否带有调试信息，有两种方法可以确定。</p><ol><li>使用 gdb 命令</li></ol><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行gdb test命令后，如果其不是debug版本，不带有调试信息，那么就会显示：</p><pre><code>Reading symbols from test...(No debugging symbols found in test)</code></pre><p>（当然还有其他的一些信息会显示，如gdb版本等等。）</p><ul><li>带有调试信息（debug）</li></ul><p>如果带有调试信息，是debug版本，那么会显示：</p><pre><code>Reading symbols from test...</code></pre><p>也就是比不带有调试信息的少一行<code>(No debugging symbols found in test)</code>提示。</p><ol start="2"><li>使用 readelf 命令</li></ol><p>还可以使用命令readlef查看可执行文件是否带有调试功能。</p><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果其不是debug版本，不带有调试信息，那么不会显示任何内容。</p><ul><li>带有调试信息（debug）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果是debug版本，带有调试信息，那么类似于以下的内容：</p><pre><code>[28] .debug_aranges    PROGBITS         0000000000000000  0000303b[29] .debug_info       PROGBITS         0000000000000000  0000306b[30] .debug_abbrev     PROGBITS         0000000000000000  00005429[31] .debug_line       PROGBITS         0000000000000000  000059df[32] .debug_str        PROGBITS         0000000000000000  00005b41[33] .debug_line_str   PROGBITS         0000000000000000  00006cfb</code></pre><p>总之带调试信息的会显示内容，不带调试信息的不显示任何内容。</p><h1>2. GDB 命令汇总</h1><table><thead><tr><th>指令</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td><code>l</code></td><td><code>list</code></td><td>显示对应的代码，每次10行。可以指定行号或函数名。</td></tr><tr><td><code>r</code></td><td><code>run</code></td><td>无断点直接运行到底，有断点就运行到下一个断点然后停止。</td></tr><tr><td><code>b</code></td><td><code>breakpoint</code></td><td>在指定行号或函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:函数名</code></td><td><code>breakpoint</code></td><td>在该函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:行号</code></td><td><code>breakpoint</code></td><td>在该源文件中的指定行号打上断点。</td></tr><tr><td><code>info b</code></td><td><code>info breakpoints</code></td><td>查看断点的信息。</td></tr><tr><td><code>d</code></td><td><code>delete</code></td><td>删除指定编号的断点。</td></tr><tr><td><code>d breakpoints</code></td><td><code>delete breakpoints</code></td><td>删除所有的断点。</td></tr><tr><td><code>disable b</code></td><td><code>disable breakpoints</code></td><td>使所有断点无效。</td></tr><tr><td><code>disable b 编号</code></td><td><code>disable breakpoint</code></td><td>使指定编号的断点无效。</td></tr><tr><td><code>enable b</code></td><td><code>enable breakpoints</code></td><td>使所有断点有效。</td></tr><tr><td><code>enable b 编号</code></td><td><code>enable breakpoint</code></td><td>使指定编号的断点有效。</td></tr><tr><td><code>n</code></td><td><code>next</code></td><td>逐过程。</td></tr><tr><td><code>s</code></td><td><code>step</code></td><td>单步调试。</td></tr><tr><td><code>bt</code></td><td><code>backtrace</code></td><td>查看函数调用。</td></tr><tr><td><code>set var</code></td><td><code>set variable</code></td><td>修改变量的值。</td></tr><tr><td><code>p</code></td><td><code>print</code></td><td>打印变量的值。</td></tr><tr><td><code>display</code></td><td><code>display</code></td><td>追踪变量，每次停下来都显示它的值。</td></tr><tr><td><code>undisplay</code></td><td><code>undisplay</code></td><td>取消追踪。</td></tr><tr><td><code>until</code></td><td><code>until</code></td><td>继续执行，直至下一个断点处停止。</td></tr><tr><td><code>finish</code></td><td><code>finish</code></td><td>单步跳出，执行完当前所在函数后停止。</td></tr><tr><td><code>c</code></td><td><code>continue</code></td><td>从一个断点处，直接运行至下一个断点处。</td></tr></tbody></table><h1>3. GDB调试实践</h1><h2 id="3-1-编译出debug版本的二进制可执行文件">3.1 编译出debug版本的二进制可执行文件</h2><p>以下是将要用于调试的C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，用于计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，用于演示指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pointerDemo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *ptr = <span class="number">100</span>; <span class="comment">// 修改指针指向的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">factorial</span>(num); <span class="comment">// 计算阶乘</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Factorial of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;value;</span><br><span class="line">    <span class="built_in">pointerDemo</span>(ptr); <span class="comment">// 演示指针操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value after pointerDemo: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个简单的循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Loop iteration: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态内存分配</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放动态内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> test.cpp -g</span><br></pre></td></tr></table></figure><p>进行编译可得带调试信息的二进制可执行文件test。</p><h2 id="3-2-启动GDB">3.2 启动GDB</h2><p>可以使用gdb [要调试的二进制可执行文件名称]如gdb test来启动gdb调试，此时会进入gdb的命令行。也可以直接输入gdb回车进入gdb命令行后输入file test后回车来调试test。</p><h2 id="3-3-部分命令详解">3.3 部分命令详解</h2><h3 id="3-3-1-list">3.3.1 list</h3><p>简写为l（小写L），输入后便会展示10行代码，第一次使用会随机展示连续的10行代码。</p><p>如果输入<code>l [函数名]</code>，那么就会展示函数名所在的上面5行和包括函数名所在行在内的下面5行，至少10行。</p><p>如果输入<code>l [行号]</code>，那么就会展示那行代码所在的上面5行和包括那行行在内的下面5行，至少10行。</p><p>如果继续按住<code>Enter</code>，那么会展示接下来的几行代码。因为gdb会自动记忆你上次敲入的指令。</p><h3 id="3-3-2-breakpoint（插入断点）">3.3.2 breakpoint（插入断点）</h3><p>简写为b。</p><pre><code>b 行号 —— 在那一行打断点</code></pre><p>如<code>b 20</code>就是在第20行打上断点。</p><pre><code>b 源文件：函数名 —— 在该函数的第一行打上断点</code></pre><p>如<code>b test.cpp: main</code>就是在源文件的该函数的第一行打上断点。</p><pre><code>b 源文件：行号 —— 在该源文件中的这行加上一个断点</code></pre><p>如<code>b test.cpp: 20</code>就是在源文件的第20行打上断点。</p><h3 id="3-3-3-info">3.3.3 info</h3><p>直接执行info命令，就会显示所有的调试信息。</p><pre><code>info b —— 查看断点的信息</code></pre><p>info b会展示以下信息：</p><pre><code>Num —— 编号Type —— 类型Disp —— 状态Enb —— 是否可用Address —— 地址What —— 在此文件的哪个函数以及此文件的第几行</code></pre><h3 id="3-3-4-删除断点">3.3.4 删除断点</h3><pre><code>d 编号 —— 删除此编号的断点d —— 删除所有断点</code></pre><h3 id="3-3-5-开启-禁用断点">3.3.5 开启/禁用断点</h3><pre><code>disable b —— 使所有断点无效disable b 编号 —— 使此编号的断点无效enable b —— 使所有断点有效enable b 编号 —— 使此编号的断点有效</code></pre><h3 id="3-3-6-run">3.3.6 run</h3><p>简写为r，无断点直接运行到底，有断点就运行到下一个断点然后停止。</p><h3 id="3-3-7-逐过程-和-单步调试">3.3.7 逐过程 和 单步调试</h3><p>next简写为n，为逐过程，会一行一行地执行源文件中的代码。</p><p>step简写为s，为单步调试，也是一行一行地执行源文件中的代码，不同的是，它还会跳转库函数的代码。</p><h3 id="3-3-8-打印-和-追踪">3.3.8 打印 和 追踪</h3><p>print简写为p，为打印</p><pre><code>p 变量名 —— 打印变量值</code></pre><p>display，为追踪</p><pre><code>display 变量名 —— 追踪查看一个变量，每次停下来都显示它的值</code></pre><p>undisplay为取消追踪</p><pre><code>undisplay + 变量名编号 —— 取消对该编号变量的跟踪</code></pre><h3 id="3-3-9-bt">3.3.9 bt</h3><p>bt命令用于查看当前调用了哪些函数。</p><h3 id="3-3-10-修改变量的值">3.3.10 修改变量的值</h3><pre><code>set var —— 修改变量的值</code></pre><p>如<code>set var i = 0</code>就是将变量i的值设为0。</p><h3 id="3-3-11-until">3.3.11 until</h3><pre><code>until 行号 —— 继续执行当前代码，直到执行到该行号为止。</code></pre><h3 id="3-3-12-finish">3.3.12 finish</h3><pre><code>finish —— 执行完当前所在函数后停止。</code></pre><p>finish应该就是单步跳出了。</p><h3 id="3-3-13-continue">3.3.13 continue</h3><p>简写为c。</p><pre><code>c —— 继续执行，直至下一个断点处停止。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GDB是Linux下非常好用且强大的调试工具。GDB可以调试C、C++等多种语言。&lt;/p&gt;
&lt;h1&gt;1. 判断文件是否带有调试信息&lt;/h1&gt;
&lt;p&gt;C/C++的编译文件有两种版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;release版本&lt;/li&gt;
&lt;li&gt;debug版本&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>左值引用 与 右值引用</title>
    <link href="http://malone-ai.github.io/2025/03/05/cpp-interview3/"/>
    <id>http://malone-ai.github.io/2025/03/05/cpp-interview3/</id>
    <published>2025-03-05T15:40:27.000Z</published>
    <updated>2025-03-06T03:15:19.939Z</updated>
    
    <content type="html"><![CDATA[<p>来复习总结一下左值引用与右值引用。</p><p>左值引用和右值引用是 C++ 中用于管理对象生命周期的两种引用类型，主要区别在于它们绑定的对象类型和使用场景</p><h1>左值引用（Lvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp; 声明的引用，只能绑定到 左值（有名字、有内存地址的对象）。</p><ol start="2"><li>特点</li></ol><ul><li>左值对象通常可以被修改（除非被 const 修饰）。</li><li>常用于函数参数传递（避免拷贝）或为现有对象起别名。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref_a = a;  <span class="comment">// 正确：左值引用绑定左值</span></span><br><span class="line"><span class="comment">// int&amp; ref_b = 10;  // 错误：不能绑定到右值（字面量）</span></span><br></pre></td></tr></table></figure><h1>右值引用（Rvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp;&amp; 声明的引用，只能绑定到 右值（临时对象、字面量、即将销毁的对象）。<br>2. 特点</p><ul><li>C++11 引入，用于实现<code>移动语义</code>和<code>完美转发</code>。</li><li>允许“窃取”右值的资源（如动态内存），避免不必要的拷贝。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span>;  <span class="comment">// 正确：右值引用绑定右值</span></span><br><span class="line"><span class="comment">// int&amp;&amp; rref2 = a;  // 错误：不能直接绑定左值</span></span><br></pre></td></tr></table></figure><h1>左值引用与右值引用的区别</h1><table><thead><tr><th>特性</th><th>左值引用 (&amp;)</th><th>右值引用 (&amp;&amp;)</th></tr></thead><tbody><tr><td>绑定对象类型</td><td>左值（持久对象）</td><td>右值（临时对象）</td></tr><tr><td>可修改性</td><td>允许修改（除非 const）</td><td>允许修改</td></tr><tr><td>主要用途</td><td>避免拷贝、别名</td><td>移动语义、完美转发</td></tr></tbody></table><h1>应用场景</h1><ol><li>移动语义（Move Semantics）</li></ol><p>右值引用允许将资源（如堆内存）从临时对象“移动”到新对象，避免深拷贝。</p><p>假设有一个管理动态数组的类 MyArray：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyArray</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当发生拷贝时（如 MyArray b = a），默认的拷贝构造函数会执行浅拷贝，导致两个对象共享同一块内存，引发双重释放等问题。为此，我们需要：</p><ul><li>深拷贝：显式实现拷贝构造函数，复制数据（安全但性能差）。</li><li>移动语义：直接“窃取”临时对象的资源（高效且安全）。</li></ul><p>移动语义的<code>核心机制</code><br>（1）右值引用（&amp;&amp;）<br>右值引用只能绑定到右值（临时对象、字面量、std::move 转换后的对象）。<br>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp;&amp; rref = <span class="built_in">MyArray</span>(<span class="number">100</span>);  <span class="comment">// 绑定到临时对象（右值）</span></span><br></pre></td></tr></table></figure><p>（2）移动构造函数和移动赋值运算符</p><ul><li>移动构造函数：接受右值引用参数，直接转移资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyArray</span>(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">    : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">    other.size_ = <span class="number">0</span>;        <span class="comment">// 原对象置空</span></span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;   <span class="comment">// 防止原对象析构时释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动赋值运算符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp; <span class="keyword">operator</span>=(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;      <span class="comment">// 释放当前资源</span></span><br><span class="line">        data_ = other.data_; <span class="comment">// 窃取资源</span></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么何时会触发移动语义？</p><p>场景 1：传递临时对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">createArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">arr</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> arr;  <span class="comment">// 返回时，arr 是右值，触发移动构造函数（而非拷贝）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray a = <span class="built_in">createArray</span>();  <span class="comment">// 移动构造</span></span><br></pre></td></tr></table></figure><p>场景 2：显式使用 std::move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);  <span class="comment">// 将左值 a 转为右值，触发移动构造</span></span><br><span class="line"><span class="comment">// 此时 a.data_ = nullptr，a 不可再使用！</span></span><br></pre></td></tr></table></figure><p>场景 3：标准库优化（如 vector::push_back）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;MyArray&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">MyArray</span>(<span class="number">1000</span>));  <span class="comment">// 传递右值，触发移动构造</span></span><br></pre></td></tr></table></figure><ol start="2"><li>完美转发（Perfect Forwarding）</li></ol><p>结合 std::forward 保持参数的值类别（左值/右值），是 C++ 中实现完美转发的核心机制，用于泛型编程。</p><p>假设你写了一个泛型包装函数 wrapper，它需要将参数传递给另一个函数 process：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);   <span class="comment">// 直接传递arg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里有一个问题：无论 arg 原始是左值还是右值，在 wrapper 内部，arg 始终是左值（因为它有名字，可以取地址）。因此，process 永远只能收到左值，无法触发右值重载的优化（如移动语义）。</p><p>使用std::forward可以解决这个问题。std::forward的作用是根据模板参数 T 的类型，有条件地将参数转换为左值或右值。修改后的 wrapper：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持 arg 的原始值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时：</p><ul><li>如果 arg 原始是左值，std::forward<T> 返回左值引用。</li><li>如果 arg 原始是右值，std::forward<T> 返回右值引用，从而允许移动语义。</li></ul><p>举个栗子：</p><p>定义两个 process 重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理左值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理右值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况 1：不使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);  <span class="comment">// arg 始终是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bad_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">bad_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理左值: 20 （但 20 是右值！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论传入左值还是右值，arg 在 bad_wrapper 内部都是左值，导致右值无法触发移动优化。</p><p>情况 2：使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持原始值类别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">good_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">good_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理右值: 20 （正确触发右值重载！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 std::forward 根据传入参数的值类别，正确选择 process 的左值或右值版本。</p><p>那么 std::forward 是如何做到的呢？是靠引用折叠规则。</p><p>引用折叠规则<br>当模板参数 T 推导为左值或右值时，T&amp;&amp; 会触发引用折叠：</p><ul><li>如果 T 是 X&amp;（左值引用），T&amp;&amp; 折叠为 X&amp;（仍是左值引用）。</li><li>如果 T 是 X 或 X&amp;&amp;，T&amp;&amp; 变为 X&amp;&amp;（右值引用）。</li></ul><p>简化版的 std::forward 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 T 是左值引用（如 int&amp;），T&amp;&amp; 折叠为 int&amp;，返回左值引用。</li><li>如果 T 是普通类型（如 int），T&amp;&amp; 是 int&amp;&amp;，返回右值引用。</li></ul><ol start="3"><li>优化临时对象</li></ol><p>通过 std::move 将左值显式转换为右值引用，触发移动操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; v1;</span><br><span class="line">std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s));  <span class="comment">// 移动 s 的资源到 vector，s 变为空</span></span><br></pre></td></tr></table></figure><h1>注意事项</h1><ol><li>右值引用本身是左值<br>右值引用变量有名字，因此是左值。若需继续传递右值，需用 std::move</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 是左值（有名字），若需传递给其他函数，需转为右值</span></span><br><span class="line">    <span class="built_in">another_process</span>(std::<span class="built_in">move</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>避免滥用 std::move<br>对局部变量使用 std::move 可能导致意外悬空引用。</li></ol><p>移动后的对象处于有效但未定义状态（通常被置空）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="comment">// a.data_ 变为 nullptr，不可再访问 a 的数据！</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>std::move 的本质<br>std::move 只是将对象强制转换为右值引用，本身不执行任何移动操作。真正的资源转移在移动构造函数或移动赋值运算符中完成。</p></li><li><p>异常安全<br>移动操作应标记为 noexcept，否则某些标准库操作（如 vector 扩容）可能回退到拷贝语义。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来复习总结一下左值引用与右值引用。&lt;/p&gt;
&lt;p&gt;左值引用和右值引用是 C++ 中用于管理对象生命周期的两种引用类型，主要区别在于它们绑定的对象类型和使用场景&lt;/p&gt;
&lt;h1&gt;左值引用（Lvalue Reference）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ol</summary>
      
    
    
    
    <category term="C/C++ 面试" scheme="http://malone-ai.github.io/categories/C-C-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C++" scheme="http://malone-ai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 里的 lower_bound 和 upper_bound</title>
    <link href="http://malone-ai.github.io/2025/03/04/chores1/"/>
    <id>http://malone-ai.github.io/2025/03/04/chores1/</id>
    <published>2025-03-04T15:20:21.000Z</published>
    <updated>2025-03-06T03:16:40.738Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++ 中，lower_bound 和 upper_bound 是标准库 <algorithm> 中提供的两个非常实用的函数，用于在已排序的序列中进行二分查找。它们的功能和用法非常相似，但在细节上有一些区别。</p><h1>使用条件</h1><p>由于 lower_bound 和 upper_bound 底层是基于二分查找的，故lower_bound 和 upper_bound 都要求输入的序列是已排序的（默认是升序）。</p><h1>lower_bound 的功能</h1><p>lower_bound 用于在已排序的序列中查找第一个大于或等于目标值的元素的位置。通俗地讲，就是在这个序列中为目标值找一个位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于或等于 value 的元素的迭代器。如果所有元素都小于 value，则返回 last。</li></ul><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt;= 6 is 7 at index 3</code></pre><h1>upper_bound 的功能</h1><p>upper_bound 用于在已排序的序列中查找第一个大于目标值的元素的位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于 value 的元素的迭代器。如果所有元素都小于或等于 value，则返回 last。</li></ul><p>参数与lower_bound相同，返回值就不同了。</p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt; 6 is 7 at index 3</code></pre><h1>lower_bound 和 upper_bound 的区别</h1><table><thead><tr><th>特性</th><th><code>lower_bound</code></th><th><code>upper_bound</code></th></tr></thead><tbody><tr><td><strong>查找条件</strong></td><td>第一个 <strong>大于或等于</strong> 目标值的元素</td><td>第一个 <strong>大于</strong> 目标值的元素</td></tr><tr><td><strong>返回值</strong></td><td>指向第一个满足条件的元素的迭代器</td><td>指向第一个满足条件的元素的迭代器</td></tr><tr><td><strong>目标值存在时</strong></td><td>返回目标值的第一个位置</td><td>返回目标值的下一个位置</td></tr><tr><td><strong>目标值不存在时</strong></td><td>返回第一个大于目标值的位置</td><td>返回第一个大于目标值的位置</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 C++ 中，lower_bound 和 upper_bound 是标准库 &lt;algorithm&gt; 中提供的两个非常实用的函数，用于在已排序的序列中进行二分查找。它们的功能和用法非常相似，但在细节上有一些区别。&lt;/p&gt;
&lt;h1&gt;使用条件&lt;/h1&gt;
&lt;p&gt;由于 lower_</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划六：最长递增子序列</title>
    <link href="http://malone-ai.github.io/2025/03/04/dp6/"/>
    <id>http://malone-ai.github.io/2025/03/04/dp6/</id>
    <published>2025-03-04T12:08:05.000Z</published>
    <updated>2025-03-05T15:37:14.044Z</updated>
    
    <content type="html"><![CDATA[<p>今日学习灵茶山艾府出品的<a href="https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">最长递增子序列【基础算法精讲 20】</a>。</p><p>UP通过Leetcode官方题<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列</a>进行讲解。</p><h1>300. 最长递增子序列</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p><code>子序列</code>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><h1>基本思路</h1><p>由于子序列是数组的一个子集，因此用子集型回溯来思考，也就是[选或不选]或者[枚举选哪个]。</p><p>对于nums = [1, 6, 7, 2, 4, 5, 3]：</p><ul><li>如果我们倒着思考，假设3是严格递增子序列中的最后一个数，考虑选或不选，需要与前面的数字进行比较，需要知道当前数的下标以及上一个数的下标。</li><li>如果考虑枚举选哪个，可以直接枚举3前面比3小的数字，当作严格递增子序列的倒数第二个数，只需要知道当前数字的下标即可。</li></ul><p>经过对比，枚举选哪个的思路只需要一个参数，更方便。</p><p>因此最终的思路为：<br>- 枚举以nums[i]结尾的严格递增子序列的长度<br>- 接着需要枚举以nums[j]为倒数第二个元素的严格递增子序列的长度<br>- 其中j &lt; i，nums[j] &lt; nums[i]</p><p>以下是灵茶山艾府总结的回溯三问：</p><ul><li>子问题？以nums[i]结尾的严格递增子序列的长度</li><li>当前操作？枚举nums[j]</li><li>下一个子问题？以nums[j]结尾的严格递增子序列的长度</li></ul><p>定义dfs(i)为以nums[i]结尾的严格递增子序列的长度，枚举满足要求的nums[j]，子问题就变成了以nums[j]结尾的严格递增子序列的长度，这些子问题求个最大值再+1，就得到了以nums[i]结尾的严格递增子序列的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i) = max&#123;dfs(j)&#125; + 1， j &lt; i &amp;&amp; nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure><h1>递归</h1><p>递归实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// dfs(i)表示以nums[i]结尾的严格递增子序列的长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(j), res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ++res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，一定要将i = 0 ~ n - 1当参数传给dfs，也就是最后的循环里挨个调用。如果直接dfs(n-1)的话，只有当j &lt; i &amp;&amp; nums[j] &lt; nums[i]的时候才能递归到其他状态，可能会导致0~n-2中的某些递归不到。并且dfs(n-1)的意义是以nums[n-1]结尾的严格递增子序列的长度，但是最长的严格递增子序列并不一定以nums[n-1]结尾，也可能是以前面的某个数字结尾。</p><h1>递推</h1><p>递归很容易翻译成递推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++f[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>贪心 + 二分</h1><p>这一块开始听不懂了，主要感觉灵茶山艾府的证明不是很清晰。</p><p>通过贪心 + 二分查找求解<code>最长严格递增子序列（LIS）</code>问题的核心思想是：<code>尽可能地让递增子序列的末尾元素更小，从而为后续的元素提供更多的扩展机会</code>。</p><h2 id="贪心思想">贪心思想</h2><p>贪心算法的核心是：在每一步选择中，都采取当前最优的策略，从而希望最终得到全局最优解。</p><p>在这个问题中，我们希望找到一个尽可能长的递增子序列。为了达到这个目标，我们需要让子序列的末尾元素尽可能小，因为较小的末尾元素更容易被后续的元素扩展。</p><p>因此，贪心策略是<code>对于相同长度的递增子序列，我们只保留末尾元素最小的那个</code>。</p><p>g[i] 表示长度为 i+1 的递增子序列的最小末尾元素</p><h2 id="二分查找的作用">二分查找的作用</h2><p>对于每个新元素 num，我们需要找到它在 g 中的位置：</p><ul><li>如果 num 比 g 中的所有元素都大，说明它可以扩展当前的最长递增子序列，因此将其添加到 g 的末尾。</li><li>否则，找到 g 中第一个大于等于 num 的位置 pos，并用 num 替换 g[pos]。这是因为 num 可以作为一个更小的末尾元素来构成长度为 pos+1 的递增子序列。</li></ul><p>通过二分查找，我们可以在 O(log n) 的时间内找到 num 应该插入或替换的位置，从而保证算法的高效性。</p><h2 id="为什么贪心-二分查找是正确的？">为什么贪心 + 二分查找是正确的？</h2><p>我们需要证明：通过贪心策略维护的数组 g，最终的长度就是最长递增子序列的长度。</p><p>关键点：</p><ol><li><p>g 的长度就是 LIS 的长度：</p><ul><li>每次向 g 中添加一个新元素时，都意味着我们发现了一个更长的递增子序列。</li><li>每次替换 g 中的元素时，只是优化了相同长度的递增子序列的末尾元素，而不会改变 g 的长度。</li></ul></li><li><p>g 的严格递增性：</p><ul><li>由于我们总是用更小的元素替换 g 中的元素，g 始终保持严格递增。</li><li>这种性质保证了我们可以通过二分查找快速定位 num 应该插入或替换的位置。</li></ul></li><li><p>替换操作不会影响最终结果：</p><ul><li>当我们用 num 替换 g[pos] 时，虽然我们改变了长度为 pos+1 的递增子序列的末尾元素，但这并不影响更长递增子序列的构建。</li><li>因为 num 比原来的 g[pos] 更小，它为后续的元素提供了更多的扩展机会。</li></ul></li></ol><h2 id="一个例子">一个例子</h2><p>假设 nums = [10, 9, 2, 5, 3, 7, 101, 18]，我们通过贪心 + 二分查找来求解：</p><ul><li>初始化 g = []。</li><li>遍历 nums：<ol><li>num = 10：<ul><li>g 为空，直接添加：g = [10]。</li></ul></li><li>num = 9：<ul><li>找到第一个大于等于 9 的位置是 0，替换：g = [9]。</li></ul></li><li>num = 2：<ul><li>找到第一个大于等于 2 的位置是 0，替换：g = [2]。</li></ul></li><li>num = 5：<ul><li>5 比 g 中的所有元素都大，添加到末尾：g = [2, 5]。</li></ul></li><li>num = 3：<ul><li>找到第一个大于等于 3 的位置是 1，替换：g = [2, 3]。</li></ul></li><li>num = 7：<ul><li>7 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7]。</li></ul></li><li>num = 101：<ul><li>101 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7, 101]。</li></ul></li><li>num = 18：<ul><li>找到第一个大于等于 18 的位置是 3，替换：g = [2, 3, 7, 18]。</li></ul></li></ol></li></ul><p>最终，g 的长度是 4，因此最长递增子序列的长度是 4。</p><p>这种方法的时间复杂度是 O(n log n)，空间复杂度是 O(n)，是一种非常高效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心 + 二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;num: nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), num);</span><br><span class="line">            <span class="keyword">if</span> (it == g.<span class="built_in">end</span>())</span><br><span class="line">                g.<span class="built_in">emplace_back</span>(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>变形</h1><p>如果允许最长递增子序列中有重复元素，那么按照<code>贪心+二分</code>的思路，在g中需要寻找的就是第一个大于（原来是大于等于）num的位置，也就是把原来使用的lower_bound改成upper_bound即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日学习灵茶山艾府出品的&lt;a href=&quot;https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.1387.collection.video_card.click&amp;amp;vd_source=a0f19e79</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 集成Element-Plus</title>
    <link href="http://malone-ai.github.io/2025/03/04/project-test2/"/>
    <id>http://malone-ai.github.io/2025/03/04/project-test2/</id>
    <published>2025-03-04T08:29:23.000Z</published>
    <updated>2025-03-04T10:24:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1GLKweAEHj/?spm_id_from=333.1245.0.0">【带小白做毕设】02. 使用Vue3集成Element-Plus快速搭建一个管理系统的页面</a>并进行一个学习记录。</p><h1>Element-Plus</h1><p>Element-Plus 是一套前端 UI 框架，提供了许多精美的样式，Ctrl-C + Ctrl-V即可使用。<a href="https://element-plus.org/zh-CN/">官网跳转</a>。</p><p>使用以下命令安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-plus -S</span><br></pre></td></tr></table></figure><p>在main.js中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/css/global.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>) <span class="comment">// 这一行</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后直接从官网找到以下代码粘贴到Home.vue体验：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    主页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span>&gt;</span>Info<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span>&gt;</span>Warning<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span>&gt;</span>Danger<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1>使用 icon</h1><p>首先安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @element-plus/icons-vue</span><br></pre></td></tr></table></figure><p>然后需要从 @element-plus/icons-vue 中导入所有图标并进行全局注册：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您正在使用CDN引入，请删除下面一行。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ElementPlusIconsVue</span> <span class="keyword">from</span> <span class="string">&#x27;@element-plus/icons-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, component] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="title class_">ElementPlusIconsVue</span>)) &#123;</span><br><span class="line">  app.<span class="title function_">component</span>(key, component)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环部分放在main.js的末尾即可。</p><p>然后就可以从官网复制一个icon放到Home.vue中即可使用icon了。</p><p>使用图标:</p><ul><li>el-input：当你在输入框组件里面使用图标，你需要单独导入图标</li><li>el-icon、el-button：按钮或者图标组件里面，不需要单独导入图标</li></ul><h1>Element-Plus 主题色设置</h1><p>安装依赖 sass、unplugin-vue-components、unplugin-auto-import</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D sass unplugin-vue-components unplugin-auto-import</span><br></pre></td></tr></table></figure><p>配置index.scss放在 src/assets/css 目录下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@forward <span class="string">&quot;element-plus/theme-chalk/src/common/var.scss&quot;</span> <span class="title function_">with</span>(</span><br><span class="line">    <span class="attr">$colors</span>:(</span><br><span class="line">            <span class="string">&quot;primary&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #2c82ff),</span><br><span class="line">            <span class="string">&quot;success&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #31bf00),</span><br><span class="line">            <span class="string">&quot;warning&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #ffade0),</span><br><span class="line">            <span class="string">&quot;danger&quot;</span>:   (<span class="string">&quot;base&quot;</span>:  #e52f2f), </span><br><span class="line">            <span class="string">&quot;info&quot;</span>:     (<span class="string">&quot;base&quot;</span>: #8855ff),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置vite.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span><span class="string">&#x27;unplugin-auto-import/vite&#x27;</span><span class="comment">//自动导入vue中的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span><span class="comment">//自动导入ui-组件 比如 element-plus等</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span><span class="comment">//对应组件引入</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line"><span class="comment">//element-plus按简导入</span></span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [</span><br><span class="line">            <span class="comment">//配置elementPlus采用sass样式配置系统</span></span><br><span class="line">            <span class="title class_">ElementPlusResolver</span>(&#123;<span class="attr">importStyle</span>:<span class="string">&quot;sass&quot;</span>&#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="attr">css</span>:&#123;</span><br><span class="line">  <span class="attr">preprocessorOptions</span>:&#123;</span><br><span class="line">    <span class="attr">scss</span>: &#123;</span><br><span class="line">      <span class="attr">additionalData</span>: <span class="string">`@use&quot;@/assets/css/index.scss&quot; as *;`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1>创建后台基本框架</h1><p>创建vue/src/views/Manager.vue文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1GLKweAEHj/?spm_id_from=333.1245.0.0&quot;&gt;【带小白做毕设】02. 使用Vue3集成Element-Plus快速搭建一个管理</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端" scheme="http://malone-ai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="http://malone-ai.github.io/tags/Vue/"/>
    
    <category term="Element-Plus" scheme="http://malone-ai.github.io/tags/Element-Plus/"/>
    
  </entry>
  
</feed>
