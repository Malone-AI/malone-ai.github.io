<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零一世界</title>
  
  
  <link href="http://malone-ai.github.io/atom.xml" rel="self"/>
  
  <link href="http://malone-ai.github.io/"/>
  <updated>2025-03-02T07:18:32.536Z</updated>
  <id>http://malone-ai.github.io/</id>
  
  <author>
    <name>Malone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://malone-ai.github.io/2025/03/02/designPattern1/"/>
    <id>http://malone-ai.github.io/2025/03/02/designPattern1/</id>
    <published>2025-03-02T00:50:59.000Z</published>
    <updated>2025-03-02T07:18:32.536Z</updated>
    
    <content type="html"><![CDATA[<p>通过他人博客学习一下单例模式以及C++实现，文件链接<a href="https://blog.csdn.net/trackxiaoxin321/article/details/110749781">C++设计模式之单例模式详解（懒汉模式、饿汉模式、双重锁）</a>。</p><h1>走进单例模式</h1><p>我们希望类的实例对象有且仅有一个，比如数据库连接配置、应用设置时，系统中需要一个全局对象，所有模块共享同一配置。再比如数据库连接池也需要全局管理，避免频繁创建与销毁。</p><p>感觉上述例子并不直观，再举个直观通俗的例子——家里的电表。家里的电表记录整个家庭的用电量。无论你在厨房、卧室还是客厅用电，电表都是同一个。你不会希望每个房间都有一个独立的电表，因为那样会导致用电量的计算混乱。</p><p>我们希望实例对象有且只有一个，此时就需要用到单例模式了。单例模式保证一个类有且仅有一个实例，并且会提供一个全局访问点。</p><p>如何实现让一个类的实例只有一个呢？那么就需要在构造函数上做点“手脚”。如果构造函数是public，那么就没有任何限制地可以构造对象了。因此，需要将构造函数私有化即设置为private属性，并对外提供一个接口，并且这个接口得是静态的即static关键字修饰的接口。如果不使用static关键字修饰，那么调用这个接口就需要创建对象，而构造函数又被私有化了，无法创建对象。因此这个接口得是静态的。</p><p>此外，还需要禁用拷贝构造函数和复制运算符。</p><h2 id="补充拷贝构造函数">补充拷贝构造函数</h2><p>复习一下拷贝构造函数。</p><p>拷贝构造函数是C++中的一个特殊成员函数，用于创建一个新对象，并将其初始化为另一个同类型对象的副本。它在以下情况下会被调用：</p><ul><li>用一个对象初始化另一个对象时。</li><li>将对象作为参数按值传递给函数时。</li><li>从函数按值返回对象时。</li></ul><p>拷贝构造函数的典型形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 拷贝函数逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拷贝构造函数的参数是一个常量引用（const MyClass&amp;），表示被拷贝的对象。</p><p>拷贝构造函数常用到的问题是<code>浅拷贝</code>的问题，不再多说啦。</p><h1>具体实现</h1><p>单例模式实现有两种方式：</p><ul><li>懒汉方式</li><li>饿汉方式</li></ul><h2 id="懒汉方式">懒汉方式</h2><p>懒汉方式：顾名思义，很“懒”，只有用到了才实例化对象并返回（调用了对外的接口才会实例化对象）。代码实现如下：</p><h3 id="不加锁">不加锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance=<span class="literal">nullptr</span>; <span class="comment">//初始化静态变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton* singlep1 = Singleton::<span class="built_in">getInstance</span>();   <span class="comment">//通过类域获取接口</span></span><br><span class="line">Singleton* singlep2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; singlep1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; singlep2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现是<code>线程不安全</code>的，原因在于<code>getInstance</code>方法中的条件判断和实例创建操作不是原子的。在多线程环境下，可能会导致多个线程同时创建实例，从而破坏单例模式的唯一性。</p><p>在 getinstance 方法中，以下代码是问题的根源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) </span><br><span class="line">    instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure><ul><li>多个线程可能同时进入 if (instance == nullptr) 的判断。</li><li>如果 instance 为 nullptr，多个线程会同时执行 instance = new singleClass()，导致创建多个实例。</li><li>最终，instance 可能指向不同的对象，破坏了单例模式的唯一性。</li></ul><h3 id="加锁后检查">加锁后检查</h3><p>为了解决这一问题，很容易想到使用互斥信号量也就是互斥锁来解决，于是就有以下方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br></pre></td></tr></table></figure><p>这种实现方法有很明显的优缺点:</p><ul><li>优点<ul><li>简单直观</li></ul></li><li>缺点<ul><li>每次调用<code>getInstance</code>都需要加锁，性能开销较大。</li></ul></li></ul><h3 id="二重锁">二重锁</h3><p>因此继续进行改进，使用<code>双重检查锁定</code>的方式，又称为<code>二重锁</code>。不同于前一种上锁方法，二重锁的<code>核心思想</code>是通过两次检查实例是否为空来减少加锁的次数：</p><ol><li>第一次检查（不加锁）：检查实例是否已经创建。如果已经创建，直接返回实例，避免加锁的开销。</li><li>第二次检查（加锁）：如果实例未创建，加锁后再次检查实例是否为空。如果仍然为空，则创建实例。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance=<span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br></pre></td></tr></table></figure><h4 id="二重锁优点">二重锁优点</h4><ol><li>减少加锁开销<ul><li>只有在实例未创建时才加锁，避免了每次调用 getInstance 都加锁的性能开销。</li></ul></li><li>线程安全<ul><li>通过加锁确保实例创建过程的线程安全。</li></ul></li></ol><h4 id="额外补充">额外补充</h4><p>上述实现中对于互斥信号量mtx的上锁使用的是<code>mtx.lock()</code>，解锁使用的是<code>mtx.unlock()</code>。其实可以使用<code>lock_guard&lt;mutex&gt; lock(mtx)</code>来实现。</p><ol><li><p>mtx.lock() 和 mtx.unlock()</p><ul><li>手动加锁和解锁：<ul><li>mtx.lock()：手动加锁。</li><li>mtx.unlock()：手动解锁。</li></ul></li><li>需要显式调用解锁：<ul><li>如果忘记调用 mtx.unlock()，会导致锁未被释放，可能引发死锁。</li></ul></li><li>灵活性：<ul><li>可以在代码的任何地方加锁和解锁，适合需要精细控制锁的场景。</li></ul></li></ul></li><li><p>lock_guard<mutex> lock(mtx)</p><ul><li>自动加锁和解锁：<ul><li>lock_guard 是一个 RAII（资源获取即初始化）封装类。</li><li>在构造时自动加锁，在析构时自动解锁。</li></ul></li><li>无需手动解锁：<ul><li>即使函数提前返回或抛出异常，lock_guard 也能保证锁被释放。</li></ul></li><li>简洁性和安全性：<ul><li>代码更简洁，不易出错。</li></ul></li></ul></li><li><p>lock_guard 和 mtx.lock() 的区别</p></li></ol><table><thead><tr><th>特性</th><th>lock_guard<mutex></th><th>mtx.lock() 和 mtx.unlock()</th></tr></thead><tbody><tr><td>加锁方式</td><td>自动加锁（构造时）</td><td>手动加锁</td></tr><tr><td>解锁方式</td><td>自动解锁（析构时）</td><td>手动解锁</td></tr><tr><td>异常安全</td><td>是（即使抛出异常也能解锁）</td><td>否（需要手动处理异常）</td></tr><tr><td>代码简洁性</td><td>高</td><td>低</td></tr><tr><td>灵活性</td><td>低（锁的作用域由 lock_guard 的生命周期决定）</td><td>高（可以在任意位置加锁和解锁）</td></tr><tr><td>适用场景</td><td>简单的加锁和解锁场景</td><td>需要精细控制锁的场景</td></tr></tbody></table><h4 id="静态局部变量实例化实现">静态局部变量实例化实现</h4><p>C++11 标准规定，静态局部变量的初始化是线程安全的。因此可以使用静态局部变量初始化来实现懒汉模式。</p><ol><li>核心思想<ul><li>延迟初始化：单例对象在第一次调用 getInstance 时才被创建，而不是在程序启动时。</li><li>线程安全：C++11 标准规定，局部静态变量的初始化是线程安全的，编译器会自动处理线程同步问题。</li><li>简洁高效：无需手动管理锁或静态成员变量，代码更简洁。</li></ul></li><li>静态局部变量的特性<ul><li>生命周期：静态局部变量的生命周期从第一次执行到它的声明语句开始，直到程序结束。</li><li>线程安全：C++11 及以上标准保证，静态局部变量的初始化是线程安全的。</li><li>唯一性：静态局部变量只会被初始化一次。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">//初始化静态变量</span></span><br></pre></td></tr></table></figure><h2 id="饿汉方式">饿汉方式</h2><p>以上是单例模式的懒汉实现方法，接下来介绍饿汉实现方法。</p><p>饿汉模式：不管调不调用对外接口，都已经实例化对象了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式：不管用不用得到，都构造出来。本身就是线程安全的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过他人博客学习一下单例模式以及C++实现，文件链接&lt;a href=&quot;https://blog.csdn.net/trackxiaoxin321/article/details/110749781&quot;&gt;C++设计模式之单例模式详解（懒汉模式、饿汉模式、双重锁）&lt;/a&gt;。&lt;/p</summary>
      
    
    
    
    <category term="设计模式" scheme="http://malone-ai.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="http://malone-ai.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="C++" scheme="http://malone-ai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java开发环境搭建</title>
    <link href="http://malone-ai.github.io/2025/03/01/java1/"/>
    <id>http://malone-ai.github.io/2025/03/01/java1/</id>
    <published>2025-03-01T09:36:40.000Z</published>
    <updated>2025-03-01T09:54:24.154Z</updated>
    
    <content type="html"><![CDATA[<h1>JDK的下载与安装</h1><p>百度搜索JDK8到Oracle官网下载<code>Java SE Development Kit 8u202</code>即可，需要注册账号。</p><p>下载好对应电脑版本的安装包后直接安装，记得把安装目录给记清楚，配置环境需要使用。</p><h1>配置环境目录</h1><ol><li>编辑系统环境变量<ul><li>创建一个新的系统环境变量，名称为<code>JAVA_HOME</code>，值为java的安装路径</li></ul></li><li>配置PATH变量<ul><li>在PATH变量中添加<code>%JAVA_HOME%\bin</code></li><li>在PATH变量中添加<code>%JAVA_HOME%\jre\bin</code></li></ul></li><li>验证<ul><li>在cmd中输入<code>java -version</code></li><li>显示java的版本等信息即为成功</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;JDK的下载与安装&lt;/h1&gt;
&lt;p&gt;百度搜索JDK8到Oracle官网下载&lt;code&gt;Java SE Development Kit 8u202&lt;/code&gt;即可，需要注册账号。&lt;/p&gt;
&lt;p&gt;下载好对应电脑版本的安装包后直接安装，记得把安装目录给记清楚，配置环境需要使用</summary>
      
    
    
    
    <category term="Java" scheme="http://malone-ai.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL一：MySQL环境配置</title>
    <link href="http://malone-ai.github.io/2025/03/01/mysql1/"/>
    <id>http://malone-ai.github.io/2025/03/01/mysql1/</id>
    <published>2025-03-01T08:31:58.000Z</published>
    <updated>2025-03-02T08:33:28.839Z</updated>
    
    <content type="html"><![CDATA[<p>即日起学习Mysql并进行记录。</p><h1>数据库分类</h1><h2 id="关系型数据库">关系型数据库</h2><ul><li>称作SQL</li><li>Mysql，Oracle，Sql Server， DB2， SQLlite</li><li>通过表与表之间，行与行之间的关系进行数据存储</li></ul><h2 id="非关系型数据库">非关系型数据库</h2><ul><li>称作NoSQL即Not only SQL</li><li>Redis， MongDB</li><li>对象存储，通过对象自身的属性来进行存储</li></ul><h2 id="DBMS">DBMS</h2><ul><li>DBMS即数据库管理系统</li></ul><h2 id="MySQL">MySQL</h2><ul><li>MySQL是一个关系型数据库管理系统</li><li>由瑞典 MySQL AB 公司开发</li><li>属于 Oracle 旗下产品</li><li>MySQL是最流行的关系型数据库管理系统之一</li><li>在 WEB 应用方面，MySQL是最好的RDBMS (Relational Database Management System，关系数据库管理系统)应用软件之一。</li></ul><h1>MySQL 安装</h1><h2 id="建议">建议</h2><ul><li>尽量使用压缩包，不用exe文件（貌似与注册表有关）</li></ul><h2 id="详细安装说明">详细安装说明</h2><ol><li>解压到合适的位置（我的安装目录为D:\ProgramFiles\mysql-5.7.44）</li><li>为解压后文件中的bin目录配置环境变量</li><li>在解压后的目录下创建一个my.ini文件（D:\ProgramFiles\mysql-5.7.44\my.ini）</li><li>编辑my.ini文件为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=D:\ProgramFiles\mysql-5.7.44\</span><br><span class="line">datadir=D:\ProgramFiles\mysql-5.7.44\data\</span><br><span class="line">port=3306</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>注意：虽然没有data目录也不用去手动创建！</p><ol start="5"><li>启动管理员模式下的cmd，并将目录切换到mysql的bin目录下，然后输入<code>mysqld --install</code><ul><li>显示Service successfully installed.即成功</li></ul></li><li>再输入<code>mysqld --initialize-insecure --user=mysql</code>初始化数据文件<ul><li>此时会在mysql目录下产生data文件夹</li></ul></li><li>输入<code>net start mysql</code>启动mysql服务</li><li>输入<code>mysql -u root -p</code>，注意-p后不要＋任何东西，包括空格。提示输入密码，直接回车跳过</li><li>输入<code>update mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost';</code>修改密码为123456，最后输入<code>flush priviledges;</code>刷新权限（注意MySQL语句以分号结尾）<ul><li>如果使用的是MySQL 5.7.6 及以上版本，输入<code>ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';</code>，然后<code>flush priviledges</code></li></ul></li><li>将my.ini文件<code>skip-grant-tables</code>删除</li><li>重启MySQL服务即可使用<ul><li>net stop mysql</li><li>net start mysql</li></ul></li><li>输入<code>mysql -u root -p</code>再键入密码即可使用</li></ol><h2 id="基本命令行">基本命令行</h2><ol><li>查询所有数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><ol start="2"><li>切换数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use [数据库名称]</span><br></pre></td></tr></table></figure><ol start="3"><li>查看数据库中所有的表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看显示数据库中所有表的信息</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descibe [表名]</span><br></pre></td></tr></table></figure><ol start="5"><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [数据库名称]</span><br></pre></td></tr></table></figure><ol start="6"><li>退出连接</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="sqlyog的使用">sqlyog的使用</h2><p>参考CSDN博客<a href="https://blog.csdn.net/weixin_43364551/article/details/116754626">https://blog.csdn.net/weixin_43364551/article/details/116754626</a></p><h2 id="数据库基本操作">数据库基本操作</h2><p>数据库 XXX 语言</p><ol><li>DDL 定义</li><li>DML 操作</li><li>DQL 查询</li><li>DCL 控制</li></ol><h1>操作数据库</h1><p>操作数据库-&gt;操作数据库中的表-&gt;操作数据库中的表的数据</p><ol><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [数据库名称]</span><br></pre></td></tr></table></figure><ol start="2"><li>删除数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] [数据库名称]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;即日起学习Mysql并进行记录。&lt;/p&gt;
&lt;h1&gt;数据库分类&lt;/h1&gt;
&lt;h2 id=&quot;关系型数据库&quot;&gt;关系型数据库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;称作SQL&lt;/li&gt;
&lt;li&gt;Mysql，Oracle，Sql Server， DB2， SQLlite&lt;/li&gt;
&lt;li&gt;通过</summary>
      
    
    
    
    <category term="MySQL" scheme="http://malone-ai.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://malone-ai.github.io/tags/MySQL/"/>
    
    <category term="关系型数据库" scheme="http://malone-ai.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>动态规划三</title>
    <link href="http://malone-ai.github.io/2025/02/28/dp3/"/>
    <id>http://malone-ai.github.io/2025/02/28/dp3/</id>
    <published>2025-02-28T15:49:07.000Z</published>
    <updated>2025-03-01T08:30:16.257Z</updated>
    
    <content type="html"><![CDATA[<p>今日继续学习B站Up主出品的基础算法精讲系列，<a href="https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">0-1背包 完全背包【基础算法精讲 18】</a>（点击即可跳转视频链接）。</p><p>0-1背包和完全背包是非常重要的DP模型，灵茶山艾府认为一定程度上它们就是“选或不选”思想的代表。</p><h1>0-1 背包</h1><p><code>0-1 背包</code>:有 n 个物品，第i个物品的体积为 w[i]，价值为 v[i]，每个物品至多选一个，求体积和不超过 capacity 时的最大价值和。</p><p>先从回溯开始思考，这里先附上灵茶山艾府总结的关于该问题的回溯三问：</p><ul><li>当前操作？枚举<code>第</code>i个物品选还是不选：<ul><li>不选，剩余容量不变</li><li>选，剩余容量变量</li></ul></li><li>子问题？即在剩余容量为c时，从<code>前</code>i-1个物品中得到的最大价值和</li><li>下一个子问题？分类讨论<ul><li>不选，剩余容量仍为c，从<code>前</code>i-1个物品中得到的最大价值和</li><li>选，剩余容量变为c-w[i]，从<code>前</code>i-1个物品中得到的最大价值和</li></ul></li></ul><p>先从回溯开始思考，也就是考虑第i个物品选还是不选，不选-&gt;容量不变，选-&gt;容量变小，由此确定递归参数中的i和c。对应的<code>子问题</code>就变成从前i个物品中能得到的最大价值和。</p><ul><li>不选就递归到它表示在剩余容量为c时，从前i-1个物品中获得的最大价值和。</li><li>选就递归到它表示在剩余容量为c-w[i]时，从前i-1个物品中获得的最大价值和。<br>上述两个取最大值就是dfs(i, c)的结果了。</li></ul><p>基于上述结果可以编写代码，我忽略的一点是当剩余容量c小于第i个物品即<code>c &lt; w[i]</code>时，我们只能不选第i个物品，因此直接返回<code>dfs(i-1, c)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">zero_one_knapsack</span><span class="params">(<span class="type">int</span> capacity, vector&lt;<span class="type">int</span>&gt;&amp; w, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i<span class="number">-1</span>, c-w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="494-目标和">494.目标和</h2><p>然后看leetcode题<a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个非负整数数组 nums 和一个整数 target 。</span><br><span class="line"></span><br><span class="line">向数组中的每个整数前添加 &#x27;+&#x27; 或 &#x27;-&#x27; ，然后串联起所有整数，可以构造一个 表达式 ：</span><br><span class="line"></span><br><span class="line"><span class="code">    例如，nums = [2, 1] ，可以在 2 之前添加 &#x27;+&#x27; ，在 1 之前添加 &#x27;-&#x27; ，然后串联起来得到表达式 &quot;+2-1&quot; 。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</span><br></pre></td></tr></table></figure><p>这道题看上去和0-1背包没有关系。</p><p>假设添加正号的数的和为p，那么添加负号的数的和为所有元素的和s减去p。那么<code>p - (s - p)</code>就是target了，即<code>p - (s - p) = t</code>=&gt;<code>2p=s+t</code>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">p=\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>。</p><p>现在问题就变成从nums中选择一些数字，使得他们的和恰好等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>的方案数。注意s+t既然要除以2那么s+t就得为偶数，并且由于nums[i]为非负数，故无论怎么选s+t都不会为负数。</p><p>背包问题的常见变形：</p><ol><li>至多装capacity，求方案数/最大价值和</li><li>恰好装capacity，求方案数/最大/最小价值和</li><li>至少装capacity，求方案数/最小价值和</li></ol><p>经过灵茶山艾府的巧妙转换，494. 目标和 问题就变形为上述第2中情况下的：恰好装capacity，求方案数。</p><p>接下来编写代码。首先计算s+t，如果s+t是负数或者说target是一个奇数，则不满足要求，方案数为0。否则将s+t除以2（整除）记为p。</p><p>对于递归，因为是从target倒着减，当c=0时说明找到了一个合法的方案数，因此返回1。否则返回0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c) + <span class="built_in">dfs</span>(i<span class="number">-1</span>, c - w[i]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w.<span class="built_in">size</span>() - <span class="number">1</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.length-<span class="number">1</span>, p, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c, <span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c, w) + dfs(i-<span class="number">1</span>, c - w[i], w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化为递推">优化为递推</h3><p>如何将记忆化搜索改成递推？灵茶山艾府总结如下：</p><ol><li>dfs -&gt; f数组</li><li>递归 -&gt; 循环</li><li>递归边界 -&gt; 数组初始值</li></ol><p>dfs改成f数组，这里的f数组是一个二维数组f[i][c]表示前i个数恰好等于c。需要重点处理一下边界条件，从原递归中的边界条件入手。递归的边界条件有<code>i &lt; 0 &amp;&amp; c == 0</code>时return 1，每次向下递归时都传参i-1，故负数下标为边界。原来的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以更改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>只对<code>i &lt; 0 &amp;&amp; c == 0</code>的边界条件转换为数组边界<code>f[0][0] = 1</code>，而没有处理<code>i &lt; 0 &amp;&amp; c != 0</code>是因为c != 0时不为f数组边界。</p><p>递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c) + <span class="built_in">dfs</span>(i<span class="number">-1</span>, c - w[i]);</span><br></pre></td></tr></table></figure><p>改成循环为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][c] = f[i<span class="number">-1</span>][c] + f[i<span class="number">-1</span>][c-w[i]]</span><br></pre></td></tr></table></figure><p>为了避免负数下标将f中的i全部+1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+1</span>][c] = f[i][c] + f[i][c-w[i]]</span><br></pre></td></tr></table></figure><p>相应的数组的第一维大小应为nums.size() + 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (p + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][c] = f[i][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[i<span class="number">+1</span>][c] += f[i][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][c] = f[i][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[i+<span class="number">1</span>][c] += f[i][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继续优化空间复杂度">继续优化空间复杂度</h3><h4 id="两行数组">两行数组</h4><p>每次把f[i+1]算完之后，后面就不会用到f[i]了，也就是每时每刻数组中只有两个元素在参与状态转移，干脆就只用两行数组。比如把f[1]算完了，那么计算f[2]时直接把结果填到f[0]当中。然后计算f[3]时，f[1]没用，就把f[3]填到f[1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+1</span>][c] = f[i][c];</span><br><span class="line"><span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">    f[i<span class="number">+1</span>][c] += f[i][c-w[i]];</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line"><span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">    f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br></pre></td></tr></table></figure><p>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (p + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[(i+<span class="number">1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一行数组">一行数组</h4><p>能否进一步优化？Of course！<br>两行数组对于第一维是正向计算，有覆盖问题。但是如果反向计算就没有覆盖问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(p<span class="number">+1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = p; c &gt;= <span class="number">0</span>; --c) </span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[c] += f[c-w[i]];</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> p; c &gt;= <span class="number">0</span>; --c) </span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[c] += f[c-w[i]];</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>完全背包</h1><p><code>完全背包</code>：有n种物品，第i种物品的体积为 w[i]，价值为 v[i]，每种物品<code>无限次重复选</code>，求体积和不超过 capacity时的最大价值和。</p><p>递归做法的回溯三问为：</p><ul><li>当前操作?枚举<code>第</code>i种物品选一个或不选:<ul><li>不选，剩余容量不变;</li><li>选一个，剩余容量减少 w[i]</li></ul></li><li>子问题?在剩余容量为c时，从<code>前</code>i种物品中得到的最大价值和</li><li>下一个子问题?分类讨论：<ul><li>不选：在剩余容量为c时，从<code>前</code>i-1 种物品中得到的最大价值和:</li><li>选一个，在剩余容量为c-w[i]时，从<code>前</code>i种物品中得到的最大价值和</li></ul></li></ul><p>这里和0-1背包的回溯<code>区别</code>为，在选了一个物品之后，i是不变的，表示可以继续选第i中物品。因此不是递归到i-1，而是递归到i。</p><p>很容易得到其实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">unbounded_knapsack</span><span class="params">(<span class="type">int</span> c, vector&lt;<span class="type">int</span>&gt;&amp; w, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i, c), <span class="built_in">dfs</span>(i, c-w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换">322. 零钱兑换</h2><p>看一道Leetcode题<a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span><br><span class="line"></span><br><span class="line">计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</span><br><span class="line"></span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure><p>背包问题的常见变形：</p><ol><li>至多装capacity，求方案数/最大价值和</li><li>恰好装capacity，求方案数/最大/最小价值和</li><li>至少装capacity，求方案数/最小价值和</li></ol><p>这道Leetcode题也是完全背包的一种变形，把物品价值看成是1，把求最大改成求最小，可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i, c) = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i, c-w[i]) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>由于要求恰好组成amount，所以当c=0时才能返回0表示前i个物品组成金额c（金额0）需要0枚硬币，否则返回无穷大表示方案不合法。这样后面取min时自然就取到了不是无穷大的方案。</p><p>最后还需要判断一下，如果ans小于无穷大表示这是一个合法方案，否则无合法方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, <span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : INT_MAX / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][c];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">                <span class="keyword">return</span> res = <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i, c-w[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">dfs</span>(n<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] w;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.w = w;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> dfs(n-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][c] != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][c];</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i]) </span><br><span class="line">            <span class="keyword">return</span> memo[i][c] = dfs(i-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> memo[i][c] = Math.min(dfs(i-<span class="number">1</span>, c), dfs(i, c-w[i]) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化为递推-2">优化为递推</h3><p>依然是使用f数组，根据递归边界条件当<code>i == 0 &amp;&amp; c == 0</code>时才是0，其他都是无穷大，所以f数组可以初始化为无穷大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i]) </span><br><span class="line">                    f[i<span class="number">+1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i<span class="number">+1</span>][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">+1</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = f[n][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: f) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    f[i+<span class="number">1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i+<span class="number">1</span>][j] = Math.min(f[i][j], f[i+<span class="number">1</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[n][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间优化">空间优化</h3><p>同0-1背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i]) </span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][j] = f[i%<span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][j] = <span class="built_in">min</span>(f[i%<span class="number">2</span>][j], f[(i<span class="number">+1</span>)%<span class="number">2</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = f[n%<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: f) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = f[i%<span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = Math.min(f[i%<span class="number">2</span>][j], f[(i+<span class="number">1</span>)%<span class="number">2</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[n%<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日继续学习B站Up主出品的基础算法精讲系列，&lt;a href=&quot;https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a&quot;&gt;0-1背包 完全背包【基础算法精</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 二十九：2353. 设计食物评分系统</title>
    <link href="http://malone-ai.github.io/2025/02/28/leetcode29/"/>
    <id>http://malone-ai.github.io/2025/02/28/leetcode29/</id>
    <published>2025-02-28T15:48:53.000Z</published>
    <updated>2025-03-01T08:33:59.027Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/design-a-food-rating-system/description/">2353. 设计食物评分系统</a>。</p><p>设计一个支持下述操作的食物评分系统：</p><ul><li>修改 系统中列出的某种食物的评分。</li><li>返回系统中某一类烹饪方式下评分最高的食物。</li></ul><p>实现 FoodRatings 类：</p><ul><li>FoodRatings(String[] foods, String[] cuisines, int[] ratings) 初始化系统。食物由 foods、cuisines 和 ratings 描述，长度均为 n 。<ul><li>foods[i] 是第 i 种食物的名字。</li><li>cuisines[i] 是第 i 种食物的烹饪方式。</li><li>ratings[i] 是第 i 种食物的最初评分。</li></ul></li><li>void changeRating(String food, int newRating) 修改名字为 food 的食物的评分。</li><li>String highestRated(String cuisine) 返回指定烹饪方式 cuisine 下评分最高的食物的名字。如果存在并列，返回<code>字典序较小</code>的名字。</li></ul><p>注意，字符串 x 的字典序比字符串 y 更小的前提是：x 在字典中出现的位置在 y 之前，也就是说，要么 x 是 y 的前缀，或者在满足 x[i] != y[i] 的第一个位置 i 处，x[i] 在字母表中出现的位置在 y[i] 之前。</p><p>这几天设计题做得头大😒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">int</span>, string&gt;&gt; foods_map;</span><br><span class="line">    unordered_map&lt;string, set&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;&gt; cuisines_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FoodRatings</span>(vector&lt;string&gt;&amp; foods, vector&lt;string&gt;&amp; cuisines, vector&lt;<span class="type">int</span>&gt;&amp; ratings) &#123;</span><br><span class="line">        <span class="type">int</span> n = foods.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            foods_map[foods[i]] = &#123;ratings[i], cuisines[i]&#125;;</span><br><span class="line">            cuisines_map[cuisines[i]].<span class="built_in">emplace</span>(-ratings[i], foods[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeRating</span><span class="params">(string food, <span class="type">int</span> newRating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [rating, cuisine] = foods_map[food];</span><br><span class="line">        cuisines_map[cuisine].<span class="built_in">erase</span>(&#123;-rating, food&#125;);</span><br><span class="line">        cuisines_map[cuisine].<span class="built_in">emplace</span>(-newRating, food);</span><br><span class="line">        rating = newRating;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cuisines_map[cuisine].<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FoodRatings object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);</span></span><br><span class="line"><span class="comment"> * obj-&gt;changeRating(food,newRating);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;highestRated(cuisine);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>由于每日一题题型较散，即日起本专栏停更。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-a-food-rating-system/description/&quot;&gt;2353. 设计食物评分系统&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;设计一个支持下述操作的食物评分</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="哈希表" scheme="http://malone-ai.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>动态规划二</title>
    <link href="http://malone-ai.github.io/2025/02/27/dp2/"/>
    <id>http://malone-ai.github.io/2025/02/27/dp2/</id>
    <published>2025-02-27T14:47:25.000Z</published>
    <updated>2025-03-01T04:39:05.588Z</updated>
    
    <content type="html"><![CDATA[<p>今日继续动态规划，先来道简单题练练手<a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a>。</p><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre><code>F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre><p>给定 n ，请计算 F(n) 。</p><p>这道题我称之为递归入门题目，但是在DP里也算入门级吧。</p><h1>跟着灵茶山艾府学DP</h1><p>接下来，学习学习灵茶山艾府出品的<a href="https://www.bilibili.com/video/BV1Xj411K7oF/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">动态规划入门：从记忆化搜索到递推【基础算法精讲 17】</a>（视频链接为B站UP主灵茶山艾府出品，点击即可跳转视频）。</p><p>UP主指出，动态规划的核心：</p><ul><li>状态定义</li><li>状态转移方程</li></ul><p>UP主要是通过Leetcode上的一道题目<a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍</a>来进行讲解的。</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><pre><code>输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p>示例 2：</p><pre><code>输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><h2 id="灵茶山艾府的思路">灵茶山艾府的思路</h2><h3 id="递归">递归</h3><p>先把它看成一道回溯题，把一个大问题变成规模更小的子问题，从第一个房子或者最后一个房子开始思考，因为他们收到的约束最少。比如考虑最后一个房子选还是不选：</p><ul><li>如果不选，那么问题就变成n-1个房子的问题</li><li>如果选，就变成n-2个房子的问题<br>不断这样思考下去可以得到一棵搜索树：</li></ul><p><img src="/images/dp2.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><p>注意一点，图中每个节点的数字代表第几个房子，4就是第四个房子。</p><p>灵茶山艾府提出了回溯三问：</p><ol><li>当前操作？是枚举<code>第</code>i个房子选/不选</li><li>子问题？是<code>前</code>i个房子中得到的最大金额和</li><li>下一个子问题？需要分类讨论：<ul><li>不选：从<code>前</code>i-1个房子得到的最大金额和</li><li>选：从<code>前</code>i-2个房子得到的最大金额和<br>最终得到以下实现：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>), nums[i] + <span class="built_in">dfs</span>(i<span class="number">-2</span>));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="记忆化搜索">记忆化搜索</h3><p>上述代码类似于回溯，时间复杂度是指数级别的，会超时。如何优化？灵茶山艾府引导我们回去看之前的那颗搜索树。观察搜索树我们会发现，有两个包含节点2的子树，并且这两个子树是相同的。也就是说dfs(2)算了两次，但它们的结果是一样，干脆在第一次计算时就把计算结果存到一个cache数组或者哈希表里。</p><p><img src="/images/dp2_2.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><p>优化后的搜索树如下，可以看到这棵搜索树只有O(n)个节点，时间复杂度也优化到了O(n)。</p><p><img src="/images/dp2_3.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> memo[i];</span><br><span class="line">            memo[i] = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>), nums[i] + <span class="built_in">dfs</span>(i<span class="number">-2</span>));</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums, memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(dfs(i-<span class="number">1</span>), dfs(i-<span class="number">2</span>) + nums[i]);</span><br><span class="line">        memo[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度如何计算呢？有公式：</p><ul><li>状态数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">×</span></span></span></span>单个状态所需要的计算时间<br>本题状态个数是O(n)，单个状态的计算时间是O(1)，所以时间复杂度为O(n)。空间复杂度为O(n)。</li></ul><h3 id="递推">递推</h3><p>有没有办法把空间复杂度优化到O(1)呢？递归的递即调用函数，归即return。</p><p>再回头看上面那张图，这里为了避免来回翻，再在这里附上。</p><p><img src="/images/dp2_3.png" alt=""></p><p>注：图片来源于上述所提B站视频中</p><p>这里计算max发生在dfs调用结束之后，也就是在递归的“归”的过程中才发生了实际的max计算。0和1归到2，2和1归到3，3和2归到4，那既然我们知道要从哪些点归到哪个点，那么干脆去掉递归中的“递”，只留下“归”的过程，也就是从最下面开始往上计算。这被灵茶山艾府称作“递推”。</p><pre><code>自顶向下算 = 记忆化搜索自底向上算 = 递推</code></pre><p>上述应该是UP主灵茶山艾府提出的概念了，仔细详细感觉很有道理😁。</p><p>如何将记忆化搜索改成递推？灵茶山艾府总结如下：</p><ol><li>dfs -&gt; f数组</li><li>递归 -&gt; 循环</li><li>递归边界 -&gt; 数组初始值</li></ol><p>原来的递归为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-2</span>) + nums[i]);</span><br></pre></td></tr></table></figure><p>基于上述方法很容易将递归修改成递推，但是需要对i = 0和i = 1的情况特殊处理（因为会产生负数下标）。</p><p>为了避免产生负数下标，可以把i改成从2开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i] = <span class="built_in">max</span>(f[i<span class="number">-1</span>], f[i<span class="number">-2</span>] + nums[i]);</span><br></pre></td></tr></table></figure><p>也可以把三处i都+2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+2</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>], f[i] + nums[i]);</span><br></pre></td></tr></table></figure><p>最终得到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            f[i<span class="number">+2</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>], f[i] + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * f = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n + <span class="number">2</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        f[i+<span class="number">2</span>] = MAX(f[i+<span class="number">1</span>], f[i] + nums[i]);</span><br><span class="line">    <span class="keyword">return</span> f[n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            f[i+<span class="number">2</span>] = Math.max(f[i+<span class="number">1</span>], f[i] + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> f[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递推的代码空间复杂度仍然为O(n)，但是结合一开始的<a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a>，应该不难想到如何空间优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f1 = <span class="number">0</span>, f2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">max</span>(f1, f2 + nums[i]);</span><br><span class="line">            f2 = f1;</span><br><span class="line">            f1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">0</span>, f2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cur = MAX(f1, f2 + nums[i]);</span><br><span class="line">        f2 = f1;</span><br><span class="line">        f1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>, f2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(f1, f2 + nums[i]);</span><br><span class="line">            f2 = f1;</span><br><span class="line">            f1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日继续动态规划，先来道简单题练练手&lt;a href=&quot;https://leetcode.cn/problems/fibonacci-number/description/&quot;&gt;509. 斐波那契数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;斐波那契数 （通常用 F(n) 表示）形成的序列称为 </summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>malloc、free 和 new、delete 的区别</title>
    <link href="http://malone-ai.github.io/2025/02/27/cpp-interview1/"/>
    <id>http://malone-ai.github.io/2025/02/27/cpp-interview1/</id>
    <published>2025-02-27T13:51:24.000Z</published>
    <updated>2025-02-27T14:29:52.279Z</updated>
    
    <content type="html"><![CDATA[<p>malloc 和 free 是C语言的库函数， new 和 delete 是 C++ 里的操作符。谈到区别就要去讨论共同点与不同点，尤其要关注他们之间的差异。</p><h1>new 和 malloc</h1><ol><li>new 自动计算所需分配的内存大小，malloc需要手动计算。</li><li>返回值不同，new的返回值为对象类型的指针，而malloc返回的是<code>void*</code>类型的指针（使用malloc往往需要手动进行类型转换）。</li><li>new 分配失败时抛出异常std::bad_alloc，而malloc分配失败则返回NULL。</li><li>new 是free store上分配内存，而malloc是在堆上或者文件映射区。</li><li>new 分配的内存一般是初始化过的，malloc分配的内存没有经过初始化。</li></ol><h2 id="new-的工作过程">new 的工作过程</h2><ol><li>使用new操作符时，先调用operator new（这个可以重载）</li><li>然后申请所需的空间</li><li>最后调用构造函数，初始化成员变量</li></ol><h2 id="malloc">malloc</h2><ol><li>malloc分配的虚拟内存</li><li>malloc当分配的内存小于128K字节时通过brk系统调用在堆上分配内存，当超过128K字节时通过mmap系统调用在文件映射区分配内存</li></ol><h1>delete 和 free</h1><ol><li>delete 需要对象类型的指针，free 不需要关注需要释放对象的类型<ul><li>delete需要调用对应的析构函数，擦除类型delete就不知道调用什么析构函数了。</li></ul></li></ol><h2 id="delete-工作过程">delete 工作过程</h2><ol><li>先调用析构函数</li><li>再调用operator delete（也可以进行重载）</li><li>释放空间</li></ol><h2 id="free是如何知道要释放多大的空间">free是如何知道要释放多大的空间</h2><p>malloc分配内存的时候，事实上多分配了16字节的空间(16 + mem)，返回值返回mem的首地址。free的时候，就会向左偏移16字节，这16字节的空间存储了内存块的描述信息，包含mem的大小。free就是通过这种方式来获取要释放的空间大小，并且正因为此，free释放时无需关注所需释放对象的类型。</p><h2 id="free释放内存后，这块内存还在吗">free释放内存后，这块内存还在吗</h2><ul><li>如果内存块是通过brk系统调用获得的，内存管理器会将这块内存插入到其维护的<code>空闲链表</code>或<code>空闲内存池</code>中，以便在后续的内存分配请求中复用。</li><li>如果是通过mmap系统调用获得的，这块内存会归还给操作系统。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;malloc 和 free 是C语言的库函数， new 和 delete 是 C++ 里的操作符。谈到区别就要去讨论共同点与不同点，尤其要关注他们之间的差异。&lt;/p&gt;
&lt;h1&gt;new 和 malloc&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;new 自动计算所需分配的内存大小，mall</summary>
      
    
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十八：2296. 设计一个文本编辑器</title>
    <link href="http://malone-ai.github.io/2025/02/27/leetcode28/"/>
    <id>http://malone-ai.github.io/2025/02/27/leetcode28/</id>
    <published>2025-02-27T12:08:38.000Z</published>
    <updated>2025-02-27T12:14:07.054Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/design-a-text-editor/description/">2296. 设计一个文本编辑器</a>。</p><p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p><ul><li>添加：在光标所在处添加文本。</li><li>删除：在光标所在处删除文本（模拟键盘的删除键）。</li><li>移动：将光标往左或者往右移动。</li></ul><p>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候 0 &lt;= cursor.position &lt;= currentText.length 都成立。</p><p>请你实现 TextEditor 类：</p><ul><li>TextEditor() 用空文本初始化对象。</li><li>void addText(string text) 将 text 添加到光标所在位置。添加完后光标在 text 的右边。</li><li>int deleteText(int k) 删除光标左边 k 个字符。返回实际删除的字符数目。</li><li>string cursorLeft(int k) 将光标向左移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。</li><li>string cursorRight(int k) 将光标向右移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。</li></ul><p>最近真的是头大，Leetcode的每日一题怎么这几天一直搞这种设计题，苦不堪言。</p><p>解法参考Leetcode官方的解法，一开始准备使用双向链表的做法，但是发现第二种做法——使用栈来实现貌似更加简单，就是用了栈来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_len 1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *left;</span><br><span class="line">    <span class="type">char</span> *right;</span><br><span class="line">    <span class="type">int</span> leftSize;</span><br><span class="line">    <span class="type">int</span> rightSize;</span><br><span class="line">&#125; TextEditor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextEditor* <span class="title function_">textEditorCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    TextEditor *obj = (TextEditor*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TextEditor));</span><br><span class="line">    obj-&gt;left = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * max_len);</span><br><span class="line">    obj-&gt;right = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * max_len);</span><br><span class="line">    obj-&gt;leftSize = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;rightSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">textEditorAddText</span><span class="params">(TextEditor* obj, <span class="type">char</span>* text)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*text) &#123;</span><br><span class="line">        obj-&gt;left[obj-&gt;leftSize++] = *text;</span><br><span class="line">        ++text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">textEditorDeleteText</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;leftSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;left[--obj-&gt;leftSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        --k;</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">textEditorCursorLeft</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;leftSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;right[obj-&gt;rightSize++] = obj-&gt;left[--obj-&gt;leftSize];</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> retLen = MIN(<span class="number">10</span>, obj-&gt;leftSize);</span><br><span class="line">    <span class="type">char</span> * ret = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (retLen + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; retLen; ++i) </span><br><span class="line">        ret[i] = obj-&gt;left[obj-&gt;leftSize-retLen+i];</span><br><span class="line">    ret[retLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">textEditorCursorRight</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;rightSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;left[obj-&gt;leftSize++] = obj-&gt;right[--obj-&gt;rightSize];</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> retLen = MIN(<span class="number">10</span>, obj-&gt;leftSize);</span><br><span class="line">    <span class="type">char</span> * ret = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (retLen + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; retLen; ++i) </span><br><span class="line">        ret[i] = obj-&gt;left[obj-&gt;leftSize-retLen+i];</span><br><span class="line">    ret[retLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">textEditorFree</span><span class="params">(TextEditor* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;left) </span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;right) </span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor* obj = textEditorCreate();</span></span><br><span class="line"><span class="comment"> * textEditorAddText(obj, text);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = textEditorDeleteText(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * char* param_3 = textEditorCursorLeft(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * char* param_4 = textEditorCursorRight(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * textEditorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-a-text-editor/description/&quot;&gt;2296. 设计一个文本编辑器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;请你设计一个带光标的文本编辑器，它可以实</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="栈" scheme="http://malone-ai.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>动态规划一</title>
    <link href="http://malone-ai.github.io/2025/02/26/dp1/"/>
    <id>http://malone-ai.github.io/2025/02/26/dp1/</id>
    <published>2025-02-26T13:29:02.000Z</published>
    <updated>2025-02-27T14:47:44.953Z</updated>
    
    <content type="html"><![CDATA[<p>开启一个动态规划专栏，跟着灵茶山艾府学习一下动态规划，将动态规划按在地上摩擦。<a href="https://leetcode.cn/circle/discuss/tXLS3i/"><br>分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化）</a>。</p><p>题目为<a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a>。</p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><ul><li>输入：n = 2</li><li>输出：2</li><li>解释：有两种方法可以爬到楼顶。<ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol></li></ul><p>示例 2：</p><ul><li>输入：n = 3</li><li>输出：3</li><li>解释：有三种方法可以爬到楼顶。<ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></li></ul><h1>基本思路</h1><p>n = 1时有1种方法，n = 2时有2种方法；从第 3 阶开始，每一阶的爬法数等于前一阶的爬法数加上前两阶的爬法数，即 arr[i] = arr[i-1] + arr[i-2]。最终返回 arr[n]，即第 n 阶的爬法数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> * arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> * arr = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码虽然可以正确求解，但是存在一些问题：</p><ol><li>内存泄漏<ul><li>使用 malloc 分配的内存没有释放，会导致内存泄漏。</li></ul></li><li>空间复杂度优化<ul><li>使用数组存储所有阶的爬法数，空间复杂度为 O(n)，但实际上只需要前两个值即可，可以优化为 O(1) 的空间复杂度。<br>经优化获得如下实现：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cur = pre1 + pre2;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开启一个动态规划专栏，跟着灵茶山艾府学习一下动态规划，将动态规划按在地上摩擦。&lt;a href=&quot;https://leetcode.cn/circle/discuss/tXLS3i/&quot;&gt;&lt;br&gt;
分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十六：2502. 设计内存分配器</title>
    <link href="http://malone-ai.github.io/2025/02/25/leetcode26/"/>
    <id>http://malone-ai.github.io/2025/02/25/leetcode26/</id>
    <published>2025-02-25T07:23:34.000Z</published>
    <updated>2025-02-25T08:59:14.235Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/design-memory-allocator/description/">2502. 设计内存分配器</a>。</p><p>给你一个整数 n ，表示下标从 0 开始的内存数组的大小。所有内存单元开始都是空闲的。</p><p>请你设计一个具备以下功能的内存分配器：</p><p>分配 一块大小为 size 的连续空闲内存单元并赋 id <code>mID</code> 。<br>释放 给定 id <code>mID</code> 对应的所有内存单元。<br>注意：</p><p>多个块可以被分配到同一个 mID 。<br>你必须释放<code>mID</code>对应的所有内存单元，即便这些内存单元被分配在不同的块中。<br>实现<code>Allocator</code>类：</p><p>Allocator(int n) 使用一个大小为 n 的内存数组初始化 Allocator 对象。<br>int allocate(int size, int mID) 找出大小为 size 个连续空闲内存单元且位于最左侧的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 -1 。<br>int freeMemory(int mID) 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</p><h1>分析理解</h1><p>题目要求实现一个内存管理单元。</p><p>函数allocate有两个参数：size和mID，size即需要找到size个内存块并且这些内存块得是连续的，mID即这些内存块得被赋值为mID。这个函数的返回值为这些内存块的首地址即下标索引。</p><p>函数freeMemory有一个参数mID，实现的功能为将所有内存单元中值为mID的单元释放，然后返回释放的内存单元的个数。</p><h1>基本思路</h1><p>我的第一想法是通过链表来进行组织这些内存块，然后通过哈希表、二维数组等记录未使用的内存块的数量和大小等。但是一直苦于将内存块按照大小进行排序这件事儿，感觉这么做将事情反而复杂化了，并且使用链表貌似也有点多余了。</p><p>最后看了看<a href="https://leetcode.cn/problems/design-memory-allocator/solutions/2016010/bao-li-mo-ni-by-endlesscheng-bqba/?envType=daily-question&amp;envId=2025-02-25">灵茶山艾府的题解</a>。他提供了两种方法：</p><ul><li>模拟</li><li>线段树</li></ul><p>看了看两种方法，感觉使用他的模拟解法就足够了。</p><p>基本思路是使用数组来组织内存块，在分配内存块时，并且全部初始化为0，表示内存块未使用（题目限定mID的取值范围为[1, 1000]）。然后从头开始遍历，寻找到一块大小为size的连续内存块，找不到则返回-1。回收内存块就更简单了，遍历所有内存块，内存块值为mID的均释放并设为0，并使用count进行计数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *mem;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Allocator</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span> ) * n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">this</span>-&gt;mem[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">allocate</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span> (count == size) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i - count + <span class="number">1</span>; j &lt; i + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    mem[j] = mID;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i - count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">freeMemory</span><span class="params">(<span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] == mID) &#123;</span><br><span class="line">                mem[i] = <span class="number">0</span>;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Allocator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Allocator* obj = new Allocator(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;allocate(size,mID);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;freeMemory(mID);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> * mem;</span><br><span class="line">    <span class="type">int</span> n;    </span><br><span class="line">&#125; Allocator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Allocator* <span class="title function_">allocatorCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Allocator * obj = (Allocator *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Allocator));</span><br><span class="line">    obj-&gt;mem = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    obj-&gt;n = n;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">allocatorAllocate</span><span class="params">(Allocator* obj, <span class="type">int</span> size, <span class="type">int</span> mID)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *mem = obj-&gt;mem;</span><br><span class="line">    <span class="type">int</span> n = obj-&gt;n;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">if</span> (count == size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - count + <span class="number">1</span>; j &lt; i + <span class="number">1</span>; ++j)</span><br><span class="line">                mem[j] = mID;</span><br><span class="line">            <span class="keyword">return</span> i - count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">allocatorFreeMemory</span><span class="params">(Allocator* obj, <span class="type">int</span> mID)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * mem = obj-&gt;mem;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = obj-&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i] == mID) &#123;</span><br><span class="line">            mem[i] = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocatorFree</span><span class="params">(Allocator* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;mem);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Allocator struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Allocator* obj = allocatorCreate(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = allocatorAllocate(obj, size, mID);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = allocatorFreeMemory(obj, mID);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * allocatorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>分配和释放内存函数的时间复杂度均为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-memory-allocator/description/&quot;&gt;2502. 设计内存分配器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给你一个整数 n ，表示下标从 0 开</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十五：1656. 设计有序流</title>
    <link href="http://malone-ai.github.io/2025/02/24/leetcode25/"/>
    <id>http://malone-ai.github.io/2025/02/24/leetcode25/</id>
    <published>2025-02-24T04:36:06.000Z</published>
    <updated>2025-02-26T13:40:27.210Z</updated>
    
    <content type="html"><![CDATA[<p>今日的 Leetcode 每日一题为<a href="https://leetcode.cn/problems/design-an-ordered-stream/description/">1656. 设计有序流</a>。</p><p>有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。</p><p>设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。</p><p>实现 OrderedStream 类：</p><ul><li>OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。</li><li>String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后：<ul><li>如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个  id + 1 。</li><li>否则，返回一个空列表。</li></ul></li></ul><h1>官方题解</h1><p>这道题采用了官方题解，解释的还是比较清楚的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> **stream;</span><br><span class="line">    <span class="type">int</span> streamSize;</span><br><span class="line">    <span class="type">int</span> ptr;</span><br><span class="line">&#125; OrderedStream;</span><br><span class="line"></span><br><span class="line">OrderedStream* <span class="title function_">orderedStreamCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    OrderedStream *obj = (OrderedStream *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OrderedStream));</span><br><span class="line">    obj-&gt;stream = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        obj-&gt;stream[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;streamSize = n + <span class="number">1</span>;</span><br><span class="line">    obj-&gt;ptr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ** <span class="title function_">orderedStreamInsert</span><span class="params">(OrderedStream* obj, <span class="type">int</span> idKey, <span class="type">char</span> * value, <span class="type">int</span>* retSize)</span> &#123;</span><br><span class="line">    obj-&gt;stream[idKey] = value;</span><br><span class="line">    <span class="type">char</span> **res = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * obj-&gt;streamSize);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;ptr &lt; obj-&gt;streamSize &amp;&amp; obj-&gt;stream[obj-&gt;ptr]) &#123;</span><br><span class="line">        res[pos++] = obj-&gt;stream[obj-&gt;ptr];</span><br><span class="line">        obj-&gt;ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    *retSize = pos;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">orderedStreamFree</span><span class="params">(OrderedStream* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;stream);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-an-ordered-stream/solutions/1749068/she-ji-you-xu-liu-by-leetcode-solution-3imb/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1>对官方题解进行改善</h1><p>感觉官方将C语言实现里的insert函数中的res内嵌到结构体里比较好，大小与流的大小相同，这样就不必反复分配内存，以及后续忘记释放了。一下是我进行了改进的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> **str;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ptr;</span><br><span class="line">    <span class="type">char</span> **buffer; </span><br><span class="line">&#125; OrderedStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OrderedStream* <span class="title function_">orderedStreamCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    OrderedStream* obj = (OrderedStream*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OrderedStream));</span><br><span class="line">    obj-&gt;str = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">        obj-&gt;str[i] = <span class="literal">NULL</span>;</span><br><span class="line">    obj-&gt;n = n;</span><br><span class="line">    obj-&gt;ptr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配缓冲区大小</span></span><br><span class="line">    obj-&gt;buffer = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * n);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** <span class="title function_">orderedStreamInsert</span><span class="params">(OrderedStream* obj, <span class="type">int</span> idKey, <span class="type">char</span>* value, <span class="type">int</span>* retSize)</span> &#123;</span><br><span class="line">    obj-&gt;str[idKey] = value;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;ptr &lt;= obj-&gt;n &amp;&amp; obj-&gt;str[obj-&gt;ptr])</span><br><span class="line">        obj-&gt;buffer[pos++] = obj-&gt;str[obj-&gt;ptr++];</span><br><span class="line">    *retSize = pos;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">orderedStreamFree</span><span class="params">(OrderedStream* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;str);</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;buffer);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your OrderedStream struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * OrderedStream* obj = orderedStreamCreate(n);</span></span><br><span class="line"><span class="comment"> * char** param_1 = orderedStreamInsert(obj, idKey, value, retSize);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * orderedStreamFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的 Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-an-ordered-stream/description/&quot;&gt;1656. 设计有序流&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;有 n 个 (id, value) </summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="数据流" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十四：1206. 设计跳表</title>
    <link href="http://malone-ai.github.io/2025/02/23/leetcode24/"/>
    <id>http://malone-ai.github.io/2025/02/23/leetcode24/</id>
    <published>2025-02-23T02:41:38.000Z</published>
    <updated>2025-02-26T12:46:51.987Z</updated>
    
    <content type="html"><![CDATA[<p>今日 Leetcode 每日一题为<a href="https://leetcode.cn/problems/design-skiplist/description/">1206. 设计跳表</a>。</p><p>不使用任何库函数，设计一个 跳表 。</p><p>跳表是在<code>O(log n)</code>时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：<br><img src="/images/1702370216-mKQcTt-1506_skiplist.gif" alt=""><br>注：图片来源于Leetcode <a href="https://leetcode.cn/problems/design-skiplist/description/">https://leetcode.cn/problems/design-skiplist/description/</a></p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>了解更多 : <a href="https://oi-wiki.org/ds/skiplist/">https://oi-wiki.org/ds/skiplist/</a></p><p>在本题中，你的设计应该要包含这些函数：</p><ul><li>bool search(int target) : 返回target是否存在于跳表中。</li><li>void add(int num): 插入一个元素到跳表。</li><li>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。</li></ul><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><h1>分析理解</h1><p>这道题目让我们设计一个数据结构——跳表。在这之前确实不怎么了解跳表，仔细看了一会儿发现跳表和链表有点像，但是跳表应该说是一个多层链表。其中第0层是包含所有元素的有序链表；1层及以上，每一层都是下一层的子集，作为索引层，帮助快速跳过多个元素。每一层的元素通过指针连接，高层元素会指向低层的相同元素，形成一个“跳跃”的结构。</p><p>跳表有三个核心操作：</p><ol><li>查找</li><li>插入</li><li>删除</li></ol><p>跳表的应用还挺广泛的，Redis的有序集合（Sorted Set）底层就使用了跳表。</p><p>跳表可以实现操作复杂度为O(log n)的查找、插入和删除，还是挺高效的。谈一谈个人对这的理解吧。不管跳表还是链表，都离不开查找、插入和删除三个核心操作，而私以为插入和删除都是基于查找操作的，只要查找得快，插入和删除得也就快。</p><p>链表查找的时候，最坏的情况下是O(n)，就是遍历了整个表。而跳表作为多层链表，可以跳过遍历某些元素，从而加快查找速度，举个简单的例子。</p><p>假设我们要在跳表中查找值 7，跳表的结构如下：</p><ul><li>第2层（最高层）：1 -&gt; 9</li><li>第1层：1 -&gt; 5 -&gt; 9</li><li>第0层（底层）：1 -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 9</li></ul><p>查找过程：</p><ol><li>从最高层（第2层）开始：<ul><li>当前节点是 1，下一个节点是 9。</li><li>9 大于 7，所以不能直接跳到 9，而是向下移动到第1层。</li></ul></li><li>在第1层：<ul><li>当前节点是 1，下一个节点是 5。</li><li>5 小于 7，所以跳到 5。</li><li>从 5 开始，下一个节点是 9。</li><li>9 大于 7，所以向下移动到第0层。</li></ul></li><li>在第0层：<ul><li>当前节点是 5，下一个节点是 7。</li><li>7 等于目标值，查找成功。</li></ul></li></ol><p>基于上述过程可以大概了解跳表的查询过程，可以看到跳表在查询7的时候跳过了对3的遍历。这个例子或许并不能很好地体现跳表的高效，但是在规模较大时，会跳过对很多元素的遍历，产生较好的效果。</p><p>此外，还有一点。跳表依赖于随机算法。在最坏的情况下会退化成单层有序链表。因此随机算法的选择很重要。</p><h1>基本思路</h1><p>这道题我是一点思路都没有，研究了许久官方题解中的C语言实现。一直感觉C语言是不错的语言，虽然有诸多的不便，没有面向对象，没有类似于C++的模板。但是也不可否认C语言的精妙。所以，基本思路：抄！doge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> P_FACTOR = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SkiplistNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;SkiplistNode *&gt; forward;</span><br><span class="line">    <span class="built_in">SkiplistNode</span>(<span class="type">int</span> _val, <span class="type">int</span> _maxLevel = MAX_LEVEL) : <span class="built_in">val</span>(_val), forward(_maxLevel, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SkiplistNode * head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    mt19937 gen&#123;random_device&#123;&#125;()&#125;;</span><br><span class="line">    uniform_real_distribution&lt;<span class="type">double</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Skiplist</span>(): <span class="built_in">head</span>(<span class="keyword">new</span> <span class="built_in">SkiplistNode</span>(<span class="number">-1</span>)), <span class="built_in">level</span>(<span class="number">0</span>), <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 target 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">        <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;SkiplistNode *&gt; <span class="title">update</span><span class="params">(MAX_LEVEL, head)</span></span>;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lv = <span class="built_in">randomLevel</span>();</span><br><span class="line">        level = <span class="built_in">max</span>(level, lv);</span><br><span class="line">        SkiplistNode *newNode = <span class="keyword">new</span> <span class="built_in">SkiplistNode</span>(num, lv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">            <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">            newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">            update[i]-&gt;forward[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;SkiplistNode *&gt; <span class="title">update</span><span class="params">(MAX_LEVEL, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* 如果值不存在则返回 false */</span></span><br><span class="line">        <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span></span><br><span class="line">            update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="comment">/* 更新当前的 level */</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head-&gt;forward[level - <span class="number">1</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dis</span>(gen) &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;</span><br><span class="line">            lv++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-skiplist/solutions/1696545/she-ji-tiao-biao-by-leetcode-solution-e8yh/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P_FACTOR = RAND_MAX &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> maxLevel;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> **<span class="title">forward</span>;</span></span><br><span class="line">&#125; SkiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SkiplistNode *head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; Skiplist;</span><br><span class="line"></span><br><span class="line">SkiplistNode *<span class="title function_">skiplistNodeCreat</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> maxLevel)</span> &#123;</span><br><span class="line">    SkiplistNode *obj = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode));</span><br><span class="line">    obj-&gt;val = val;</span><br><span class="line">    obj-&gt;maxLevel = maxLevel;</span><br><span class="line">    obj-&gt;forward = (SkiplistNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode *) * maxLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLevel; i++) &#123;</span><br><span class="line">        obj-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeFree</span><span class="params">(SkiplistNode* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;forward) &#123;</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;forward);</span><br><span class="line">        obj-&gt;forward = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;maxLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *obj = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Skiplist));</span><br><span class="line">    obj-&gt;head = skiplistNodeCreat(<span class="number">-1</span>, MAX_LEVEL);</span><br><span class="line">    obj-&gt;level = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SkiplistNode * curr = obj-&gt;head; curr; ) &#123;</span><br><span class="line">        SkiplistNode *prev = curr;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        skiplistNodeFree(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">    <span class="keyword">while</span> (rand() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;</span><br><span class="line">        lv++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 target 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">    <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lv = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; i++) &#123;</span><br><span class="line">            update[i] = obj-&gt;head;</span><br><span class="line">        &#125;</span><br><span class="line">        obj-&gt;level = lv;</span><br><span class="line">    &#125;</span><br><span class="line">    SkiplistNode *newNode = skiplistNodeCreat(num, lv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">        newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 如果值不存在则返回 false */</span></span><br><span class="line">    <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span></span><br><span class="line">        update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    skiplistNodeFree(curr);</span><br><span class="line">    <span class="comment">/* 更新当前的 level */</span></span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        obj-&gt;level--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-skiplist/solutions/1696545/she-ji-tiao-biao-by-leetcode-solution-e8yh/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>我主要围绕着C语言的实现进行一下理解，便于日后复习。理解了C语言版本，C++版本也就不难了。</p><h2 id="代码理解">代码理解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P_FACTOR = RAND_MAX &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>首先定义了两个常量MAX_LEVEL和P_FACTOR。MAX_LEVEL是跳表的最大层数，而P_FACTOR是一个概率，这里称它为概率或许有点牵强，结合着函数randomLevel应该就不难理解了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">    <span class="keyword">while</span> (rand() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) </span><br><span class="line">        lv++;</span><br><span class="line">    <span class="keyword">return</span> lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数randomLevel是一个静态的内联函数，由关键字<code>static</code>和<code>inline</code>标识。</p><h3 id="static关键字"><code>static</code>关键字</h3><p><code>static</code>将函数的作用域限制在当前文件内，其他文件无法访问这个函数。这里使用static关键字标识这个函数有以下好处：</p><ol><li>避免命名冲突<ul><li>如果其他文件中也定义了同名的 randomLevel 函数，链接时会发生冲突。</li><li>使用 static 可以确保这个函数只在当前文件中可见，避免冲突。</li></ul></li><li>封装性<ul><li>randomLevel 是跳表内部使用的辅助函数，不需要暴露给外部。</li></ul></li></ol><h3 id="inline关键字"><code>inline</code>关键字</h3><p><code>inline</code>关键字将函数标识为<code>内联函数</code>，提示编译器将函数内联展开，即将函数的代码直接插入到调用处，而不是通过函数调用的方式执行。使用<code>inline</code>关键字有以下好处：</p><ol><li>减少函数调用开销<ul><li>函数调用需要保存上下文、跳转到函数地址、执行完后再返回，这些操作有一定的开销。</li><li>randomLevel 是一个简单的函数，内联展开可以避免这些开销，提高性能。</li></ul></li><li>适合小型函数<ul><li>randomLevel 的逻辑非常简单（只是一个循环），适合内联展开。</li><li>如果函数体较大，内联可能会导致代码膨胀，反而降低性能。所以说不是所有的函数都适合作内联声明。</li></ul></li><li>编译器优化<ul><li>inline 是对编译器的建议，编译器可以选择是否真正内联展开。</li></ul></li></ol><h3 id="randomLevel-函数">randomLevel 函数</h3><p>randomLevel函数的作用是生成一个随机数，随机数的区间为[1, MAX_LEVEL]即[1, 32]。lv从1开始，每次以25%的概率递增。为什么是25%呢？这就得看开头的静态常量P_FACTOR，P_FACTOR = RAND_MAX &gt;&gt; 2。RAND_MAX为rand函数能生成的随机数的最大值，然后右移两位，也就是除以4。rand能生成的随机数区间为[1, RAND_MAX]，当生成的随机数小于P_FACTOR即RAND_MAX / 4时进行递增。生成的随机数小于P_FACTOR的区间占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，大于P_FACTOR的区间占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>3</mn></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，这也不难理解为什么是25%概率。还有就是随机数的生成需要初始化随机数种子，这一步在跳表的创建中通过<code>srand(time(NULL))</code>实现了。</p><h3 id="跳表有关结构体">跳表有关结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> maxLevel;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> **<span class="title">forward</span>;</span></span><br><span class="line">&#125; SkiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SkiplistNode *head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; Skiplist;</span><br></pre></td></tr></table></figure><p>类似于链表，其中SkiplistNode是跳表中<code>节点的定义</code>，Skiplist是<code>跳表的定义</code>。</p><p><code>SkiplistNode</code>结构体内val代表节点存储的值，maxLevel为该节点的最大层数。需要注意的是如果某个节点的maxLevel值为4，那么说明该节点存在于第0、1、2、3层。结构体内的forward是一个指针数组，而forward[i]指向该节点在第i层的下一个节点。</p><p><code>Skiplist</code>结构体，个人感觉不用它也可以，但是使用后方便管理，主要是方便参数的地址传递。这样每次只需要将Skiplist类型的指针传递给函数即可，否则既要传指向*head的指针，又要传指向level的指针，实属不方便。还需要注意的一点是level的值，它其实是跳表中所有节点中maxLevel值最大的那一个。</p><h3 id="跳表节点的创建">跳表节点的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *<span class="title function_">skiplistNodeCreat</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> maxLevel)</span> &#123;</span><br><span class="line">    SkiplistNode *obj = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode));</span><br><span class="line">    obj-&gt;val = val;</span><br><span class="line">    obj-&gt;maxLevel = maxLevel;</span><br><span class="line">    obj-&gt;forward = (SkiplistNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode *) * maxLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLevel; i++) </span><br><span class="line">        obj-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很好理解，就是为跳表节点分配内存，初始化跳表节点中的val、maxLevel，为跳表节点的指针数组forward分配内存，并将所有的成员指向NULL。</p><h3 id="跳表节点的释放">跳表节点的释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeFree</span><span class="params">(SkiplistNode* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;forward) &#123;</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;forward);</span><br><span class="line">        obj-&gt;forward = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;maxLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了跳表节点的创建，那么释放也不难理解，相当于将创建节点时所做的事儿反过来做一遍。释放forward（在释放前先检查其是否为NULL，避免反复释放），释放跳表节点所占用内存。</p><h3 id="跳表的创建与释放">跳表的创建与释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *obj = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Skiplist));</span><br><span class="line">    obj-&gt;head = skiplistNodeCreat(<span class="number">-1</span>, MAX_LEVEL);</span><br><span class="line">    obj-&gt;level = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SkiplistNode * curr = obj-&gt;head; curr; ) &#123;</span><br><span class="line">        SkiplistNode *prev = curr;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        skiplistNodeFree(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块也类似于跳表节点的创建与释放，不再赘述。</p><h3 id="跳表的搜索">跳表的搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target)</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">    <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回target是否存在于跳表中，存在返回true，否则返回false。</p><p>我开始看到这段代码是大写的懵逼，调试了一会儿才明白是怎么个事儿。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target)</span><br><span class="line">        curr = curr-&gt;forward[i];</span><br></pre></td></tr></table></figure><p>理解了这段循环体应该就差不多了。还要强调的一点是跳表的头节点存在于每一层。</p><p>从跳表的最高层开始遍历，在每层定位到最后一个小于target的节点，就向下移动一层。当遍历到最后一层时，就找到了最底层最后一个小于target的节点，它的下一个节点很有可能就是目标节点。使用<code>cur = cur-&gt;forward[0]</code>让cur指向该节点，检查其是否为NULL，不为NULL就再检查节点的值是否为target即可。</p><p>查找过程是从最高层开始，逐层向下查找目标值。</p><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *curr = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>curr 指向跳表的头节点。</li></ul><ol start="2"><li>从最高层开始查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br></pre></td></tr></table></figure><ul><li>obj-&gt;level 是跳表当前的最大层数。</li><li>从最高层（obj-&gt;level - 1）开始，逐层向下查找。</li></ul><ol start="3"><li>在当前层向右查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) </span><br><span class="line">    curr = curr-&gt;forward[i];</span><br></pre></td></tr></table></figure><ul><li>curr-&gt;forward[i] 是当前节点在第 i 层的下一个节点。</li><li>如果下一个节点的值小于 target，则继续向右移动。</li><li>这个过程会跳过多个节点，快速接近目标值。</li></ul><ol start="4"><li>移动到下一层</li></ol><ul><li>当在当前层无法继续向右移动时，向下移动到下一层<code>（i--）</code>，继续查找。</li></ul><ol start="5"><li>最终定位到目标节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curr = curr-&gt;forward[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>查找结束后，curr 指向第0层中最后一个小于 target 的节点。</li><li>curr-&gt;forward[0] 是第0层中下一个节点，可能是目标节点。</li></ul><ol start="6"><li>检查是否找到目标值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>如果 curr-&gt;forward[0] 存在且值等于 target，则返回 true。</li><li>否则返回 false。</li></ul><h3 id="跳表中节点的添加">跳表中节点的添加</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lv = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; i++) &#123;</span><br><span class="line">            update[i] = obj-&gt;head;</span><br><span class="line">        &#125;</span><br><span class="line">        obj-&gt;level = lv;</span><br><span class="line">    &#125;</span><br><span class="line">    SkiplistNode *newNode = skiplistNodeCreat(num, lv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">        newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skiplistAdd 的作用是向跳表中插入一个值为 num 的节点。插入时需要：</p><ol><li>找到每一层中最后一个小于 num 的节点。</li><li>随机生成新节点的层数。</li><li>将新节点插入到每一层的正确位置。</li></ol><h4 id="插入过程">插入过程</h4><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">SkiplistNode *cur = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>update是一个指针数组，用于记录每一层中最后一个小于num的节点。</li><li>cur是当前节点，初始化为跳表的头节点。</li></ul><ol start="2"><li>查找插入位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;forward[i] &amp;&amp; cur-&gt;forward[i]-&gt;val &lt; num) </span><br><span class="line">        cur = cur-&gt;forward[i];</span><br><span class="line">    update[i] = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从最高处(<code>obj-&gt;level-1</code>)开始，逐层向下查找。</li><li>在每一层中，向右移动cur，直到找到最后一个小于num的节点。</li><li>将cur记录到update[i]，表示在第i层，应将新节点插入update[i]的后面。</li></ul><ol start="3"><li>随机生成新节点的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lv = randomLevel();</span><br></pre></td></tr></table></figure><ul><li>调用 randomLevel 函数，随机生成新节点的层数 lv。</li></ul><ol start="4"><li>更新跳表的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; ++i) </span><br><span class="line">        update[i] = obj-&gt;head;</span><br><span class="line">    obj-&gt;level = lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果新节点的层数lv大于跳表的层数obj-&gt;level，需要更新跳表的层数</li><li>对于新增的层（obj-&gt;level-1到lv-1），将update[i]初始化为头节点obj-&gt;head。</li><li>更新跳表的层数obj-&gt;level为lv。</li></ul><ol start="5"><li>创建新节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode * newNode = skiplistNodeCreate(num, lv);</span><br></pre></td></tr></table></figure><ul><li>调用 skiplistNodeCreate 函数，创建一个值为 num、层数为 lv 的新节点。</li></ul><ol start="6"><li>插入新节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; ++i) &#123;</span><br><span class="line">    newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">    update[i]-&gt;forward[i] = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历新节点的每一层（从第0层到第 lv - 1 层）：<ul><li>将新节点的 forward[i] 指向 update[i]-&gt;forward[i]。</li><li>将 update[i]-&gt;forward[i] 指向新节点。</li></ul></li></ul><p>这样，新节点就被插入到每一层的正确位置。</p><h3 id="跳表节点的删除">跳表节点的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    skiplistNodeFree(curr);</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        obj-&gt;level--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skiplistErase 的作用是从跳表中删除值为 num 的节点。如果节点存在并成功删除，返回 true；否则返回 false。</p><h4 id="删除过程">删除过程</h4><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">SkiplistNode *curr = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>update 数组用于记录每一层中需要更新的节点。</li><li>curr 指向跳表的头节点（head），用于遍历跳表</li></ul><ol start="2"><li>查找待删除节点的位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) </span><br><span class="line">        curr = curr-&gt;forward[i];</span><br><span class="line">    update[i] = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从最高层开始，逐层向下查找值为 num 的节点。</li><li>在每一层中，找到最后一个小于 num 的节点，并记录到 update[i] 中。</li><li>这个过程和 skiplistSearch 类似，目的是定位待删除节点的位置。</li></ul><ol start="3"><li>定位待删除节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">curr 现在指向第<span class="number">0</span>层中最后一个小于 num 的节点。</span><br></pre></td></tr></table></figure><ul><li>curr-&gt;forward[0] 是第0层中下一个节点，可能是待删除节点</li></ul><ol start="4"><li>检查节点是否存在</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!curr || curr-&gt;val != num) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>如果 curr-&gt;forward[0] 不存在，或者它的值不等于 num，说明节点不存在，返回 false。</li></ul><ol start="5"><li>更新每一层的指针</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历每一层，更新指向待删除节点的指针。</li><li>如果 update[i]-&gt;forward[i] 不等于 curr，说明在这一层中不需要更新（因为待删除节点不在这一层），并且是从底层向高层遍历的，所以后面的所有层也不需要更新，break退出。</li><li>否则，将 update[i]-&gt;forward[i] 指向 curr-&gt;forward[i]，跳过待删除节点。</li></ul><ol start="6"><li>释放待删除节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skiplistNodeFree(curr);</span><br></pre></td></tr></table></figure><p>调用 skiplistNodeFree 函数释放待删除节点的内存。</p><ol start="7"><li>更新跳表的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) </span><br><span class="line">    obj-&gt;level--;</span><br></pre></td></tr></table></figure><ul><li>如果删除节点后，某些层变为空（即头节点在这一层的下一个节点为 NULL），则降低跳表的层数。</li><li>这是为了确保跳表的层数不会过高，避免浪费空间。</li></ul><ol start="8"><li>返回结果</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>删除成功，返回 true。</li></ul><p>到此整个代码可算是理解完毕了QvQ。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日 Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-skiplist/description/&quot;&gt;1206. 设计跳表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不使用任何库函数，设计一个 跳表 。&lt;/p&gt;
&lt;p&gt;跳表是</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="链表" scheme="http://malone-ai.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="跳表" scheme="http://malone-ai.github.io/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十三：2506. 统计相似字符串对的数目</title>
    <link href="http://malone-ai.github.io/2025/02/22/leetcode23/"/>
    <id>http://malone-ai.github.io/2025/02/22/leetcode23/</id>
    <published>2025-02-22T11:22:26.000Z</published>
    <updated>2025-02-25T12:36:16.745Z</updated>
    
    <content type="html"><![CDATA[<p>今日 Leetcode 每日一题为<a href="https://leetcode.cn/problems/count-pairs-of-similar-strings/description/">2506. 统计相似字符串对的数目</a>。</p><p>给你一个下标从 0 开始的字符串数组 words 。</p><p>如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。</p><ul><li>例如，“abca” 和 “cba” 相似，因为它们都由字符 ‘a’、‘b’、‘c’ 组成。</li><li>然而，“abacba” 和 “bcfd” 不相似，因为它们不是相同字符组成的。</li></ul><p>请你找出满足字符串 words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 &lt;= i &lt; j &lt;= words.length - 1 。</p><h1>分析理解</h1><p>题目给了一个数组，数组存放的是字符串，然后要求我们统计相似字符串的对数。而相似字符串就是出现的字母相同的字符串，无论字母的个数，看例子就能很好的明白。</p><h1>基本思路</h1><p>枚举每个字符串中的每个字符是否出现，然后比较逐个比较每对字符串即可。</p><p>按照上述思路应使用的数据结构是哈希表，但是其实使用一个int型变量即可。因为题目限定了每个字符串中出现的字母均为小写字母，而小写字母为26个，int型变量为4字节为32位，刚好满足需要。初始时置为0，从最低位依次开始记录字母a、b、c、d……是否出现即可，出现就将该位置为1。通过移位和或操作，<code>bitNum[i] = bitNum[i] | (1 &lt;&lt; (words[i][j] - 'a'))</code>即可。这里减掉’a’是因为小写字母对应的ASCII码值为97~122。如果直接左移的话就左移97~122位了，减去’a’后就是左移0~25.</p><p>使用int变量记录每个字符串中每个字母是否出现之后，每个字符串就对应一个值。如果两个字符串是相似字符串，那么他们对应的值相等。将每个字符串对应的值使用数组存储后，使用两层循环枚举即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">similarPairs</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">     <span class="type">int</span>* bitNum = <span class="keyword">new</span> <span class="type">int</span>[n]&#123;&#125;;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">         <span class="type">int</span>&amp; cur = bitNum[i];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str: words[i])</span><br><span class="line">             cur = cur | (<span class="number">1</span> &lt;&lt; (str - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)        </span><br><span class="line">         res += (bitNum[i] == bitNum[j]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">similarPairs</span><span class="params">(<span class="type">char</span>** words, <span class="type">int</span> wordsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * bitNum = (<span class="type">int</span> *)<span class="built_in">calloc</span>(wordsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(words[i]); ++j) &#123;</span><br><span class="line">            bitNum[i] = bitNum[i] | (<span class="number">1</span> &lt;&lt; (words[i][j] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsSize; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; wordsSize; ++j) </span><br><span class="line">            <span class="keyword">if</span> (bitNum[i] == bitNum[j])</span><br><span class="line">                ++res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(n * min(m, n))，其中 n 是数组 words 的长度，m 是数组 words 中单个字符串的平均长度。<br>空间复杂度为O(n)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日 Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/count-pairs-of-similar-strings/description/&quot;&gt;2506. 统计相似字符串对的数目&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给你一个下标从</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="位运算" scheme="http://malone-ai.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十二：2209. 用地毯覆盖后的最少白色砖块</title>
    <link href="http://malone-ai.github.io/2025/02/21/leetcode22/"/>
    <id>http://malone-ai.github.io/2025/02/21/leetcode22/</id>
    <published>2025-02-21T04:43:08.000Z</published>
    <updated>2025-02-23T04:49:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/description/">2209. 用地毯覆盖后的最少白色砖块</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/description/&quot;&gt;2209. 用地毯覆盖后的最少白色砖块&lt;/a</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十一：2595. 奇偶位数</title>
    <link href="http://malone-ai.github.io/2025/02/20/leetcode21/"/>
    <id>http://malone-ai.github.io/2025/02/20/leetcode21/</id>
    <published>2025-02-20T02:26:29.000Z</published>
    <updated>2025-02-23T04:43:43.908Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/number-of-even-and-odd-bits/description/">2595. 奇偶位数</a>。</p><p>给你一个正整数 n 。</p><p>用 even 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的偶数下标的个数。</p><p>用 odd 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的奇数下标的个数。</p><p>请注意，在数字的二进制表示中，位下标的顺序 从右到左。</p><p>返回整数数组 answer ，其中 answer = [even, odd] 。</p><h1>思路分析</h1><p>使用int型变量even和odd分别记录，对n进行移位操作，因为记录的是1的个数，因此直接在移位操作后直接加在even或者odd上即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">evenOddBit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> even = <span class="number">0</span>, odd = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;&gt; pos != <span class="number">0</span>) &#123;</span><br><span class="line">            even += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">            odd += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;even, odd&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">evenOddBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;&gt; pos != <span class="number">0</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>] += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">        res[<span class="number">1</span>] += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(log n)，空间复杂度为O(1)。灵茶山艾府就比较厉害了，使用了位掩码的办法，实现了O(1)复杂度的算法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/number-of-even-and-odd-bits/description/&quot;&gt;2595. 奇偶位数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给你一个正整数 n 。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="位运算" scheme="http://malone-ai.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十：624. 数组列表中的最大距离</title>
    <link href="http://malone-ai.github.io/2025/02/19/leetcode20/"/>
    <id>http://malone-ai.github.io/2025/02/19/leetcode20/</id>
    <published>2025-02-19T12:31:32.000Z</published>
    <updated>2025-02-19T16:21:08.640Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/maximum-distance-in-arrays/description/">624. 数组列表中的最大距离</a>。</p><p>给定 m 个数组，每个数组都已经按照升序排好序了。</p><p>现在你需要从两个不同的数组中选择两个整数（每个数组选一个）并且计算它们的距离。两个整数 a 和 b 之间的距离定义为它们差的绝对值 |a-b| 。</p><h1>分析理解</h1><p>题目意思很明确，并且每个数组中的数是按升序排列的，我们需要返回不同数组中的两个数的差值的绝对值，并且这个差值的绝对值得是最大的那个。</p><h1>思路分析</h1><p>暴力的做法是枚举所有的差值的绝对值进行比较，返回绝对值最大的那个即可，但是这种做法显然有提升空间，并且效率不高，复杂度为二阶。</p><p>然后我一开始的想法是比较所有数组的最大值和最小值，然后取出这些最大值中的最大值和最小值中的最小值，返回他们的差值即可，但是无法排除他们在同一个数组中的情况。</p><p>紧接着，我先找出最小值中的最小值，然后记录下其下标；然后在寻找最大值中的最大值时，排除这个下标即可。但是依然无法排除某些特殊情况，如对于[[-2],[-3,-2,1]]，会记录数组②中的-3为最小值，记录数组①中的-2为最大值，得到结果1。但应该是1-(-2)=3。</p><p>于是乎我又开始先找出最大值中的最大值，然后最小值中的最小值，但是依然无法排除某些特殊情况。</p><p>再于是乎，我转向了灵茶山艾府的题解。他的思路很清晰，解释得也比较清楚。基本思路是遍历每个数组，先计算当前数组与记录的最小值和记录的最大值之间的最大距离。记录的最小值和最大值为min_a和max_b，然后当前数组的最大值是最后一个元素，它减去min_a可能是一个候选结果；最小值是第一个元素，max_b减去它是一个候选结果。然后更新min_a和max_b。最终即可得到结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; arrays)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = arrays.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min_a = arrays[<span class="number">0</span>][<span class="number">0</span>], max_b = arrays[<span class="number">0</span>].<span class="built_in">back</span>();</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="built_in">max</span>(max_b - arrays[i].<span class="built_in">front</span>(), arrays[i].<span class="built_in">back</span>() - min_a), ans);</span><br><span class="line">            min_a = <span class="built_in">min</span>(min_a, arrays[i].<span class="built_in">front</span>());</span><br><span class="line">            max_b = <span class="built_in">max</span>(max_b, arrays[i].<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>** arrays, <span class="type">int</span> arraysSize, <span class="type">int</span>* arraysColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min_a = arrays[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max_b = arrays[<span class="number">0</span>][arraysColSize[<span class="number">0</span>]<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arraysSize; ++i) &#123;</span><br><span class="line">        ans = max(max(max_b - arrays[i][<span class="number">0</span>], arrays[i][arraysColSize[i]<span class="number">-1</span>] - min_a), ans);</span><br><span class="line">        min_a = min(min_a, arrays[i][<span class="number">0</span>]);</span><br><span class="line">        max_b = max(max_b, arrays[i][arraysColSize[i]<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/maximum-distance-in-arrays/description/&quot;&gt;624. 数组列表中的最大距离&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给定 m 个数组，每个数组都已</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="贪心" scheme="http://malone-ai.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十九：2080. 区间内查询数字的频率</title>
    <link href="http://malone-ai.github.io/2025/02/18/leetcode19/"/>
    <id>http://malone-ai.github.io/2025/02/18/leetcode19/</id>
    <published>2025-02-18T12:31:16.000Z</published>
    <updated>2025-02-23T02:16:44.843Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/range-frequency-queries/description/">2080. 区间内查询数字的频率</a>。</p><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。</p><p>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。</p><p>请你实现<code>RangeFreqQuery</code>类：</p><ul><li>RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。</li><li>int query(int left, int right, int value) 返回子数组 arr[left…right] 中 value 的 频率 。</li></ul><p>一个 子数组 指的是数组中一段连续的元素。arr[left…right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。</p><h1>分析理解</h1><p>目标是实现一个数据结构，该数据结构能够在给定一个数组的情况下，返回在指定下标范围内特定值的频率。指定下标范围记作[left, right]。</p><h1>基本思路</h1><p>基本思路是使用哈希表将数组中的数值与其出现的下标位置建立映射关系，下标位置使用数组就可以存储。然后再使用二分查找，并且是两次二分查找：</p><ul><li>第一次二分查找用于查找下标位置数组中第一个大于right的值。</li><li>第二次二分查找用于查找下标位置数组中第一个小于等于left的值。</li></ul><p>二者进行相减即为所求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeFreqQuery</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; hash;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RangeFreqQuery</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            hash[arr[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (it == hash.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;&amp; nums = hash[value];</span><br><span class="line">        <span class="comment">// return ranges::upper_bound(nums, right) - ranges::lower_bound(nums, left);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">upper_bound</span>(nums, right) - <span class="built_in">lower_bound</span>(nums, left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; value)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= value)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RangeFreqQuery object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RangeFreqQuery* obj = new RangeFreqQuery(arr);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;query(left,right,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>C语言哈希表库的使用请查看这篇文章<a href="https://malone-ai.github.io/2025/02/18/c1">C语言哈希表库使用</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/range-frequency-queries/description/&quot;&gt;2080. 区间内查询数字的频率&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;请你设计一个数据结构，它能求出给定</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="哈希表" scheme="http://malone-ai.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="二分查找" scheme="http://malone-ai.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>C语言哈希表库使用</title>
    <link href="http://malone-ai.github.io/2025/02/18/c1/"/>
    <id>http://malone-ai.github.io/2025/02/18/c1/</id>
    <published>2025-02-18T03:27:33.000Z</published>
    <updated>2025-02-19T17:12:43.909Z</updated>
    
    <content type="html"><![CDATA[<p>写一篇博客记录一下C语言的哈希表库的使用。哈希表说白了就是Python的字典，我认为二者几乎无异。本文主要讨论的是uthash库。</p><h1>使用步骤</h1><ol><li>安装与包含<br>uthash是一个单文件头库，只需要下载<code>uthash.h</code>库并将其包含在项目中即可。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义结构体<br>定义一个结构体来表示哈希表中的元素，并且结构体中必须包含<code>UT_hash_handle</code>类型的字段。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 值</span></span><br><span class="line">    UT_hash_handle hh; <span class="comment">// 声明一个UT_hash_handle类型的变量</span></span><br><span class="line">&#125;Hash;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化哈希表<br>哈希表是一个指向Hash类型的指针，初始时设为<code>NULL</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash* hash = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>插入元素<br>使用<code>HASH_ADD_INT</code>宏将元素插入哈希表。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hash* item = (Hash*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Hash));</span><br><span class="line">item-&gt;key = key;    <span class="comment">// 此处的key你可以任意指定</span></span><br><span class="line">item-&gt;value = value;    <span class="comment">// 此处的value你可以任意指定</span></span><br><span class="line">HASH_ADD_INT(hash, key, item);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一篇博客记录一下C语言的哈希表库的使用。哈希表说白了就是Python的字典，我认为二者几乎无异。本文主要讨论的是uthash库。&lt;/p&gt;
&lt;h1&gt;使用步骤&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;安装与包含&lt;br&gt;
uthash是一个单文件头库，只需要下载&lt;code&gt;uthash.h</summary>
      
    
    
    
    <category term="C语言" scheme="http://malone-ai.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://malone-ai.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="哈希表" scheme="http://malone-ai.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十八：1287. 有序数组中出现次数超过25%的元素</title>
    <link href="http://malone-ai.github.io/2025/02/17/leetcode18/"/>
    <id>http://malone-ai.github.io/2025/02/17/leetcode18/</id>
    <published>2025-02-17T07:54:06.000Z</published>
    <updated>2025-02-19T12:31:56.377Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leecode每日一题为<a href="https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/">1287. 有序数组中出现次数超过25%的元素</a>。</p><p>给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。</p><p>请你找到并返回这个整数</p><h1>基本思路</h1><p>数组是<code>非递减</code>顺序的，那就好办了，直接遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSpecialInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == res) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">if</span> (count &gt;= (n / <span class="number">4</span> + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = arr[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findSpecialInteger</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == res) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= n / <span class="number">4</span> + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = arr[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leecode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/&quot;&gt;1287. 有序数组中出现次数超过25%的元素&lt;</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十七：1299. 将每个元素替换为右侧最大元素</title>
    <link href="http://malone-ai.github.io/2025/02/16/leetcode17/"/>
    <id>http://malone-ai.github.io/2025/02/16/leetcode17/</id>
    <published>2025-02-15T16:34:04.000Z</published>
    <updated>2025-02-15T17:10:27.215Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leecode每日一题为<a href="https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/description/">1299. 将每个元素替换为右侧最大元素</a>。</p><p>给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。</p><p>完成所有替换操作后，请你返回这个数组。</p><h1>分析理解</h1><p>题目很好理解，无需多言。</p><h1>基本思路</h1><p>从最后一个元素开始向前遍历，然后维护一个从当前元素往后的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">replaceElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cur_max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = cur_max;</span><br><span class="line">            cur_max = <span class="built_in">max</span>(cur_max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">replaceElements</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cur_max = <span class="number">-1</span>;</span><br><span class="line">    *returnSize = arrSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = cur_max;</span><br><span class="line">        cur_max = Max(cur_max, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leecode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/description/&quot;&gt;1299. 将每个元素替换为右侧最大</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
