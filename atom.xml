<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零一世界</title>
  
  
  <link href="http://malone-ai.github.io/atom.xml" rel="self"/>
  
  <link href="http://malone-ai.github.io/"/>
  <updated>2025-02-27T12:14:07.054Z</updated>
  <id>http://malone-ai.github.io/</id>
  
  <author>
    <name>Malone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 每日一题二十八：2296. 设计一个文本编辑器</title>
    <link href="http://malone-ai.github.io/2025/02/27/leetcode28/"/>
    <id>http://malone-ai.github.io/2025/02/27/leetcode28/</id>
    <published>2025-02-27T12:08:38.000Z</published>
    <updated>2025-02-27T12:14:07.054Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/design-a-text-editor/description/">2296. 设计一个文本编辑器</a>。</p><p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p><ul><li>添加：在光标所在处添加文本。</li><li>删除：在光标所在处删除文本（模拟键盘的删除键）。</li><li>移动：将光标往左或者往右移动。</li></ul><p>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候 0 &lt;= cursor.position &lt;= currentText.length 都成立。</p><p>请你实现 TextEditor 类：</p><ul><li>TextEditor() 用空文本初始化对象。</li><li>void addText(string text) 将 text 添加到光标所在位置。添加完后光标在 text 的右边。</li><li>int deleteText(int k) 删除光标左边 k 个字符。返回实际删除的字符数目。</li><li>string cursorLeft(int k) 将光标向左移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。</li><li>string cursorRight(int k) 将光标向右移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。</li></ul><p>最近真的是头大，Leetcode的每日一题怎么这几天一直搞这种设计题，苦不堪言。</p><p>解法参考Leetcode官方的解法，一开始准备使用双向链表的做法，但是发现第二种做法——使用栈来实现貌似更加简单，就是用了栈来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_len 1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *left;</span><br><span class="line">    <span class="type">char</span> *right;</span><br><span class="line">    <span class="type">int</span> leftSize;</span><br><span class="line">    <span class="type">int</span> rightSize;</span><br><span class="line">&#125; TextEditor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextEditor* <span class="title function_">textEditorCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    TextEditor *obj = (TextEditor*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TextEditor));</span><br><span class="line">    obj-&gt;left = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * max_len);</span><br><span class="line">    obj-&gt;right = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * max_len);</span><br><span class="line">    obj-&gt;leftSize = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;rightSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">textEditorAddText</span><span class="params">(TextEditor* obj, <span class="type">char</span>* text)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*text) &#123;</span><br><span class="line">        obj-&gt;left[obj-&gt;leftSize++] = *text;</span><br><span class="line">        ++text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">textEditorDeleteText</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;leftSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;left[--obj-&gt;leftSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        --k;</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">textEditorCursorLeft</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;leftSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;right[obj-&gt;rightSize++] = obj-&gt;left[--obj-&gt;leftSize];</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> retLen = MIN(<span class="number">10</span>, obj-&gt;leftSize);</span><br><span class="line">    <span class="type">char</span> * ret = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (retLen + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; retLen; ++i) </span><br><span class="line">        ret[i] = obj-&gt;left[obj-&gt;leftSize-retLen+i];</span><br><span class="line">    ret[retLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">textEditorCursorRight</span><span class="params">(TextEditor* obj, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;rightSize &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj-&gt;left[obj-&gt;leftSize++] = obj-&gt;right[--obj-&gt;rightSize];</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> retLen = MIN(<span class="number">10</span>, obj-&gt;leftSize);</span><br><span class="line">    <span class="type">char</span> * ret = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (retLen + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; retLen; ++i) </span><br><span class="line">        ret[i] = obj-&gt;left[obj-&gt;leftSize-retLen+i];</span><br><span class="line">    ret[retLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">textEditorFree</span><span class="params">(TextEditor* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;left) </span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;right) </span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor* obj = textEditorCreate();</span></span><br><span class="line"><span class="comment"> * textEditorAddText(obj, text);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = textEditorDeleteText(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * char* param_3 = textEditorCursorLeft(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * char* param_4 = textEditorCursorRight(obj, k);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * textEditorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-a-text-editor/description/&quot;&gt;2296. 设计一个文本编辑器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;请你设计一个带光标的文本编辑器，它可以实</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="栈" scheme="http://malone-ai.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>动态规划一：70. 爬楼梯</title>
    <link href="http://malone-ai.github.io/2025/02/26/dp1/"/>
    <id>http://malone-ai.github.io/2025/02/26/dp1/</id>
    <published>2025-02-26T13:29:02.000Z</published>
    <updated>2025-02-26T13:46:55.489Z</updated>
    
    <content type="html"><![CDATA[<p>开启一个动态规划专栏，跟着灵茶山艾府学习一下动态规划，将动态规划按在地上摩擦。<a href="https://leetcode.cn/circle/discuss/tXLS3i/"><br>分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化）</a>。</p><p>题目为<a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a>。</p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><ul><li>输入：n = 2</li><li>输出：2</li><li>解释：有两种方法可以爬到楼顶。<ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol></li></ul><p>示例 2：</p><ul><li>输入：n = 3</li><li>输出：3</li><li>解释：有三种方法可以爬到楼顶。<ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></li></ul><h1>基本思路</h1><p>n = 1时有1种方法，n = 2时有2种方法；从第 3 阶开始，每一阶的爬法数等于前一阶的爬法数加上前两阶的爬法数，即 arr[i] = arr[i-1] + arr[i-2]。最终返回 arr[n]，即第 n 阶的爬法数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> * arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> * arr = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码虽然可以正确求解，但是存在一些问题：</p><ol><li>内存泄漏<ul><li>使用 malloc 分配的内存没有释放，会导致内存泄漏。</li></ul></li><li>空间复杂度优化<ul><li>使用数组存储所有阶的爬法数，空间复杂度为 O(n)，但实际上只需要前两个值即可，可以优化为 O(1) 的空间复杂度。<br>经优化获得如下实现：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cur = pre1 + pre2;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开启一个动态规划专栏，跟着灵茶山艾府学习一下动态规划，将动态规划按在地上摩擦。&lt;a href=&quot;https://leetcode.cn/circle/discuss/tXLS3i/&quot;&gt;&lt;br&gt;
分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十六：2502. 设计内存分配器</title>
    <link href="http://malone-ai.github.io/2025/02/25/leetcode26/"/>
    <id>http://malone-ai.github.io/2025/02/25/leetcode26/</id>
    <published>2025-02-25T07:23:34.000Z</published>
    <updated>2025-02-25T08:59:14.235Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/design-memory-allocator/description/">2502. 设计内存分配器</a>。</p><p>给你一个整数 n ，表示下标从 0 开始的内存数组的大小。所有内存单元开始都是空闲的。</p><p>请你设计一个具备以下功能的内存分配器：</p><p>分配 一块大小为 size 的连续空闲内存单元并赋 id <code>mID</code> 。<br>释放 给定 id <code>mID</code> 对应的所有内存单元。<br>注意：</p><p>多个块可以被分配到同一个 mID 。<br>你必须释放<code>mID</code>对应的所有内存单元，即便这些内存单元被分配在不同的块中。<br>实现<code>Allocator</code>类：</p><p>Allocator(int n) 使用一个大小为 n 的内存数组初始化 Allocator 对象。<br>int allocate(int size, int mID) 找出大小为 size 个连续空闲内存单元且位于最左侧的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 -1 。<br>int freeMemory(int mID) 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</p><h1>分析理解</h1><p>题目要求实现一个内存管理单元。</p><p>函数allocate有两个参数：size和mID，size即需要找到size个内存块并且这些内存块得是连续的，mID即这些内存块得被赋值为mID。这个函数的返回值为这些内存块的首地址即下标索引。</p><p>函数freeMemory有一个参数mID，实现的功能为将所有内存单元中值为mID的单元释放，然后返回释放的内存单元的个数。</p><h1>基本思路</h1><p>我的第一想法是通过链表来进行组织这些内存块，然后通过哈希表、二维数组等记录未使用的内存块的数量和大小等。但是一直苦于将内存块按照大小进行排序这件事儿，感觉这么做将事情反而复杂化了，并且使用链表貌似也有点多余了。</p><p>最后看了看<a href="https://leetcode.cn/problems/design-memory-allocator/solutions/2016010/bao-li-mo-ni-by-endlesscheng-bqba/?envType=daily-question&amp;envId=2025-02-25">灵茶山艾府的题解</a>。他提供了两种方法：</p><ul><li>模拟</li><li>线段树</li></ul><p>看了看两种方法，感觉使用他的模拟解法就足够了。</p><p>基本思路是使用数组来组织内存块，在分配内存块时，并且全部初始化为0，表示内存块未使用（题目限定mID的取值范围为[1, 1000]）。然后从头开始遍历，寻找到一块大小为size的连续内存块，找不到则返回-1。回收内存块就更简单了，遍历所有内存块，内存块值为mID的均释放并设为0，并使用count进行计数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *mem;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Allocator</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span> ) * n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">this</span>-&gt;mem[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">allocate</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span> (count == size) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i - count + <span class="number">1</span>; j &lt; i + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    mem[j] = mID;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i - count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">freeMemory</span><span class="params">(<span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] == mID) &#123;</span><br><span class="line">                mem[i] = <span class="number">0</span>;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Allocator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Allocator* obj = new Allocator(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;allocate(size,mID);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;freeMemory(mID);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> * mem;</span><br><span class="line">    <span class="type">int</span> n;    </span><br><span class="line">&#125; Allocator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Allocator* <span class="title function_">allocatorCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Allocator * obj = (Allocator *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Allocator));</span><br><span class="line">    obj-&gt;mem = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    obj-&gt;n = n;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">allocatorAllocate</span><span class="params">(Allocator* obj, <span class="type">int</span> size, <span class="type">int</span> mID)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *mem = obj-&gt;mem;</span><br><span class="line">    <span class="type">int</span> n = obj-&gt;n;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">if</span> (count == size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - count + <span class="number">1</span>; j &lt; i + <span class="number">1</span>; ++j)</span><br><span class="line">                mem[j] = mID;</span><br><span class="line">            <span class="keyword">return</span> i - count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">allocatorFreeMemory</span><span class="params">(Allocator* obj, <span class="type">int</span> mID)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * mem = obj-&gt;mem;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = obj-&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mem[i] == mID) &#123;</span><br><span class="line">            mem[i] = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocatorFree</span><span class="params">(Allocator* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;mem);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Allocator struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Allocator* obj = allocatorCreate(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = allocatorAllocate(obj, size, mID);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = allocatorFreeMemory(obj, mID);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * allocatorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>分配和释放内存函数的时间复杂度均为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-memory-allocator/description/&quot;&gt;2502. 设计内存分配器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给你一个整数 n ，表示下标从 0 开</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十五：1656. 设计有序流</title>
    <link href="http://malone-ai.github.io/2025/02/24/leetcode25/"/>
    <id>http://malone-ai.github.io/2025/02/24/leetcode25/</id>
    <published>2025-02-24T04:36:06.000Z</published>
    <updated>2025-02-26T13:40:27.210Z</updated>
    
    <content type="html"><![CDATA[<p>今日的 Leetcode 每日一题为<a href="https://leetcode.cn/problems/design-an-ordered-stream/description/">1656. 设计有序流</a>。</p><p>有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。</p><p>设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。</p><p>实现 OrderedStream 类：</p><ul><li>OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。</li><li>String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后：<ul><li>如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个  id + 1 。</li><li>否则，返回一个空列表。</li></ul></li></ul><h1>官方题解</h1><p>这道题采用了官方题解，解释的还是比较清楚的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> **stream;</span><br><span class="line">    <span class="type">int</span> streamSize;</span><br><span class="line">    <span class="type">int</span> ptr;</span><br><span class="line">&#125; OrderedStream;</span><br><span class="line"></span><br><span class="line">OrderedStream* <span class="title function_">orderedStreamCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    OrderedStream *obj = (OrderedStream *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OrderedStream));</span><br><span class="line">    obj-&gt;stream = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        obj-&gt;stream[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;streamSize = n + <span class="number">1</span>;</span><br><span class="line">    obj-&gt;ptr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ** <span class="title function_">orderedStreamInsert</span><span class="params">(OrderedStream* obj, <span class="type">int</span> idKey, <span class="type">char</span> * value, <span class="type">int</span>* retSize)</span> &#123;</span><br><span class="line">    obj-&gt;stream[idKey] = value;</span><br><span class="line">    <span class="type">char</span> **res = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * obj-&gt;streamSize);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;ptr &lt; obj-&gt;streamSize &amp;&amp; obj-&gt;stream[obj-&gt;ptr]) &#123;</span><br><span class="line">        res[pos++] = obj-&gt;stream[obj-&gt;ptr];</span><br><span class="line">        obj-&gt;ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    *retSize = pos;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">orderedStreamFree</span><span class="params">(OrderedStream* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;stream);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-an-ordered-stream/solutions/1749068/she-ji-you-xu-liu-by-leetcode-solution-3imb/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1>对官方题解进行改善</h1><p>感觉官方将C语言实现里的insert函数中的res内嵌到结构体里比较好，大小与流的大小相同，这样就不必反复分配内存，以及后续忘记释放了。一下是我进行了改进的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> **str;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ptr;</span><br><span class="line">    <span class="type">char</span> **buffer; </span><br><span class="line">&#125; OrderedStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OrderedStream* <span class="title function_">orderedStreamCreate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    OrderedStream* obj = (OrderedStream*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OrderedStream));</span><br><span class="line">    obj-&gt;str = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">        obj-&gt;str[i] = <span class="literal">NULL</span>;</span><br><span class="line">    obj-&gt;n = n;</span><br><span class="line">    obj-&gt;ptr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配缓冲区大小</span></span><br><span class="line">    obj-&gt;buffer = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * n);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** <span class="title function_">orderedStreamInsert</span><span class="params">(OrderedStream* obj, <span class="type">int</span> idKey, <span class="type">char</span>* value, <span class="type">int</span>* retSize)</span> &#123;</span><br><span class="line">    obj-&gt;str[idKey] = value;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;ptr &lt;= obj-&gt;n &amp;&amp; obj-&gt;str[obj-&gt;ptr])</span><br><span class="line">        obj-&gt;buffer[pos++] = obj-&gt;str[obj-&gt;ptr++];</span><br><span class="line">    *retSize = pos;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">orderedStreamFree</span><span class="params">(OrderedStream* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;str);</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;buffer);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your OrderedStream struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * OrderedStream* obj = orderedStreamCreate(n);</span></span><br><span class="line"><span class="comment"> * char** param_1 = orderedStreamInsert(obj, idKey, value, retSize);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * orderedStreamFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的 Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-an-ordered-stream/description/&quot;&gt;1656. 设计有序流&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;有 n 个 (id, value) </summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="数据流" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十四：1206. 设计跳表</title>
    <link href="http://malone-ai.github.io/2025/02/23/leetcode24/"/>
    <id>http://malone-ai.github.io/2025/02/23/leetcode24/</id>
    <published>2025-02-23T02:41:38.000Z</published>
    <updated>2025-02-26T12:46:51.987Z</updated>
    
    <content type="html"><![CDATA[<p>今日 Leetcode 每日一题为<a href="https://leetcode.cn/problems/design-skiplist/description/">1206. 设计跳表</a>。</p><p>不使用任何库函数，设计一个 跳表 。</p><p>跳表是在<code>O(log n)</code>时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：<br><img src="/images/1702370216-mKQcTt-1506_skiplist.gif" alt=""><br>注：图片来源于Leetcode <a href="https://leetcode.cn/problems/design-skiplist/description/">https://leetcode.cn/problems/design-skiplist/description/</a></p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>了解更多 : <a href="https://oi-wiki.org/ds/skiplist/">https://oi-wiki.org/ds/skiplist/</a></p><p>在本题中，你的设计应该要包含这些函数：</p><ul><li>bool search(int target) : 返回target是否存在于跳表中。</li><li>void add(int num): 插入一个元素到跳表。</li><li>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。</li></ul><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><h1>分析理解</h1><p>这道题目让我们设计一个数据结构——跳表。在这之前确实不怎么了解跳表，仔细看了一会儿发现跳表和链表有点像，但是跳表应该说是一个多层链表。其中第0层是包含所有元素的有序链表；1层及以上，每一层都是下一层的子集，作为索引层，帮助快速跳过多个元素。每一层的元素通过指针连接，高层元素会指向低层的相同元素，形成一个“跳跃”的结构。</p><p>跳表有三个核心操作：</p><ol><li>查找</li><li>插入</li><li>删除</li></ol><p>跳表的应用还挺广泛的，Redis的有序集合（Sorted Set）底层就使用了跳表。</p><p>跳表可以实现操作复杂度为O(log n)的查找、插入和删除，还是挺高效的。谈一谈个人对这的理解吧。不管跳表还是链表，都离不开查找、插入和删除三个核心操作，而私以为插入和删除都是基于查找操作的，只要查找得快，插入和删除得也就快。</p><p>链表查找的时候，最坏的情况下是O(n)，就是遍历了整个表。而跳表作为多层链表，可以跳过遍历某些元素，从而加快查找速度，举个简单的例子。</p><p>假设我们要在跳表中查找值 7，跳表的结构如下：</p><ul><li>第2层（最高层）：1 -&gt; 9</li><li>第1层：1 -&gt; 5 -&gt; 9</li><li>第0层（底层）：1 -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 9</li></ul><p>查找过程：</p><ol><li>从最高层（第2层）开始：<ul><li>当前节点是 1，下一个节点是 9。</li><li>9 大于 7，所以不能直接跳到 9，而是向下移动到第1层。</li></ul></li><li>在第1层：<ul><li>当前节点是 1，下一个节点是 5。</li><li>5 小于 7，所以跳到 5。</li><li>从 5 开始，下一个节点是 9。</li><li>9 大于 7，所以向下移动到第0层。</li></ul></li><li>在第0层：<ul><li>当前节点是 5，下一个节点是 7。</li><li>7 等于目标值，查找成功。</li></ul></li></ol><p>基于上述过程可以大概了解跳表的查询过程，可以看到跳表在查询7的时候跳过了对3的遍历。这个例子或许并不能很好地体现跳表的高效，但是在规模较大时，会跳过对很多元素的遍历，产生较好的效果。</p><p>此外，还有一点。跳表依赖于随机算法。在最坏的情况下会退化成单层有序链表。因此随机算法的选择很重要。</p><h1>基本思路</h1><p>这道题我是一点思路都没有，研究了许久官方题解中的C语言实现。一直感觉C语言是不错的语言，虽然有诸多的不便，没有面向对象，没有类似于C++的模板。但是也不可否认C语言的精妙。所以，基本思路：抄！doge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> P_FACTOR = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SkiplistNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;SkiplistNode *&gt; forward;</span><br><span class="line">    <span class="built_in">SkiplistNode</span>(<span class="type">int</span> _val, <span class="type">int</span> _maxLevel = MAX_LEVEL) : <span class="built_in">val</span>(_val), forward(_maxLevel, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SkiplistNode * head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    mt19937 gen&#123;random_device&#123;&#125;()&#125;;</span><br><span class="line">    uniform_real_distribution&lt;<span class="type">double</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Skiplist</span>(): <span class="built_in">head</span>(<span class="keyword">new</span> <span class="built_in">SkiplistNode</span>(<span class="number">-1</span>)), <span class="built_in">level</span>(<span class="number">0</span>), <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 target 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">        <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;SkiplistNode *&gt; <span class="title">update</span><span class="params">(MAX_LEVEL, head)</span></span>;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lv = <span class="built_in">randomLevel</span>();</span><br><span class="line">        level = <span class="built_in">max</span>(level, lv);</span><br><span class="line">        SkiplistNode *newNode = <span class="keyword">new</span> <span class="built_in">SkiplistNode</span>(num, lv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">            <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">            newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">            update[i]-&gt;forward[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;SkiplistNode *&gt; <span class="title">update</span><span class="params">(MAX_LEVEL, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        SkiplistNode *curr = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">                curr = curr-&gt;forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* 如果值不存在则返回 false */</span></span><br><span class="line">        <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span></span><br><span class="line">            update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="comment">/* 更新当前的 level */</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head-&gt;forward[level - <span class="number">1</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dis</span>(gen) &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;</span><br><span class="line">            lv++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-skiplist/solutions/1696545/she-ji-tiao-biao-by-leetcode-solution-e8yh/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P_FACTOR = RAND_MAX &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> maxLevel;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> **<span class="title">forward</span>;</span></span><br><span class="line">&#125; SkiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SkiplistNode *head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; Skiplist;</span><br><span class="line"></span><br><span class="line">SkiplistNode *<span class="title function_">skiplistNodeCreat</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> maxLevel)</span> &#123;</span><br><span class="line">    SkiplistNode *obj = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode));</span><br><span class="line">    obj-&gt;val = val;</span><br><span class="line">    obj-&gt;maxLevel = maxLevel;</span><br><span class="line">    obj-&gt;forward = (SkiplistNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode *) * maxLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLevel; i++) &#123;</span><br><span class="line">        obj-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeFree</span><span class="params">(SkiplistNode* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;forward) &#123;</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;forward);</span><br><span class="line">        obj-&gt;forward = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;maxLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *obj = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Skiplist));</span><br><span class="line">    obj-&gt;head = skiplistNodeCreat(<span class="number">-1</span>, MAX_LEVEL);</span><br><span class="line">    obj-&gt;level = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SkiplistNode * curr = obj-&gt;head; curr; ) &#123;</span><br><span class="line">        SkiplistNode *prev = curr;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        skiplistNodeFree(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">    <span class="keyword">while</span> (rand() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;</span><br><span class="line">        lv++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 target 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">    <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lv = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; i++) &#123;</span><br><span class="line">            update[i] = obj-&gt;head;</span><br><span class="line">        &#125;</span><br><span class="line">        obj-&gt;level = lv;</span><br><span class="line">    &#125;</span><br><span class="line">    SkiplistNode *newNode = skiplistNodeCreat(num, lv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">        newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 如果值不存在则返回 false */</span></span><br><span class="line">    <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span></span><br><span class="line">        update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    skiplistNodeFree(curr);</span><br><span class="line">    <span class="comment">/* 更新当前的 level */</span></span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        obj-&gt;level--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/design-skiplist/solutions/1696545/she-ji-tiao-biao-by-leetcode-solution-e8yh/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>我主要围绕着C语言的实现进行一下理解，便于日后复习。理解了C语言版本，C++版本也就不难了。</p><h2 id="代码理解">代码理解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P_FACTOR = RAND_MAX &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>首先定义了两个常量MAX_LEVEL和P_FACTOR。MAX_LEVEL是跳表的最大层数，而P_FACTOR是一个概率，这里称它为概率或许有点牵强，结合着函数randomLevel应该就不难理解了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lv = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 随机生成 lv */</span></span><br><span class="line">    <span class="keyword">while</span> (rand() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) </span><br><span class="line">        lv++;</span><br><span class="line">    <span class="keyword">return</span> lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数randomLevel是一个静态的内联函数，由关键字<code>static</code>和<code>inline</code>标识。</p><h3 id="static关键字"><code>static</code>关键字</h3><p><code>static</code>将函数的作用域限制在当前文件内，其他文件无法访问这个函数。这里使用static关键字标识这个函数有以下好处：</p><ol><li>避免命名冲突<ul><li>如果其他文件中也定义了同名的 randomLevel 函数，链接时会发生冲突。</li><li>使用 static 可以确保这个函数只在当前文件中可见，避免冲突。</li></ul></li><li>封装性<ul><li>randomLevel 是跳表内部使用的辅助函数，不需要暴露给外部。</li></ul></li></ol><h3 id="inline关键字"><code>inline</code>关键字</h3><p><code>inline</code>关键字将函数标识为<code>内联函数</code>，提示编译器将函数内联展开，即将函数的代码直接插入到调用处，而不是通过函数调用的方式执行。使用<code>inline</code>关键字有以下好处：</p><ol><li>减少函数调用开销<ul><li>函数调用需要保存上下文、跳转到函数地址、执行完后再返回，这些操作有一定的开销。</li><li>randomLevel 是一个简单的函数，内联展开可以避免这些开销，提高性能。</li></ul></li><li>适合小型函数<ul><li>randomLevel 的逻辑非常简单（只是一个循环），适合内联展开。</li><li>如果函数体较大，内联可能会导致代码膨胀，反而降低性能。所以说不是所有的函数都适合作内联声明。</li></ul></li><li>编译器优化<ul><li>inline 是对编译器的建议，编译器可以选择是否真正内联展开。</li></ul></li></ol><h3 id="randomLevel-函数">randomLevel 函数</h3><p>randomLevel函数的作用是生成一个随机数，随机数的区间为[1, MAX_LEVEL]即[1, 32]。lv从1开始，每次以25%的概率递增。为什么是25%呢？这就得看开头的静态常量P_FACTOR，P_FACTOR = RAND_MAX &gt;&gt; 2。RAND_MAX为rand函数能生成的随机数的最大值，然后右移两位，也就是除以4。rand能生成的随机数区间为[1, RAND_MAX]，当生成的随机数小于P_FACTOR即RAND_MAX / 4时进行递增。生成的随机数小于P_FACTOR的区间占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，大于P_FACTOR的区间占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>3</mn></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，这也不难理解为什么是25%概率。还有就是随机数的生成需要初始化随机数种子，这一步在跳表的创建中通过<code>srand(time(NULL))</code>实现了。</p><h3 id="跳表有关结构体">跳表有关结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> maxLevel;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> **<span class="title">forward</span>;</span></span><br><span class="line">&#125; SkiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SkiplistNode *head;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; Skiplist;</span><br></pre></td></tr></table></figure><p>类似于链表，其中SkiplistNode是跳表中<code>节点的定义</code>，Skiplist是<code>跳表的定义</code>。</p><p><code>SkiplistNode</code>结构体内val代表节点存储的值，maxLevel为该节点的最大层数。需要注意的是如果某个节点的maxLevel值为4，那么说明该节点存在于第0、1、2、3层。结构体内的forward是一个指针数组，而forward[i]指向该节点在第i层的下一个节点。</p><p><code>Skiplist</code>结构体，个人感觉不用它也可以，但是使用后方便管理，主要是方便参数的地址传递。这样每次只需要将Skiplist类型的指针传递给函数即可，否则既要传指向*head的指针，又要传指向level的指针，实属不方便。还需要注意的一点是level的值，它其实是跳表中所有节点中maxLevel值最大的那一个。</p><h3 id="跳表节点的创建">跳表节点的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *<span class="title function_">skiplistNodeCreat</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> maxLevel)</span> &#123;</span><br><span class="line">    SkiplistNode *obj = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode));</span><br><span class="line">    obj-&gt;val = val;</span><br><span class="line">    obj-&gt;maxLevel = maxLevel;</span><br><span class="line">    obj-&gt;forward = (SkiplistNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkiplistNode *) * maxLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLevel; i++) </span><br><span class="line">        obj-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很好理解，就是为跳表节点分配内存，初始化跳表节点中的val、maxLevel，为跳表节点的指针数组forward分配内存，并将所有的成员指向NULL。</p><h3 id="跳表节点的释放">跳表节点的释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeFree</span><span class="params">(SkiplistNode* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;forward) &#123;</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;forward);</span><br><span class="line">        obj-&gt;forward = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;maxLevel = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了跳表节点的创建，那么释放也不难理解，相当于将创建节点时所做的事儿反过来做一遍。释放forward（在释放前先检查其是否为NULL，避免反复释放），释放跳表节点所占用内存。</p><h3 id="跳表的创建与释放">跳表的创建与释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *obj = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Skiplist));</span><br><span class="line">    obj-&gt;head = skiplistNodeCreat(<span class="number">-1</span>, MAX_LEVEL);</span><br><span class="line">    obj-&gt;level = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SkiplistNode * curr = obj-&gt;head; curr; ) &#123;</span><br><span class="line">        SkiplistNode *prev = curr;</span><br><span class="line">        curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        skiplistNodeFree(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块也类似于跳表节点的创建与释放，不再赘述。</p><h3 id="跳表的搜索">跳表的搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target)</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 检测当前元素的值是否等于 target */</span></span><br><span class="line">    <span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回target是否存在于跳表中，存在返回true，否则返回false。</p><p>我开始看到这段代码是大写的懵逼，调试了一会儿才明白是怎么个事儿。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target)</span><br><span class="line">        curr = curr-&gt;forward[i];</span><br></pre></td></tr></table></figure><p>理解了这段循环体应该就差不多了。还要强调的一点是跳表的头节点存在于每一层。</p><p>从跳表的最高层开始遍历，在每层定位到最后一个小于target的节点，就向下移动一层。当遍历到最后一层时，就找到了最底层最后一个小于target的节点，它的下一个节点很有可能就是目标节点。使用<code>cur = cur-&gt;forward[0]</code>让cur指向该节点，检查其是否为NULL，不为NULL就再检查节点的值是否为target即可。</p><p>查找过程是从最高层开始，逐层向下查找目标值。</p><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *curr = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>curr 指向跳表的头节点。</li></ul><ol start="2"><li>从最高层开始查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br></pre></td></tr></table></figure><ul><li>obj-&gt;level 是跳表当前的最大层数。</li><li>从最高层（obj-&gt;level - 1）开始，逐层向下查找。</li></ul><ol start="3"><li>在当前层向右查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; target) </span><br><span class="line">    curr = curr-&gt;forward[i];</span><br></pre></td></tr></table></figure><ul><li>curr-&gt;forward[i] 是当前节点在第 i 层的下一个节点。</li><li>如果下一个节点的值小于 target，则继续向右移动。</li><li>这个过程会跳过多个节点，快速接近目标值。</li></ul><ol start="4"><li>移动到下一层</li></ol><ul><li>当在当前层无法继续向右移动时，向下移动到下一层<code>（i--）</code>，继续查找。</li></ul><ol start="5"><li>最终定位到目标节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curr = curr-&gt;forward[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>查找结束后，curr 指向第0层中最后一个小于 target 的节点。</li><li>curr-&gt;forward[0] 是第0层中下一个节点，可能是目标节点。</li></ul><ol start="6"><li>检查是否找到目标值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curr &amp;&amp; curr-&gt;val == target) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>如果 curr-&gt;forward[0] 存在且值等于 target，则返回 true。</li><li>否则返回 false。</li></ul><h3 id="跳表中节点的添加">跳表中节点的添加</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 找到第 i 层小于且最接近 num 的元素*/</span></span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lv = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; i++) &#123;</span><br><span class="line">            update[i] = obj-&gt;head;</span><br><span class="line">        &#125;</span><br><span class="line">        obj-&gt;level = lv;</span><br><span class="line">    &#125;</span><br><span class="line">    SkiplistNode *newNode = skiplistNodeCreat(num, lv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; i++) &#123;</span><br><span class="line">        <span class="comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span></span><br><span class="line">        newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skiplistAdd 的作用是向跳表中插入一个值为 num 的节点。插入时需要：</p><ol><li>找到每一层中最后一个小于 num 的节点。</li><li>随机生成新节点的层数。</li><li>将新节点插入到每一层的正确位置。</li></ol><h4 id="插入过程">插入过程</h4><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">SkiplistNode *cur = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>update是一个指针数组，用于记录每一层中最后一个小于num的节点。</li><li>cur是当前节点，初始化为跳表的头节点。</li></ul><ol start="2"><li>查找插入位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;forward[i] &amp;&amp; cur-&gt;forward[i]-&gt;val &lt; num) </span><br><span class="line">        cur = cur-&gt;forward[i];</span><br><span class="line">    update[i] = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从最高处(<code>obj-&gt;level-1</code>)开始，逐层向下查找。</li><li>在每一层中，向右移动cur，直到找到最后一个小于num的节点。</li><li>将cur记录到update[i]，表示在第i层，应将新节点插入update[i]的后面。</li></ul><ol start="3"><li>随机生成新节点的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lv = randomLevel();</span><br></pre></td></tr></table></figure><ul><li>调用 randomLevel 函数，随机生成新节点的层数 lv。</li></ul><ol start="4"><li>更新跳表的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lv &gt; obj-&gt;level) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; lv; ++i) </span><br><span class="line">        update[i] = obj-&gt;head;</span><br><span class="line">    obj-&gt;level = lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果新节点的层数lv大于跳表的层数obj-&gt;level，需要更新跳表的层数</li><li>对于新增的层（obj-&gt;level-1到lv-1），将update[i]初始化为头节点obj-&gt;head。</li><li>更新跳表的层数obj-&gt;level为lv。</li></ul><ol start="5"><li>创建新节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode * newNode = skiplistNodeCreate(num, lv);</span><br></pre></td></tr></table></figure><ul><li>调用 skiplistNodeCreate 函数，创建一个值为 num、层数为 lv 的新节点。</li></ul><ol start="6"><li>插入新节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv; ++i) &#123;</span><br><span class="line">    newNode-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">    update[i]-&gt;forward[i] = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历新节点的每一层（从第0层到第 lv - 1 层）：<ul><li>将新节点的 forward[i] 指向 update[i]-&gt;forward[i]。</li><li>将 update[i]-&gt;forward[i] 指向新节点。</li></ul></li></ul><p>这样，新节点就被插入到每一层的正确位置。</p><h3 id="跳表节点的删除">跳表节点的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">    SkiplistNode *curr = obj-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) &#123;</span><br><span class="line">            curr = curr-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!curr || curr-&gt;val != num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">    &#125;</span><br><span class="line">    skiplistNodeFree(curr);</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        obj-&gt;level--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skiplistErase 的作用是从跳表中删除值为 num 的节点。如果节点存在并成功删除，返回 true；否则返回 false。</p><h4 id="删除过程">删除过程</h4><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SkiplistNode *update[MAX_LEVEL];</span><br><span class="line">SkiplistNode *curr = obj-&gt;head;</span><br></pre></td></tr></table></figure><ul><li>update 数组用于记录每一层中需要更新的节点。</li><li>curr 指向跳表的头节点（head），用于遍历跳表</li></ul><ol start="2"><li>查找待删除节点的位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;forward[i] &amp;&amp; curr-&gt;forward[i]-&gt;val &lt; num) </span><br><span class="line">        curr = curr-&gt;forward[i];</span><br><span class="line">    update[i] = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从最高层开始，逐层向下查找值为 num 的节点。</li><li>在每一层中，找到最后一个小于 num 的节点，并记录到 update[i] 中。</li><li>这个过程和 skiplistSearch 类似，目的是定位待删除节点的位置。</li></ul><ol start="3"><li>定位待删除节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curr = curr-&gt;forward[<span class="number">0</span>];</span><br><span class="line">curr 现在指向第<span class="number">0</span>层中最后一个小于 num 的节点。</span><br></pre></td></tr></table></figure><ul><li>curr-&gt;forward[0] 是第0层中下一个节点，可能是待删除节点</li></ul><ol start="4"><li>检查节点是否存在</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!curr || curr-&gt;val != num) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>如果 curr-&gt;forward[0] 不存在，或者它的值不等于 num，说明节点不存在，返回 false。</li></ul><ol start="5"><li>更新每一层的指针</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (update[i]-&gt;forward[i] != curr) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    update[i]-&gt;forward[i] = curr-&gt;forward[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历每一层，更新指向待删除节点的指针。</li><li>如果 update[i]-&gt;forward[i] 不等于 curr，说明在这一层中不需要更新（因为待删除节点不在这一层），并且是从底层向高层遍历的，所以后面的所有层也不需要更新，break退出。</li><li>否则，将 update[i]-&gt;forward[i] 指向 curr-&gt;forward[i]，跳过待删除节点。</li></ul><ol start="6"><li>释放待删除节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skiplistNodeFree(curr);</span><br></pre></td></tr></table></figure><p>调用 skiplistNodeFree 函数释放待删除节点的内存。</p><ol start="7"><li>更新跳表的层数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (obj-&gt;level &gt; <span class="number">1</span> &amp;&amp; obj-&gt;head-&gt;forward[obj-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) </span><br><span class="line">    obj-&gt;level--;</span><br></pre></td></tr></table></figure><ul><li>如果删除节点后，某些层变为空（即头节点在这一层的下一个节点为 NULL），则降低跳表的层数。</li><li>这是为了确保跳表的层数不会过高，避免浪费空间。</li></ul><ol start="8"><li>返回结果</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>删除成功，返回 true。</li></ul><p>到此整个代码可算是理解完毕了QvQ。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日 Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/design-skiplist/description/&quot;&gt;1206. 设计跳表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不使用任何库函数，设计一个 跳表 。&lt;/p&gt;
&lt;p&gt;跳表是</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="设计" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="链表" scheme="http://malone-ai.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="跳表" scheme="http://malone-ai.github.io/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十三：2506. 统计相似字符串对的数目</title>
    <link href="http://malone-ai.github.io/2025/02/22/leetcode23/"/>
    <id>http://malone-ai.github.io/2025/02/22/leetcode23/</id>
    <published>2025-02-22T11:22:26.000Z</published>
    <updated>2025-02-25T12:36:16.745Z</updated>
    
    <content type="html"><![CDATA[<p>今日 Leetcode 每日一题为<a href="https://leetcode.cn/problems/count-pairs-of-similar-strings/description/">2506. 统计相似字符串对的数目</a>。</p><p>给你一个下标从 0 开始的字符串数组 words 。</p><p>如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。</p><ul><li>例如，“abca” 和 “cba” 相似，因为它们都由字符 ‘a’、‘b’、‘c’ 组成。</li><li>然而，“abacba” 和 “bcfd” 不相似，因为它们不是相同字符组成的。</li></ul><p>请你找出满足字符串 words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 &lt;= i &lt; j &lt;= words.length - 1 。</p><h1>分析理解</h1><p>题目给了一个数组，数组存放的是字符串，然后要求我们统计相似字符串的对数。而相似字符串就是出现的字母相同的字符串，无论字母的个数，看例子就能很好的明白。</p><h1>基本思路</h1><p>枚举每个字符串中的每个字符是否出现，然后比较逐个比较每对字符串即可。</p><p>按照上述思路应使用的数据结构是哈希表，但是其实使用一个int型变量即可。因为题目限定了每个字符串中出现的字母均为小写字母，而小写字母为26个，int型变量为4字节为32位，刚好满足需要。初始时置为0，从最低位依次开始记录字母a、b、c、d……是否出现即可，出现就将该位置为1。通过移位和或操作，<code>bitNum[i] = bitNum[i] | (1 &lt;&lt; (words[i][j] - 'a'))</code>即可。这里减掉’a’是因为小写字母对应的ASCII码值为97~122。如果直接左移的话就左移97~122位了，减去’a’后就是左移0~25.</p><p>使用int变量记录每个字符串中每个字母是否出现之后，每个字符串就对应一个值。如果两个字符串是相似字符串，那么他们对应的值相等。将每个字符串对应的值使用数组存储后，使用两层循环枚举即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">similarPairs</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">     <span class="type">int</span>* bitNum = <span class="keyword">new</span> <span class="type">int</span>[n]&#123;&#125;;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">         <span class="type">int</span>&amp; cur = bitNum[i];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str: words[i])</span><br><span class="line">             cur = cur | (<span class="number">1</span> &lt;&lt; (str - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)        </span><br><span class="line">         res += (bitNum[i] == bitNum[j]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">similarPairs</span><span class="params">(<span class="type">char</span>** words, <span class="type">int</span> wordsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * bitNum = (<span class="type">int</span> *)<span class="built_in">calloc</span>(wordsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(words[i]); ++j) &#123;</span><br><span class="line">            bitNum[i] = bitNum[i] | (<span class="number">1</span> &lt;&lt; (words[i][j] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsSize; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; wordsSize; ++j) </span><br><span class="line">            <span class="keyword">if</span> (bitNum[i] == bitNum[j])</span><br><span class="line">                ++res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(n * min(m, n))，其中 n 是数组 words 的长度，m 是数组 words 中单个字符串的平均长度。<br>空间复杂度为O(n)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日 Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/count-pairs-of-similar-strings/description/&quot;&gt;2506. 统计相似字符串对的数目&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给你一个下标从</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="位运算" scheme="http://malone-ai.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十二：2209. 用地毯覆盖后的最少白色砖块</title>
    <link href="http://malone-ai.github.io/2025/02/21/leetcode22/"/>
    <id>http://malone-ai.github.io/2025/02/21/leetcode22/</id>
    <published>2025-02-21T04:43:08.000Z</published>
    <updated>2025-02-23T04:49:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/description/">2209. 用地毯覆盖后的最少白色砖块</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/description/&quot;&gt;2209. 用地毯覆盖后的最少白色砖块&lt;/a</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十一：2595. 奇偶位数</title>
    <link href="http://malone-ai.github.io/2025/02/20/leetcode21/"/>
    <id>http://malone-ai.github.io/2025/02/20/leetcode21/</id>
    <published>2025-02-20T02:26:29.000Z</published>
    <updated>2025-02-23T04:43:43.908Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/number-of-even-and-odd-bits/description/">2595. 奇偶位数</a>。</p><p>给你一个正整数 n 。</p><p>用 even 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的偶数下标的个数。</p><p>用 odd 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的奇数下标的个数。</p><p>请注意，在数字的二进制表示中，位下标的顺序 从右到左。</p><p>返回整数数组 answer ，其中 answer = [even, odd] 。</p><h1>思路分析</h1><p>使用int型变量even和odd分别记录，对n进行移位操作，因为记录的是1的个数，因此直接在移位操作后直接加在even或者odd上即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">evenOddBit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> even = <span class="number">0</span>, odd = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;&gt; pos != <span class="number">0</span>) &#123;</span><br><span class="line">            even += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">            odd += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;even, odd&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">evenOddBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;&gt; pos != <span class="number">0</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>] += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">        res[<span class="number">1</span>] += (n &gt;&gt; pos++ &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><p>时间复杂度为O(log n)，空间复杂度为O(1)。灵茶山艾府就比较厉害了，使用了位掩码的办法，实现了O(1)复杂度的算法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/number-of-even-and-odd-bits/description/&quot;&gt;2595. 奇偶位数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给你一个正整数 n 。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="位运算" scheme="http://malone-ai.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题二十：624. 数组列表中的最大距离</title>
    <link href="http://malone-ai.github.io/2025/02/19/leetcode20/"/>
    <id>http://malone-ai.github.io/2025/02/19/leetcode20/</id>
    <published>2025-02-19T12:31:32.000Z</published>
    <updated>2025-02-19T16:21:08.640Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/maximum-distance-in-arrays/description/">624. 数组列表中的最大距离</a>。</p><p>给定 m 个数组，每个数组都已经按照升序排好序了。</p><p>现在你需要从两个不同的数组中选择两个整数（每个数组选一个）并且计算它们的距离。两个整数 a 和 b 之间的距离定义为它们差的绝对值 |a-b| 。</p><h1>分析理解</h1><p>题目意思很明确，并且每个数组中的数是按升序排列的，我们需要返回不同数组中的两个数的差值的绝对值，并且这个差值的绝对值得是最大的那个。</p><h1>思路分析</h1><p>暴力的做法是枚举所有的差值的绝对值进行比较，返回绝对值最大的那个即可，但是这种做法显然有提升空间，并且效率不高，复杂度为二阶。</p><p>然后我一开始的想法是比较所有数组的最大值和最小值，然后取出这些最大值中的最大值和最小值中的最小值，返回他们的差值即可，但是无法排除他们在同一个数组中的情况。</p><p>紧接着，我先找出最小值中的最小值，然后记录下其下标；然后在寻找最大值中的最大值时，排除这个下标即可。但是依然无法排除某些特殊情况，如对于[[-2],[-3,-2,1]]，会记录数组②中的-3为最小值，记录数组①中的-2为最大值，得到结果1。但应该是1-(-2)=3。</p><p>于是乎我又开始先找出最大值中的最大值，然后最小值中的最小值，但是依然无法排除某些特殊情况。</p><p>再于是乎，我转向了灵茶山艾府的题解。他的思路很清晰，解释得也比较清楚。基本思路是遍历每个数组，先计算当前数组与记录的最小值和记录的最大值之间的最大距离。记录的最小值和最大值为min_a和max_b，然后当前数组的最大值是最后一个元素，它减去min_a可能是一个候选结果；最小值是第一个元素，max_b减去它是一个候选结果。然后更新min_a和max_b。最终即可得到结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; arrays)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = arrays.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min_a = arrays[<span class="number">0</span>][<span class="number">0</span>], max_b = arrays[<span class="number">0</span>].<span class="built_in">back</span>();</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="built_in">max</span>(max_b - arrays[i].<span class="built_in">front</span>(), arrays[i].<span class="built_in">back</span>() - min_a), ans);</span><br><span class="line">            min_a = <span class="built_in">min</span>(min_a, arrays[i].<span class="built_in">front</span>());</span><br><span class="line">            max_b = <span class="built_in">max</span>(max_b, arrays[i].<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>** arrays, <span class="type">int</span> arraysSize, <span class="type">int</span>* arraysColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min_a = arrays[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max_b = arrays[<span class="number">0</span>][arraysColSize[<span class="number">0</span>]<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arraysSize; ++i) &#123;</span><br><span class="line">        ans = max(max(max_b - arrays[i][<span class="number">0</span>], arrays[i][arraysColSize[i]<span class="number">-1</span>] - min_a), ans);</span><br><span class="line">        min_a = min(min_a, arrays[i][<span class="number">0</span>]);</span><br><span class="line">        max_b = max(max_b, arrays[i][arraysColSize[i]<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/maximum-distance-in-arrays/description/&quot;&gt;624. 数组列表中的最大距离&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给定 m 个数组，每个数组都已</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="贪心" scheme="http://malone-ai.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十九：2080. 区间内查询数字的频率</title>
    <link href="http://malone-ai.github.io/2025/02/18/leetcode19/"/>
    <id>http://malone-ai.github.io/2025/02/18/leetcode19/</id>
    <published>2025-02-18T12:31:16.000Z</published>
    <updated>2025-02-23T02:16:44.843Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/range-frequency-queries/description/">2080. 区间内查询数字的频率</a>。</p><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。</p><p>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。</p><p>请你实现<code>RangeFreqQuery</code>类：</p><ul><li>RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。</li><li>int query(int left, int right, int value) 返回子数组 arr[left…right] 中 value 的 频率 。</li></ul><p>一个 子数组 指的是数组中一段连续的元素。arr[left…right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。</p><h1>分析理解</h1><p>目标是实现一个数据结构，该数据结构能够在给定一个数组的情况下，返回在指定下标范围内特定值的频率。指定下标范围记作[left, right]。</p><h1>基本思路</h1><p>基本思路是使用哈希表将数组中的数值与其出现的下标位置建立映射关系，下标位置使用数组就可以存储。然后再使用二分查找，并且是两次二分查找：</p><ul><li>第一次二分查找用于查找下标位置数组中第一个大于right的值。</li><li>第二次二分查找用于查找下标位置数组中第一个小于等于left的值。</li></ul><p>二者进行相减即为所求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeFreqQuery</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; hash;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RangeFreqQuery</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            hash[arr[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (it == hash.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;&amp; nums = hash[value];</span><br><span class="line">        <span class="comment">// return ranges::upper_bound(nums, right) - ranges::lower_bound(nums, left);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">upper_bound</span>(nums, right) - <span class="built_in">lower_bound</span>(nums, left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; value)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= value)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RangeFreqQuery object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RangeFreqQuery* obj = new RangeFreqQuery(arr);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;query(left,right,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>C语言哈希表库的使用请查看这篇文章<a href="https://malone-ai.github.io/2025/02/18/c1">C语言哈希表库使用</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/range-frequency-queries/description/&quot;&gt;2080. 区间内查询数字的频率&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;请你设计一个数据结构，它能求出给定</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="哈希表" scheme="http://malone-ai.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="二分查找" scheme="http://malone-ai.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>C语言哈希表库使用</title>
    <link href="http://malone-ai.github.io/2025/02/18/c1/"/>
    <id>http://malone-ai.github.io/2025/02/18/c1/</id>
    <published>2025-02-18T03:27:33.000Z</published>
    <updated>2025-02-19T17:12:43.909Z</updated>
    
    <content type="html"><![CDATA[<p>写一篇博客记录一下C语言的哈希表库的使用。哈希表说白了就是Python的字典，我认为二者几乎无异。本文主要讨论的是uthash库。</p><h1>使用步骤</h1><ol><li>安装与包含<br>uthash是一个单文件头库，只需要下载<code>uthash.h</code>库并将其包含在项目中即可。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义结构体<br>定义一个结构体来表示哈希表中的元素，并且结构体中必须包含<code>UT_hash_handle</code>类型的字段。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 值</span></span><br><span class="line">    UT_hash_handle hh; <span class="comment">// 声明一个UT_hash_handle类型的变量</span></span><br><span class="line">&#125;Hash;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化哈希表<br>哈希表是一个指向Hash类型的指针，初始时设为<code>NULL</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash* hash = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>插入元素<br>使用<code>HASH_ADD_INT</code>宏将元素插入哈希表。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hash* item = (Hash*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Hash));</span><br><span class="line">item-&gt;key = key;    <span class="comment">// 此处的key你可以任意指定</span></span><br><span class="line">item-&gt;value = value;    <span class="comment">// 此处的value你可以任意指定</span></span><br><span class="line">HASH_ADD_INT(hash, key, item);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一篇博客记录一下C语言的哈希表库的使用。哈希表说白了就是Python的字典，我认为二者几乎无异。本文主要讨论的是uthash库。&lt;/p&gt;
&lt;h1&gt;使用步骤&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;安装与包含&lt;br&gt;
uthash是一个单文件头库，只需要下载&lt;code&gt;uthash.h</summary>
      
    
    
    
    <category term="C语言" scheme="http://malone-ai.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://malone-ai.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="哈希表" scheme="http://malone-ai.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十八：1287. 有序数组中出现次数超过25%的元素</title>
    <link href="http://malone-ai.github.io/2025/02/17/leetcode18/"/>
    <id>http://malone-ai.github.io/2025/02/17/leetcode18/</id>
    <published>2025-02-17T07:54:06.000Z</published>
    <updated>2025-02-19T12:31:56.377Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leecode每日一题为<a href="https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/">1287. 有序数组中出现次数超过25%的元素</a>。</p><p>给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。</p><p>请你找到并返回这个整数</p><h1>基本思路</h1><p>数组是<code>非递减</code>顺序的，那就好办了，直接遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSpecialInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == res) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">if</span> (count &gt;= (n / <span class="number">4</span> + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = arr[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findSpecialInteger</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == res) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= n / <span class="number">4</span> + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = arr[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leecode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/&quot;&gt;1287. 有序数组中出现次数超过25%的元素&lt;</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十七：1299. 将每个元素替换为右侧最大元素</title>
    <link href="http://malone-ai.github.io/2025/02/16/leetcode17/"/>
    <id>http://malone-ai.github.io/2025/02/16/leetcode17/</id>
    <published>2025-02-15T16:34:04.000Z</published>
    <updated>2025-02-15T17:10:27.215Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leecode每日一题为<a href="https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/description/">1299. 将每个元素替换为右侧最大元素</a>。</p><p>给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。</p><p>完成所有替换操作后，请你返回这个数组。</p><h1>分析理解</h1><p>题目很好理解，无需多言。</p><h1>基本思路</h1><p>从最后一个元素开始向前遍历，然后维护一个从当前元素往后的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">replaceElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cur_max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = cur_max;</span><br><span class="line">            cur_max = <span class="built_in">max</span>(cur_max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">replaceElements</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cur_max = <span class="number">-1</span>;</span><br><span class="line">    *returnSize = arrSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = cur_max;</span><br><span class="line">        cur_max = Max(cur_max, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leecode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/description/&quot;&gt;1299. 将每个元素替换为右侧最大</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十六：1706. 球会落何处</title>
    <link href="http://malone-ai.github.io/2025/02/15/leetcode16/"/>
    <id>http://malone-ai.github.io/2025/02/15/leetcode16/</id>
    <published>2025-02-15T14:14:45.000Z</published>
    <updated>2025-02-15T16:25:07.888Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/where-will-the-ball-fall/description/">1706. 球会落何处</a>。</p><p>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。</p><p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p><ul><li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。</li><li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。</li></ul><p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p><p>返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。</p><h1>分析理解</h1><p>给了一个矩阵，矩阵中每个元素要么为1要么为-1，为1代表挡板连接左上角和右下角；为-1代表挡板连接右上角和左下角。然后从最上层出发的每个小球最终落点的位置，使用下标表示，其中如果小球不能达到底部就返回-1。</p><h1>基本思路</h1><p>看到题目是一脸懵逼，直接看灵茶山艾府的解题思路，一看大家基本上都是灵茶山艾府的思路（doge）。</p><p>他的思路是，从列开始遍历，一列一列地遍历。而在对每列的遍历中，进行逐行遍历。开始行遍历之前，记录下当前遍历的列号，然后进入行遍历，在列号上加上当前位置所对应位置的值，相当于左右移动。然后每次记录进行加法后的列号是否小于0或者大于列尺寸最大值（此时出界，对应于卡在边界），是否此时的列号所对应的矩阵元素值是否与上一次列号所对应的矩阵元素值相等（此时如果不相等，则形成了“V”形）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findBall</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> cur = j;</span><br><span class="line">            <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;row: grid) &#123;</span><br><span class="line">                <span class="type">int</span> d = row[cur];</span><br><span class="line">                cur += d;</span><br><span class="line">                <span class="keyword">if</span> (cur &lt; <span class="number">0</span> || cur &gt;= n || row[cur] != d) &#123;</span><br><span class="line">                    cur = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[j] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findBall</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize, <span class="type">int</span>* returnSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    *returnSize = *gridColSize;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">    <span class="type">int</span>* p = res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; *gridColSize; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> cur = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gridSize; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> d = grid[i][cur];</span><br><span class="line">            cur += d;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="number">0</span> || cur &gt;= *gridColSize || grid[i][cur] != d) &#123;</span><br><span class="line">                cur = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *p = cur;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/where-will-the-ball-fall/description/&quot;&gt;1706. 球会落何处&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;用一个大小为 m x n 的二维网格 g</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="http://malone-ai.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="模拟" scheme="http://malone-ai.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十五：1552. 两球之间的磁力</title>
    <link href="http://malone-ai.github.io/2025/02/14/leetcode15/"/>
    <id>http://malone-ai.github.io/2025/02/14/leetcode15/</id>
    <published>2025-02-14T10:34:12.000Z</published>
    <updated>2025-02-15T14:13:59.971Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode 每日一题为<a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/description/">1552. 两球之间的磁力</a>：</p><p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p><p>已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。</p><p>给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。</p><h1>分析理解</h1><p>position数组的每个元素position[i]代表一个位置，然后从中挑选出m个位置，求得这m个位置之间的距离的绝对值（这个绝对值即磁力值）中的最小值，并且还要使这个最小值最大。</p><h1>基本思路</h1><p>这道题呈现出明显的<code>单调性</code>：</p><ul><li>如果我们能找到一个磁力值d，使得可以放置m个球，那么所有比d小的值也一定可以满足条件。因为如果d可以，那么更小的d更容易满足。</li><li>如果d不能满足条件，那么所有比d大的值也一定不能满足条件。因为如果d不可以，那么更大的值只会更难满足。</li></ul><p>因此此题目有明显的单调性，考虑<code>二分查找</code>。使用二分法遍历d的可能值，并且不断检查当前的d值是否满足条件，满足就尝试更大的d，不满足就尝试更小的d值。d的遍历区间为position中的两两元素之间的最小值m与最大值M组成的区间[m, M]。position数组是未经排序的，经过排序后很容易求得M为最后一个元素减去第一个元素，而m不容易求得。但是我们注意到有条件1≤position[i]≤10^9，因此可以得到m的下界为1。</p><p>现在只需要确定检查当前d值是否满足条件的逻辑就可以了。基本想法是设置一个pre代表上一个放小球的位置，初始化为position[0]，并设定一个计数器count=1，然后从position[1]开始逐渐向后遍历，每当position[i]-pre的值≥d时，就使计数器自增，并修正pre为position[i]即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; position, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = position.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(position.<span class="built_in">begin</span>(), position.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = position.<span class="built_in">back</span>() - position[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, position, m)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                res = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> d, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pos, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 第一个球已放置</span></span><br><span class="line">        <span class="type">int</span> prev = pos[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[i] - prev &gt;= d) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                prev = pos[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= m ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef enum &#123;</span></span><br><span class="line"><span class="comment">//     false, </span></span><br><span class="line"><span class="comment">//     true</span></span><br><span class="line"><span class="comment">// &#125;bool;</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> *pos, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 第一个球已放置</span></span><br><span class="line">    <span class="type">int</span> pre = pos[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos[i] - pre &gt;= d) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            pre = pos[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= m ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmpFunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>* pos, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    qsort(pos, n, <span class="keyword">sizeof</span>(*pos), cmpFunc);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>, right = pos[n<span class="number">-1</span>] - pos[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid, pos, n, m)) &#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><h1>时间复杂度</h1><p>首先快排的复杂度为O(n log n)，然后二分查找的复杂度为O(log M)（M为position数组中任意两两元素差的绝对值中的最大值，check函数的复杂度为O(n)，总体复杂度为O(n log n + n log M)。</p><h1>空间复杂度</h1><p>使用常数个变量，空间复杂度为O(1)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/magnetic-force-between-two-balls/description/&quot;&gt;1552. 两球之间的磁力&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;在代号为 C-137</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="二分查找" scheme="http://malone-ai.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十四：1742. 盒子中小球的最大数量</title>
    <link href="http://malone-ai.github.io/2025/02/13/leetcode14/"/>
    <id>http://malone-ai.github.io/2025/02/13/leetcode14/</id>
    <published>2025-02-13T10:31:36.000Z</published>
    <updated>2025-02-15T14:14:07.531Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/description/">1742. 盒子中小球的最大数量</a>。</p><p>你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。</p><p>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。</p><p>给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。</p><h1>思路分析</h1><p>遍历[lowLimit, highLimit]，并且计算每位数字之和，然后记录到哈希表中，返回最大的一个，这是我的第一想法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBalls</span><span class="params">(<span class="type">int</span> lowLimit, <span class="type">int</span> highLimit)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lowLimit; i &lt;= highLimit; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">bitSum</span>(i);</span><br><span class="line">            hash[cur]++;</span><br><span class="line">            <span class="keyword">if</span> (hash[cur] &gt; res)</span><br><span class="line">                res = hash[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bitSum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            res += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>灵茶山艾府的解法</h1><p>下午的时候看见了灵神写的题解，灵神就是灵神，直接给出了三种方法：</p><ol><li>暴力枚举</li><li>前缀和</li><li>数位DP</li></ol><h2 id="暴力枚举">暴力枚举</h2><p>暴力枚举的思路和我相同，但灵神更牛的是使用了一个数组来存储各个数位和的个数，他注意到了条件1 &lt;= lowLimit &lt;= highLimit &lt;= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">5</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，数位和最大值为数字99999计算所得的45，最小为1，直接用组存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBalls</span><span class="params">(<span class="type">int</span> lowLimit, <span class="type">int</span> highLimit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">46</span>]&#123;&#125;; <span class="comment">// 99999 的数位和 = 45</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lowLimit; i &lt;= highLimit; i++) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = i; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>) &#123;</span><br><span class="line">                s += x % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ranges::<span class="built_in">max</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：灵茶山艾府</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/maximum-number-of-balls-in-a-box/solutions/3073112/san-chong-fang-fa-bao-li-mei-ju-qian-zhu-kze9/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="前缀和">前缀和</h2><h2 id="数位DP">数位DP</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/description/&quot;&gt;1742. 盒子中小球的最大数量&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;你在一家生产小</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="哈希表" scheme="http://malone-ai.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="暴力" scheme="http://malone-ai.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="枚举" scheme="http://malone-ai.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="记忆化搜索" scheme="http://malone-ai.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
    <category term="前缀和" scheme="http://malone-ai.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十三：1760. 袋子里最少数目的球</title>
    <link href="http://malone-ai.github.io/2025/02/12/leetcode13/"/>
    <id>http://malone-ai.github.io/2025/02/12/leetcode13/</id>
    <published>2025-02-12T09:59:27.000Z</published>
    <updated>2025-02-15T14:14:15.715Z</updated>
    
    <content type="html"><![CDATA[<p>这里想谈谈之前写Leetcode 每日一题文章的顺序，我基本上是先把代码放上去，然后将代码进行详细讲解。感觉这种方法不合适，因为是先有思路然后有代码。先代码后思路显然是本末倒置了，这一点要改改。</p><p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/description/">1760. 袋子里最少数目的球</a>。</p><h1>分析理解</h1><p>该题给定一个数组nums，其中的每个元素nums[i]代表第i个袋子中有几个小球。还给定了一个数maxOperations即最大操作数。接下来要对nums进行操作，每次操作可以将第i个袋子中的小球拆分到两个袋子里。总共进行的操作数不能超过maxOperations，最后要使得进行不超过maxOperations次的操作后，使得nums数组中的最大值最小（花了一点时间才理解doge）。</p><h1>思路分析</h1><p>这道题的一个关键点是寻找一个最小的“最大值”，也就是说我们找到的最大值mid，使得在进行不超过maxOperations次操作后，所有袋子中的小球数都不超过mid即nums中每个元素num都满足num &lt;= mid。因为当mid可能时，比mid更大的数也一定可行。比如当mid=3可行时，mid=4或者mid=5等更大的整数也一定可行，因为允许的最大值变大了，操作次数会更少或者不变。当mid不可行时，比mid更小的数一定不可行，因为允许的最大值变小了，操作次数会更多。比如mid=3不可行时，那么mid=2需要更多的操作次数。因此本题目存在单调性，符合二分搜索的应用条件。</p><p>题目给定了条件nums中所有元素均为大于等于1的整数，所以mid的下界为1，而上界为nums中最大元素的值。因此我们通过二分搜索来遍历[1, M]就行（M为nums中最大元素）。</p><p>另外一个关键点就是拆分次数的公式，就是给定一个num，将其拆分到不大于mid的次数如何计算。一开始我认为其为num // mid，然后对于num=9，mid=3，发现9/3=3，但是9拆分到不大于3只需两次操作：9=6+3=3+3+3。。。</p><p>对于一个含有num个小球的袋子，进行拆分使得每个袋子中的小球数不超过mid，则袋子数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>，而对应的操作次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>。这里想插入一点其他内容，上取整与下取整等的数学公式的推导，还是放在后面弄个附录吧。而编程语言中的除法操作一般是下取整除法，所以还需要进行转换，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1 = \lfloor \frac{num - 1}{mid} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>。因此将含有num个小球的袋子进行拆分使得每个袋子中的小球不超过mid所需的操作次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num-1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>下取整。</p><p>接下来在区间[1, M]遍历mid（M为nums中最大值），具体步骤为：</p><ol><li>初始化左边界left=1，有边界right=M</li><li>在每次循环中，mid = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac{left+right}{2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9322159999999999em;"></span><span class="strut bottom" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.44610799999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">t</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>，计算总的操作次数是否≤maxOperations</li><li>如果满足条件则尝试更小的mid即right=mid，否则需要增大mid即left=mid+1</li><li>当left≥right时，返回right即可</li></ol><p>按照上述步骤可得C++实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num: nums) &#123;</span><br><span class="line">                cur = cur + (num - <span class="number">1</span>) / mid;</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; maxOperations)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt;= maxOperations)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>复杂度分析</h1><h2 id="时间复杂度">时间复杂度</h2><p>外层循环是二分搜索，复杂度为O(log M)（M为nums中的最大值）；内层循环的复杂度为O(n)（n为nums中元素个数），总的时间复杂度为O(n log M)。</p><h2 id="空间复杂度">空间复杂度</h2><p>使用常数个遍历，空间复杂度为O(1)。</p><h1>附录</h1><h2 id="1-lceil-frac-num-mid-rceil-1-lfloor-frac-num-mid-rfloor-吗">1. $ \lceil \frac{num}{mid} \rceil - 1== \lfloor \frac{num}{mid} \rfloor$ 吗</h2><h3 id="情况-1：-frac-num-mid-是整数">情况 1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>是整数</h3><ul><li>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\frac{num}{mid} = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>，其中k是整数</li><li>上取整后减1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mi>k</mi><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil k \rceil - 1 = k -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>​</li><li>下取整：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>k</mi><mo>⌋</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lfloor k \rfloor = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>​</li><li>结论不相等</li></ul><h3 id="情况-2：-frac-num-mid-不是整数">情况 2：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>不是整数</h3><ul><li>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\frac{num}{mid} = k + f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>，其中k是整数，0 &lt; f &lt; 1</li><li>上取整后减1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lceil k + f \rceil - 1 = k + 1 - 1 = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>​</li><li>下取整：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌋</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lfloor k + f \rfloor = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>​</li><li>结论相等</li></ul><p>因此$ \lceil \frac{num}{mid} \rceil - 1== \lfloor \frac{num}{mid} \rfloor$不成立。</p><h2 id="2-lceil-frac-num-mid-rceil-1-lfloor-frac-num-1-mid-rfloor">2. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1= \lfloor \frac{num-1}{mid} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></h2><p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\frac{num}{mid}=k+f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>，其中k为整数部分，f为小数部分，0≤f&lt;1。</p><ul><li>若f=0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>=</mo><mo>⌈</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌉</mo><mo>=</mo><mo>⌈</mo><mi>k</mi><mo>⌉</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil=\lceil k+f \rceil = \lceil k \rceil = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span></li><li>若f&gt;0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>=</mo><mo>⌈</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>⌉</mo><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil=\lceil k+f \rceil = k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.095em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌈</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></li></ul><p>通过变形可以统一上述两种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num+mid-1}{mid}=k+f+1-\frac{1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p><ul><li>若f=0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num+mid-1}{mid}=k+f+1-\frac{1}{mid}=k+1-\frac{1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，下取整为k</li><li>若f&gt;0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mo>+</mo><mi>f</mi><mo>+</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{num+mid-1}{mid}=k+f+1-\frac{1}{mid}=k+f+1-\frac{1}{mid}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，下取整为k+1</li></ul><p>因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil = \lfloor\frac{num+mid-1}{mid}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>。下取整函数有性质<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>⌋</mo><mo>=</mo><mo>⌊</mo><mi>x</mi><mo>⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor x + 1 \rfloor = \lfloor x \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord mathit">x</span><span class="mclose">⌋</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>+</mo><mn>1</mn><mo>⌋</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor\frac{num+mid-1}{mid}\rfloor=\lfloor\frac{num-1}{mid}+1\rfloor=\lfloor\frac{num-1}{mid}\rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">⌋</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>，继而可得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{num}{mid} \rceil - 1= \lfloor\frac{num-1}{mid}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mopen">⌊</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里想谈谈之前写Leetcode 每日一题文章的顺序，我基本上是先把代码放上去，然后将代码进行详细讲解。感觉这种方法不合适，因为是先有思路然后有代码。先代码后思路显然是本末倒置了，这一点要改改。&lt;/p&gt;
&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://malone-ai.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十二：913. 猫和老鼠</title>
    <link href="http://malone-ai.github.io/2025/02/11/leetcode12/"/>
    <id>http://malone-ai.github.io/2025/02/11/leetcode12/</id>
    <published>2025-02-11T14:54:05.000Z</published>
    <updated>2025-02-26T12:41:25.710Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode 每日一题为<a href="https://leetcode.cn/problems/cat-and-mouse/description/">913. 猫和老鼠</a>。</p><p>两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。</p><p>图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。</p><p>老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。</p><p>在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。</p><p>此外，猫无法移动到洞中（节点 0）。</p><p>然后，游戏在出现以下三种情形之一时结束：</p><ul><li>如果猫和老鼠出现在同一个节点，猫获胜。</li><li>如果老鼠到达洞中，老鼠获胜。</li><li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li></ul><p>给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：</p><ul><li>如果老鼠获胜，则返回 1；</li><li>如果猫获胜，则返回 2；</li><li>如果平局，则返回 0 。</li></ul><h1>分析理解</h1><p>这道题是真滴难，看了好久好久才弄明白那么一点，leetcode官方给的标签也是<code>困难</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode 每日一题为&lt;a href=&quot;https://leetcode.cn/problems/cat-and-mouse/description/&quot;&gt;913. 猫和老鼠&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="图" scheme="http://malone-ai.github.io/tags/%E5%9B%BE/"/>
    
    <category term="博弈" scheme="http://malone-ai.github.io/tags/%E5%8D%9A%E5%BC%88/"/>
    
    <category term="拓扑排序" scheme="http://malone-ai.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题十：63. 不同路径 II</title>
    <link href="http://malone-ai.github.io/2025/02/09/leetcode10/"/>
    <id>http://malone-ai.github.io/2025/02/09/leetcode10/</id>
    <published>2025-02-08T17:53:40.000Z</published>
    <updated>2025-02-26T12:39:19.312Z</updated>
    
    <content type="html"><![CDATA[<p>今日Leetcode每日一题为<a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II</a>。</p><p>给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。</p><p>返回机器人能够到达右下角的不同路径数量。</p><p>测试用例保证答案小于等于 2 * 10^9。</p><p>提示：</p><ul><li>m == obstacleGrid.length</li><li>n == obstacleGrid[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h1>分析理解</h1><p>提供一个mxn二维数组grid，其中的元素为1代表有障碍物，为0代表无障碍物。机器人初始位于(0, 0)处，目的地为(m-1, n-1)，需要我们求出从(0, 0)到(m-1, n-1)的路径个数。</p><h1>基本思路</h1><p>使用动态规划求解，求解一个二维的dp数组，dp[i+1][j+1]来代表从(0, 0)到(i, j)的路径个数。这里使用dp[i+1][j+1]而不用dp[i][j]是有原因的，主要是该题目有个特殊的几个用例，(0, 0)处为障碍物，导致解为0。</p><p>初始时将dp中所有元素均设为0，然后将dp[0][1]或者dp[1][0]初始化为1。而在求解dp[i+1][j+1]时dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1]，这样当i=0时求得dp[1][1]=dp[0][1]+dp[1][0]即从(0, 0)到(0, 0)的路径条数。这样做的好处就是不用特殊化处理边界，便于撰写代码。最后返回dp[m][n]即(0, 0)到(m-1, n-1)的路径条数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    dp[i<span class="number">+1</span>][j<span class="number">+1</span>] = dp[i][j<span class="number">+1</span>] + dp[i<span class="number">+1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>** obstacleGrid, <span class="type">int</span> obstacleGridSize, <span class="type">int</span>* obstacleGridColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = obstacleGridSize, n = *obstacleGridColSize;</span><br><span class="line">    <span class="type">int</span>** dp = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * (m+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        dp[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; ++j)</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复杂度</h1><p>时间复杂度和空间复杂度均为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/unique-paths-ii/description/&quot;&gt;63. 不同路径 II&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给定一个 m x n 的整数数组 grid。一个机器人初始位</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题九：128. 最长连续序列</title>
    <link href="http://malone-ai.github.io/2025/02/08/leetcode9/"/>
    <id>http://malone-ai.github.io/2025/02/08/leetcode9/</id>
    <published>2025-02-08T03:29:24.000Z</published>
    <updated>2025-02-15T14:14:26.347Z</updated>
    
    <content type="html"><![CDATA[<p>今日的Leetcode每日一题为<a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">128. 最长连续序列</a>。</p><h1>分析理解</h1><p>题目给一个未排序的整数数组，要求我们找出一个最长的连续的子序列，当然不需要求这个子序列是什么，只需要求出他的长度。题目要求使用时间复杂度为O(n)的算法。</p><h1>思路分析</h1><p>由于题目要求使用时间复杂度为O(n)的算法，故排序是不可能用的了，因为排序的复杂度最低也为O(n log n)。但是提交完题解后发现，最快的方法竟然是排序，给我震惊呆住了。可能是官方的例子比较特殊等原因吧。不过接着看灵神给出的哈希表的方法。</p><p>首先将数组用哈希表去重，将数组转换为哈希集合即没有重复元素的集合。然后开始遍历哈希集合。</p><p>遍历的时候，对于每一个元素x：</p><ul><li>如果x-1存在于哈希集合中，就跳过当前元素；</li><li>如果x-1不存在与哈希集合中，就开始记录从x开始的连续子序列的长度。就是依次遍历x+1、x+2、x+3，…</li></ul><p>x-1存在于哈希集合时，跳过当前元素是因为最长连续子序列的长度一定不从x开始，可能从x-1、也可能从x-2开始，但不会是从x开始。这就是基本思路了，直接给出C++代码，下次试试用Rust：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(i<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            hash.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (hash.<span class="built_in">count</span>(j))</span><br><span class="line">                j++;</span><br><span class="line">            res = <span class="built_in">max</span>(j - i, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日的Leetcode每日一题为&lt;a href=&quot;https://leetcode.cn/problems/longest-consecutive-sequence/description/&quot;&gt;128. 最长连续序列&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;分析理解&lt;/h1&gt;
&lt;p&gt;题目</summary>
      
    
    
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/categories/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="哈希表" scheme="http://malone-ai.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="Leetcode 每日一题" scheme="http://malone-ai.github.io/tags/Leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数组" scheme="http://malone-ai.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="并查集" scheme="http://malone-ai.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
