<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零一世界</title>
  
  
  <link href="http://malone-ai.github.io/atom.xml" rel="self"/>
  
  <link href="http://malone-ai.github.io/"/>
  <updated>2025-03-09T03:43:11.964Z</updated>
  <id>http://malone-ai.github.io/</id>
  
  <author>
    <name>Malone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>她的算法，我解不开</title>
    <link href="http://malone-ai.github.io/2025/03/09/my-feelings3/"/>
    <id>http://malone-ai.github.io/2025/03/09/my-feelings3/</id>
    <published>2025-03-09T03:42:35.000Z</published>
    <updated>2025-03-09T03:43:11.964Z</updated>
    
    
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>动态规划八：区间DP</title>
    <link href="http://malone-ai.github.io/2025/03/08/dp8/"/>
    <id>http://malone-ai.github.io/2025/03/08/dp8/</id>
    <published>2025-03-08T13:01:24.000Z</published>
    <updated>2025-03-08T16:47:22.407Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今日学习灵茶山艾府的<a href="https://www.bilibili.com/video/BV1Gs4y1E7EU/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">区间 DP：最长回文子序列【基础算法精讲 22】</a>。</p><p>前面的几个课程都是在数组的前缀或者后缀上转移的，这类DP叫做线性DP。</p><p>对于区间DP，会把问题规模缩小到数组中间的区间上，而不仅仅是前缀或者后置了。这是区间DP和线性DP的最大区别。</p><p>灵茶山艾府主要通过两道Leetcode题目<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列</a>和<a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/">1039. 多边形三角剖分的最低得分</a>来进行讲解。</p><h1>1. 最长回文子序列</h1><h1>1.1 题目描述</h1><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例 1：</p><pre><code>输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</code></pre><h1>1.2 基本思路</h1><h1>1.2.1 思路一</h1><p>由于回文子序列从左往右读和从右往左读都是一样的，所以可以求s和反转后的s的最长公共子序列，从而可以得到最长回文子序列的长度。</p><h1>1.2.2 思路二</h1><p>选或不选的思路来解决这道题。</p><p>只需要看第一个字母选或不选以及最后一个字母选或不选。</p><p><img src="/images/dp8_1.png" alt=""></p><p>定义dfs(i, j)表示从s[i]到s[j]的最长回文子序列的长度。</p><ul><li>如果s[i] == s[j]，那么就可以都选，i递归到i+1，j递归到j - 1。</li><li>如果s[i] != s[j]，那么要么不选s[i]，要么不选s[j]。</li></ul><p>那么状态转移方程：</p><pre><code>dfs(i, j) = dfs(i+1, j-1) + 2, s[i] == s[j]dfs(i, j) = max(dfs(i+1, j), dfs(i, j-1)), s[i] != s[j]</code></pre><p>如果递归到一个字母的时候，它一个字母也是一个回文子序列，所以返回1。如果没有字母就返回0</p><ul><li>递归边界<ul><li>dfs(i, i) = 1</li><li>dfs(i + 1, i) = 0</li></ul></li><li>递归入口<ul><li>dfs(0, n-1)</li></ul></li></ul><h1>1.3 具体实现</h1><h1>1.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = s[i] == s[j] ? <span class="built_in">dfs</span>(i<span class="number">+1</span>, j<span class="number">-1</span>) + <span class="number">2</span> : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">+1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.2 递推</h1><p>递归翻译成递推，需要注意一下循环顺序。</p><ul><li>由于f[i]从f[i+1]转移过来，所以i要<code>倒序</code>枚举。</li><li>由于f[i][j]从f[i][j-1]转移过来，所以i要<code>倒序</code>枚举。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    f[i][j] = f[i<span class="number">+1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            f[i%<span class="number">2</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    f[i%<span class="number">2</span>][j] = f[(i<span class="number">+1</span>)%<span class="number">2</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i%<span class="number">2</span>][j] = <span class="built_in">max</span>(f[(i<span class="number">+1</span>)%<span class="number">2</span>][j], f[i%<span class="number">2</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2. 多边形三角剖分的最低得分</h1><h1>2.1 题目描述</h1><p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。</p><p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p><p>返回 多边形进行三角剖分后可以得到的最低分 。</p><h1>2.2 基本思路</h1><p>数组values记为v。</p><p>定义<code>从i到j</code>表示沿着边从顶点i顺时针到顶点j的所有顶点（顶点i和顶点j除外），再加上直接从j到i的这条边所组成的多边形（三个顶点组成一个三角形）。</p><p><img src="/images/dp8_2.png" alt=""></p><p>子问题：</p><ul><li>计算从i到j的最低得分 =&gt; 枚举顶点k</li></ul><p>下一个子问题：</p><ul><li>计算从i到k的最低得分</li><li>计算从k到j的最低得分</li></ul><p>定义dfs(i, j)表示从i到j的多边形的最低得分</p><ul><li><p>dfs(i, j) = min{dfs(i, k) + dfs(k, j) + v[i] * v[j] * v[k]}, k = i + 1 ~ j - 1</p></li><li><p>递归边界</p><ul><li>dfs(i, i+1) = 0</li></ul></li><li><p>递归入口</p><ul><li>dfs(0, n-1)</li></ul></li></ul><h1>2.3 具体实现</h1><h1>2.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res = INT_MAX / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i, k) + <span class="built_in">dfs</span>(k, j) + values[i] * values[j] * values[k]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.2 递推</h1><p>状态转移方程为：</p><pre><code>f[i][j] = max&#123;f[i][k] + f[k][j] + v[i] * v[j] * v[k]&#125;, k = i + 1 ~ j - 1</code></pre><p>这里也需要注意循环顺序：</p><pre><code>i &lt; k，f[i]从f[k]转移过来，i需要倒序枚举j &gt; k, f[i][j]从f[i][k]转移过来，j需要正序枚举</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span>&amp; res = f[i][j];</span><br><span class="line">                res = INT_MAX / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, f[i][k] + f[k][j] + values[i] * values[j] * values[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>为什么 i 从 n-3 开始？</li></ul><ol><li><p>三角形的顶点要求</p><ul><li>要形成一个三角形，至少需要 3 个顶点。因此，i 和 j 之间至少要有 2 个顶点（即 j &gt;= i + 2）。</li><li>如果 i 从 n-1 或 n-2 开始，j 的范围会超出数组的边界，无法形成有效的三角形。</li></ul></li><li><p>边界条件</p><ul><li>当 i = n-3 时，j 可以从 i+2 = n-1 开始，这样 i、j 和中间的 k 可以形成一个有效的三角形。</li><li>如果 i 从 n-2 开始，j 只能从 n 开始，这已经超出了数组的边界。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;今日学习灵茶山艾府的&lt;a href=&quot;https://www.bilibili.com/video/BV1Gs4y1E7EU/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f4fa318d</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 项目框架搭建</title>
    <link href="http://malone-ai.github.io/2025/03/07/project-test3/"/>
    <id>http://malone-ai.github.io/2025/03/07/project-test3/</id>
    <published>2025-03-07T13:36:48.000Z</published>
    <updated>2025-03-08T13:00:45.721Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1uZAoeGEqM/?spm_id_from=333.1245.0.0">【带小白做毕设】03. Springboot3框架的快速搭建以及项目工程的讲解</a>并进行一个学习记录。</p><h1>1. 新建工程</h1><p>在idea新建一个工程（注意新建工程页面在左边生成器中选择springboot），工程名为springboot，存放工程的文件夹为存放vue工程的文件夹。语言选Java，类型选Maven，组填com.example，工件填springboot，软件包名称填com.example，jdk选jdk21，java选21，打包选jar。然后选择下一步。</p><p><img src="/images/project-test3_1.png" alt=""></p><p>然后springboot选3.4.3，依赖项中从Web中选择Spring Web，然后点击创建即可。springboot工程就创建完毕了。</p><p><img src="/images/project-test3_2.png" alt=""></p><h1>2. 工程精简</h1><h1>2.1 删除无用文件</h1><p><img src="/images/project-test3_3.png" alt=""></p><p>删除图中画红线的文件。把src/test文件夹、src/main/resources下的static和templates文件夹也删除了。</p><h1>2.2 配置Maven</h1><p>打开设置，直接搜索Maven，配置Maven主路径（也就是Maven的解压路径，我的解压路径为D:\ProgramFiles\apache-maven-3.9.9）。勾选两个重写，然后指定用户设置文件为Maven解压路径下的conf文件夹下的settings.xml。在Maven解压路径下创建repo文件夹，然后选择本地仓库为这个repo文件夹。然后点击确定即可。</p><p><img src="/images/project-test3_4.png" alt=""></p><h1>2.3 pom.xml 文件精简</h1><p>pom.xml文件定义了一些依赖。</p><p><img src="/images/project-test3_5.png" alt=""></p><p><img src="/images/project-test3_6.png" alt=""></p><p>把pom.xml中的上述内容（如上两幅图片所示）删除。</p><h1>2.3 工程目录分析</h1><pre><code>.idea —— idea软件的配置文件src —— 源码目录src/main/java/com/example/SpringbootApplication —— 工程的启动类（文件后缀为.java），main函数就定义在这里。src/main/resources/application.properties —— 整个springboot的配置文件，将其重命名为application.yml，方便编辑    将其编辑为：        server:          port: 9999    以重新设置转发端口号target文件夹 —— 源码编译后的文件pom.xml —— 定义了springboot工程所有的依赖项，springboot加载的时候会扫描这个文件里面所有的依赖项，然后下载</code></pre><h1>2.4 运行工程出现的问题</h1><h1>2.4.1 Error：java 错误 不支持发行版本 5</h1><p>参考链接<a href="https://blog.csdn.net/weixin_43553694/article/details/104118190">Spring项目 Error：java 错误 不支持发行版本 5 IDEA解决办法</a></p><p><img src="/images/project-test3_7.png" alt=""></p><p><img src="/images/project-test3_8.png" alt=""></p><h1>2.4.2 org.springframework.boot不存在</h1><p>参考链接<a href="https://blog.csdn.net/Asa_Prince/article/details/127986463">解决java: 程序包org.springframework.boot不存在的解决方法</a>。</p><p>以及</p><p>File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven -&gt; Runner -&gt; Delegate IDE build/run actions to Maven</p><h1>3. 重启工程</h1><p>关闭这个springboot工程，打开springboot工程和vue工程共存的工程目录。将springboot工程目录下的.idea删除。</p><h1>3.1 重新加载springboot依赖</h1><p>右键springboot工程目录下的pom.xml，选择最下面的添加为Maven项目。</p><p><img src="/images/project-test3_9.png" alt=""></p><h1>3.2 设置编码</h1><p>设置编码为UTF-8。</p><p><img src="/images/project-test3_10.png" alt=""></p><p>然后运行springboot工程，运行成功则配置成功。</p><h1>4. 写一个测试接口</h1><h1>4.1 接口层</h1><p>右键springboot工程下的src/main/java/com/example，选择新建 -&gt; 软件包<br><img src="/images/project-test3_11.png" alt=""></p><p>包名设为controller（controller是对外提供接口的包，在这个包里定义的所有文件，都是对外提供接口数据的，叫接口层controller）。</p><p>springboot一般会分为三层：</p><ul><li>controller<ul><li>提供数据接口</li></ul></li><li>service<ul><li>处理业务逻辑</li></ul></li><li>mapper<ul><li>对接数据库</li></ul></li></ul><p>在controller包里再创建一个WebController，此时它默认会有以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在public class WebController上新增一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br></pre></td></tr></table></figure><p>回车自动补全，会帮助把需要的包也导进来。</p><p>这个行为就是将这个类定义为一个controller。</p><p>在WebController类下写一个get接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键入<code>@GetMapping</code>时按回车自动补全，会自动导包。</p><p>在<code>@GetMapping</code>后键入<code>(&quot;/hello&quot;)</code>定义路由。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口定义的基本格式：</p><ul><li>@GetMapping 表示这是一个get请求接口</li><li>括号里的路径是路由（路由全局唯一）</li></ul><p>此时运行springboot工程在网址<code>localhost:9999/hello</code>下就可以看到&quot;Hello World&quot;。</p><h1>4.2 查看网络请求</h1><p>在网址<code>localhost:9999/hello</code>下按F12，然后：<br><img src="/images/project-test3_12.png" alt=""></p><p>一开始可能不显示，按F5刷新一下即可~</p><h1>4.3 定义接口统一返回的对象</h1><p>前面我们定义的接口返回值类型为String，但也可能是其他数据类型，每个接口返回的数据类型不一样就会造成混乱。为了防止混乱，可以定义一个对象，把我们实际需要返回的数据，包裹在这个对象里面，作为这个对象的一个属性。</p><p>在com.example下新建一个common包（即通用包）。在common下再新建一个Result类。在其中定义三个属性：</p><ul><li>private String code<ul><li>状态码（使用String更通用，既可以返回数字，也可以返回其他等等）</li></ul></li><li>private Object data<ul><li>我们实际返回的数据类型</li></ul></li><li>private String msg<ul><li>当请求错误时返回错误信息（如返回账号或者密码错误）</li></ul></li></ul><p>然后按ALT+Insert，会出现：<br><img src="/images/project-test3_13.png" alt=""></p><p>选择Getter和Setter，接着出现：<br><img src="/images/project-test3_14.png" alt=""></p><p>全选后确定，这样就设置了上述三个private属性的setter和getter方法。</p><p>以上就是Result包装类。</p><h1>4.4 如何使用Result包装类</h1><p>如果我们想在Web类中统一返回这个Result包装类该如何做？</p><p>原来的接口返回的是String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在应该返回一个Result类，并且应该在函数中new一个Result的对象，并调用3.5中定义的setter方法设置这个类的三个属性后返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;200&quot;</span>);</span><br><span class="line">    result.setData(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在修改返回值类型为Result的时候一定要选择com.example.common里的Result类，选它会帮我们自动导包：<br><img src="/images/project-test3_15.png" alt=""></p><p>此时再访问网址<code>localhost:9999/hello</code>：<br><img src="/images/project-test3_16.png" alt=""></p><p>这里的msg为null，也就是为空，因为没有错误消息。</p><p>在前端与后端数据交互的时候，如果拿到消息后判断状态码是否为200，为200则说明请求成功，错误消息就应该为null。如果状态码不为200，说明请求失败，并获取msg来打印错误消息。</p><p>总结一下就是，对于Result包装类：</p><ul><li>code 作为前端判断请求是否成功的依据</li><li>msg 是错误信息</li><li>data 是返回给前端的数据</li></ul><h1>4.5 优化Result包装类</h1><p>如果我们每次写一个接口，都new一个Result类，然后再调用setter方法去设置成员属性，有点繁琐。</p><p>有没有更简单的方法？那就是在Result里写一个静态方法，接收一个参数为Object data：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;200&quot;</span>);</span><br><span class="line">    result.setData(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那使用这样一个静态方法有什么好处呢？就是简化了接口中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是成功的情况，如果是失败的情况呢？那就定义一个error静态方法，此时因为请求失败所有就没有数据了，接收的参数就从Object data变成了String msg（错误消息），并且在方法中将状态码code设置为500：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;500&quot;</span>);</span><br><span class="line">    result.setMsg(msg);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想自定义code呢？那就重载error静态方法，再额外接收一个String code参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String code, String msg)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(code);</span><br><span class="line">    result.setMsg(msg);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5. 异常处理</h1><h1>5.1 500错误</h1><p>如果在定义接口函数hello的时候：<br><img src="/images/project-test3_17.png" alt=""></p><p>也就是主动去引出一个除0异常，但是这里并没有报错，并且编译也能通过，这个就叫<code>运行时异常</code>，只有在运行时才会发现异常。此时运行springboot工程，访问这个接口会发现：<br><img src="/images/project-test3_18.png" alt=""></p><p>也就是抛出了500错误。</p><p>抛出这些错误非常的用户不友好，我们应该用统一的处理方式（用Result包装类处理）。</p><p>Result怎么去处理它呢？我们可以定义一个全局异常处理GlobalExceptionHandler。在com.example里新建一个包exception，再在这个包里创建GlobalExceptionHandler类。这个类就是全局异常捕获器，它负责把代码里的错误进行捕获，并统一通过Result类返回。</p><p>在public class GlobalExceptionHandler上面一行添加<code>@ControllerAdvice</code>，依然是回车自动补全（这样自动导包）。然后还要提供Controller类的路径，<code>@ControllerAdvice(&quot;com.example.controller&quot;)</code>。</p><p>在GlobalExceptionHandler类内部键入<code>@ExceptionHandler</code>（回车自动补全自动导包），然后圆括号键入Exception.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br></pre></td></tr></table></figure><p>这里的Exception就是Java中所有异常的基类。</p><p>然后换行键入<code>@ResponseBody</code>，@ResponseBody的作用其实是将java对象转为json格式的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br></pre></td></tr></table></figure><p>然后接着换行写error方法，返回值为Result对象，接收一个参数Exception e。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再运行springboot项目，访问接口：<br><img src="/images/project-test3_19.png" alt=""></p><p>就不会在返回500错误了。</p><p>出现异常了看控制台，跳转到出错的代码进行debug。</p><p>也可以使用一个log在控制台打印错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比原来新增两行代码，一个是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br></pre></td></tr></table></figure><p>还有一行是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br></pre></td></tr></table></figure><p>此时运行工程并访问接口，在控制台：<br><img src="/images/project-test3_20.png" alt=""></p><h1>5.2 自定义异常</h1><p>什么是自定义异常呢？比如前端传了一个账号密码过来，但是账号或者密码错了，怎么告诉前端账号或者密码错了呢？假设它在service层，而不是在controller层。</p><p>也就是在service往外抛出错误。不能直接return一个Result对象，因为Result对象是在controller层进行封装的。</p><p>其实就是不在controller层时，如何抛出错误？</p><p>在com.example新建一个service包，再在这个包下创建AdminService类。然后给AdminServie加Servie注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把这个AdminService类注册为了Springboot的一个bean。</p><p>然后在这个类中添加admin方法，接收一个String name参数的方法，入股name与&quot;admin&quot;相等就返回&quot;admin&quot;（也就是admin接口只接受&quot;admin&quot;账号），其他返回错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里先留着</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们到com/example/controller/WebController.java中写一个admin接口，并给这个接口传一个参数String name。这个时候我们需要去访问service中的方法。先通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AdminService adminService;</span><br></pre></td></tr></table></figure><p>注入这个service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在admin接口中通过这个adminService调用它的admin方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/admin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">admin</span> <span class="operator">=</span> adminService.admin(name);</span><br><span class="line">        <span class="keyword">return</span> Result.success(admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前端调用admin接口传来一个name，当name等于&quot;admin&quot;时，返回&quot;admin&quot;；当不等于&quot;admin&quot;的时候返回错误。</p><p>不能在AdminService中的admin方法中直接返回&quot;账号或者密码&quot;错误，因为这个admin方法是通过admin接口调用的，这个&quot;账号或者密码&quot;错误返回后被admin接收，然后又通过<code>Result.success(admin)</code>返回，但此时状态码code还是200（请求成功）。</p><p>那么该如何返回错误呢？考虑自定义异常。</p><p>在com/example/exception类中新建一个CustomerException类，然后让这个类继承RuntimeException类（Java通过extends继承）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给这个类添加两个private属性，String code 和 String msg，也就是错误状态码和错误信息。继续利用ALT+Insert来快速实现他们的getter和setter方法以及构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">(String code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = <span class="string">&quot;500&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以完善AdminService类里的admin方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomerException</span>(<span class="string">&quot;账号错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要再全局捕获器中捕获我们的自定义异常（原来只捕获Exception基类异常）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/example/exception/GlobalExceptionHandler.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(CustomerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">customerError</span><span class="params">(CustomerException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;自定义错误&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(), e.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中customerError中一定要把CustomerException对象e中包含的msg通过getMsg拿出来。</p><p>现在访问<code>localhost:9999/admin?name=1111</code>，其中<code>?name=1111</code>就是传递参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1uZAoeGEqM/?spm_id_from=333.1245.0.0&quot;&gt;【带小白做毕设】03. Springboot3框架的快速</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>动态规划七：状态机DP</title>
    <link href="http://malone-ai.github.io/2025/03/06/dp7/"/>
    <id>http://malone-ai.github.io/2025/03/06/dp7/</id>
    <published>2025-03-06T12:12:25.000Z</published>
    <updated>2025-03-07T05:50:09.099Z</updated>
    
    <content type="html"><![CDATA[<p>今日学习灵茶山艾府的<a href="https://www.bilibili.com/video/BV1ho4y1W7QK/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">买卖股票的最佳时机【基础算法精讲 21】</a>。</p><h1>1. 买卖股票的最佳时机 II</h1><p>Leetcode 官方题目<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a>。</p><h1>1.1 题目描述</h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p>示例 1：</p><pre><code>输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。最大总利润为 4 + 3 = 7 。</code></pre><p>示例 2：</p><pre><code>输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。最大总利润为 4 。</code></pre><p>示例 3：</p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</code></pre><h1>1.2 思路</h1><p><code>启发思路</code>：最后一天发生了什么？</p><p>对于 prices = [7,1,5,3,6,4]</p><pre><code>从第0天开始到第5天结束时的利润= 从第0天开始到第4天结束时的利润 + 第5天的利润= 。。。</code></pre><p>如果第5天什么也没做，那么利润是0。如果买入4块钱的股票，那么利润是-4。如果4块钱卖掉股票，那么利润是4（即赚了4块钱，但是这里说的赚了4块钱没有考虑买入股票花的钱）。假如第5天卖掉的股票是花6块钱买入的，那么这个利润-6需要算在第0天开始到第4天结束时的利润里面。</p><p>那么第i天我们可以做哪些事儿呢？看这张图：<br><img src="/images/dp7_1.jpg" alt=""></p><ul><li>什么也不做<ul><li>状态不变</li></ul></li><li>买入股票<ul><li>那么就从第i-1天未持有股票的状态，变成第i天结束时持有股票的状态</li></ul></li><li>卖出股票<ul><li>那么就从第i-1天持有股票的状态，变成第i天结束时未持有股票的状态</li></ul></li></ul><p>从图中可以看出状态转移一共有四种状态，其中持有股票或者未持有股票时，既不买入也不卖出是两种状态。</p><ul><li>定义 dfs(i,0)表示到第i天结束时，未持有股票的最大利润</li><li>定义 dfs(i,1)表示到第i天结束时，持有股票的最大利润</li></ul><p>（这里的参数0/1是一个bool类型的值。）</p><p>由于第i-1天的结束就是第i天的开始dfs(i-1,·)也表示到第i天开始时的最大利润。</p><p>继而可以得到以下图：<br><img src="/images/dp7_2.jpg" alt=""></p><p>从每个状态可以转移到其他状态，将这些其他状态取最大值就可以得到：</p><pre><code>dfs(i, 0) = max(dfs(i-1, 0) + dfs(i-1, 1) - prices[i])dfs(i, 1) = max(dfs(i-1, 1) + dfs(i-1, 0) + prices[i])</code></pre><p>递归边界：</p><pre><code>dfs(-1, 0) = 0  第0天`开始时`未持有股票，利润为0dfs(-1, 1) = 0  第0天`开始时`不可能持有股票</code></pre><p>递归入口：</p><pre><code>max(dfs(n-1, 0), dfs(n-1, 1))= dfs(n-1, 0)</code></pre><p>看上去枚举最后一天是否持有股票就可以了，但是如果最后一天结束时还持有股票，这个股票在后面就卖不出去了（或者说不在题目考虑的范围内）。所以dfs(n-1, 1)是不会比dfs(n-1, 0)大的，故从dfs(n-1, 0)开始递归即可。</p><h1>1.3 具体实现</h1><h1>1.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = j == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.2 递推 空间复杂度O(n)</h1><p>递归很容易翻译成递推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.3 递推 空间复杂度O(1) 两个数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(1) 两个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[(i + <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i % <span class="number">2</span>][<span class="number">0</span>], f[i % <span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[(i + <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i % <span class="number">2</span>][<span class="number">1</span>], f[i % <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.4 递推 空间复杂度O(1) 不用数组</h1><p>这种貌似难想，但其实画个图再对照一下两个数组的代码就很容易想到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(1) 不用数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f1 = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> f0_tmp = f0;</span><br><span class="line">            f0 = <span class="built_in">max</span>(f0, f1 + prices[i]);</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1, f0_tmp - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4 变形题目：309. 买卖股票的最佳时机含冷冻期</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期</a>。</p><h1>1.4.1 题目描述</h1><p>给定一个整数数组prices，其中 prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><pre><code>输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><p>示例 2:</p><pre><code>输入: prices = [1]输出: 0</code></pre><h1>1.4.2 思路</h1><p>这道题有冷冻期，就是在卖出后不能立刻买入股票。换句话就是买入股票的时候，前一天不能有卖出操作。这其实和和<a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍</a>很像。在打家劫舍中，从右往左思考，如果选第i个房子，那么第i-1个房子不能选，所以直接递归到第i-2个房子。</p><p>这道题也是一样的。<br>状态转移：</p><ul><li>如果今天不持有股票，那么有两种可能：<ul><li>前一天也不持有股票，今天什么都不做。</li><li>前一天持有股票，今天卖出股票。</li><li>因此，状态转移方程为：dfs(i, 0) = max(dfs(i-1, 0), dfs(i-1, 1) + prices[i])</li></ul></li><li>如果今天持有股票，那么有两种可能：<ul><li>前一天也持有股票，今天什么都不做。</li><li>前两天不持有股票，今天买入股票（因为有冷冻期，所以不能在前一天卖出后立即买入）。</li><li>因此，状态转移方程为：dfs(i, 1) = max(dfs(i-1, 1), dfs(i-2, 0) - prices[i])</li></ul></li></ul><h1>1.4.3 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = j == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-2</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4.4 递推 空间复杂度 O(n)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度 O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i<span class="number">+2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][<span class="number">0</span>], f[i<span class="number">+1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i<span class="number">+2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4.5 递推 空间复杂度 O(1)</h1><p>这个空间复杂度为O(1)的是真想不明白😂。</p><h1>2. 买卖股票的最佳时机 IV</h1><p>Leetcode 官方题目<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV</a>。</p><h1>2.1 题目描述</h1><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1：</p><pre><code>输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</code></pre><p>示例 2：</p><pre><code>输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</code></pre><h1>2.2 基本思路</h1><p>定义 dfs(i,j,0) 表示到第 i 天<code>结束</code>时完成<code>至多</code> j 笔交易，未持有股票的最大利润。<br>定义 dfs(i,j,1) 表示到第 i 天<code>结束</code>时完成<code>至多</code> j 笔交易，持有股票的最大利润。</p><p>状态转移图如下图：</p><p><img src="/images/dp7_3.jpg" alt=""></p><p>既然有次数限制，就应当在递归过程中记录次数。所以在无限次交易的基础上增加一个参数j，表示<code>至多</code>完成j笔交易。转移方程需要修改的地方就是在买入或者卖出的地方把交易次数减1，如果买入减1，后面卖出的时候就不用减1。</p><pre><code>dfs(i,j,0) = max(dfs(i-1,j,0), dfs(i-1,j,1) + prices[i])dfs(i,j,1) = max(dfs(i-1,j,1), dfs(i-1,j-1,0) - prices[i])</code></pre><p>递归边界：</p><pre><code>dfs(·, -1, ·) = -∞, 任何情况下，j都不能为负dfs(-1, j, 0) = 0, 第 0 天开始未持有股票，利润为 0dfs(-1, j, 1) = -∞，第 0 天开始不可能持有股票</code></pre><h1>2.3 具体实现</h1><h1>2.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">memo</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>)));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> l)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> l == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j][l];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = l == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.2 递推 空间复杂度O(n*k)</h1><ul><li><p>为什么第二维度的大小是 k+2？</p><ul><li>在记忆化搜索中，j 的范围是 [−1,k]，这一共有 k+2 个数。1:1 翻译成递推就需要 k+2 的数组大小。</li></ul></li><li><p>f 数组中的 j=0 表示什么意思？</p><ul><li>这对应着记忆化搜索中的 j=−1 的状态，也就是交易 −1 次的状态。注意这是不合法的，所以初始值一定是 −∞。</li></ul></li><li><p>f 的初始值怎么确定？</p><ul><li>f 的初始值来自记忆化搜索的递归边界，递归边界怎么写，初始值就怎么写。</li></ul></li></ul><p>作者：灵茶山艾府<br>链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(n*k)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN / <span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j)</span><br><span class="line">            f[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">0</span>], f[i][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                f[i<span class="number">+1</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">1</span>], f[i][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][k<span class="number">+1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.3 递推 空间复杂度O(k)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(k)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN / <span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j)</span><br><span class="line">            f[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i%<span class="number">2</span>][j][<span class="number">0</span>], f[i%<span class="number">2</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i%<span class="number">2</span>][j][<span class="number">1</span>], f[i%<span class="number">2</span>][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][k<span class="number">+1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日学习灵茶山艾府的&lt;a href=&quot;https://www.bilibili.com/video/BV1ho4y1W7QK/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a&quot;&gt;</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>总结一下最近</title>
    <link href="http://malone-ai.github.io/2025/03/06/my-feelings2/"/>
    <id>http://malone-ai.github.io/2025/03/06/my-feelings2/</id>
    <published>2025-03-06T10:01:04.000Z</published>
    <updated>2025-03-06T12:28:59.197Z</updated>
    
    <content type="html"><![CDATA[<p>回顾一下最近的一个月。2.6号还在家，天天刷着leetcode，看看github上的一些源码，偶尔自己写写，再有空写写博客。</p><p>2.13准备返校，但是突发了一些意外，请假了，最后放了同学鸽子（本来说好一起返校的），不过好在返校后请人家吃了一顿，应该也消气了。</p><p>2.24开始返校，返校后一直在修改简历，想要投递个实习。基本上每天都在学C++的一些新特性以及一些八股文相关，然后刷刷leetcode，写写博客。</p><p>中间甚至在学java和前端🤣。java不难，因为两年前学过，并且java的很多语法与C++类似，只不过java也有很多高级的特性，比如垃圾回收机制等等，当时一度感觉就是因为java的垃圾回收机制，C++才会有智能指针。前端主要是vue3，感觉它比html要强大太多了。</p><p>还有就是，目前写的不少博客，内容基本上是B站上视频的学习的记录或者学习其他的博客，然后进行一个整理。整理和记录视频是因为看视频来进行复习回顾确实费时费力不讨好。整理其他人的博客也是一个很费时的事，说他是造轮子感觉太高大上了，说是搬运工感觉更合适。不过不可否认自己学到了很多东西。</p><p>目前的想法是，对于其他人博客的学习，只提出转载声明然后提供跳转链接，不做过多的整理。但是貌似也不是一件容易的事儿，最怕的还是版权问题。自己消化理解后再撰写博客和那完全是两码事儿。目前没有更好的解决方案了😵。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回顾一下最近的一个月。2.6号还在家，天天刷着leetcode，看看github上的一些源码，偶尔自己写写，再有空写写博客。&lt;/p&gt;
&lt;p&gt;2.13准备返校，但是突发了一些意外，请假了，最后放了同学鸽子（本来说好一起返校的），不过好在返校后请人家吃了一顿，应该也消气了。&lt;/</summary>
      
    
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>CMake 保姆级教程[转载]</title>
    <link href="http://malone-ai.github.io/2025/03/06/chores3/"/>
    <id>http://malone-ai.github.io/2025/03/06/chores3/</id>
    <published>2025-03-06T05:48:34.000Z</published>
    <updated>2025-03-06T05:51:01.455Z</updated>
    
    <content type="html"><![CDATA[<p>提供一下一个优秀的个人博客网站中写的CMake教程的跳转链接（侵权删）：</p><ul><li><a href="https://subingwen.cn/cmake/CMake-primer/">CMake 保姆级教程（上）</a></li><li><a href="https://subingwen.cn/cmake/CMake-advanced/">CMake 保姆级教程（下）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提供一下一个优秀的个人博客网站中写的CMake教程的跳转链接（侵权删）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://subingwen.cn/cmake/CMake-primer/&quot;&gt;CMake 保姆级教程（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
    <category term="CMake" scheme="http://malone-ai.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>GDB 调试</title>
    <link href="http://malone-ai.github.io/2025/03/06/chores2/"/>
    <id>http://malone-ai.github.io/2025/03/06/chores2/</id>
    <published>2025-03-06T03:16:07.000Z</published>
    <updated>2025-03-06T05:24:08.695Z</updated>
    
    <content type="html"><![CDATA[<p>GDB是Linux下非常好用且强大的调试工具。GDB可以调试C、C++等多种语言。</p><h1>1. 判断文件是否带有调试信息</h1><p>C/C++的编译文件有两种版本：</p><ul><li>release版本</li><li>debug版本</li></ul><p>gcc和g++默认编译生成的是release版本，release版本不带有调试信息，通常体积更小。</p><p>而如果在编译时带上&quot;-g&quot;参数，那么编译生成的就是debug版本。debug版本带有调试信息，体积通常会更大。</p><p>如果你想对一个C/C++的编译文件进行调试，那么它必须是debug版本，也就是编译时带了&quot;-g&quot;参数，带有调试信息的二进制可执行文件。</p><p>有一个编译好的二进制文件，你不确定是不是debug版本，是否带有调试信息，有两种方法可以确定。</p><ol><li>使用 gdb 命令</li></ol><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行gdb test命令后，如果其不是debug版本，不带有调试信息，那么就会显示：</p><pre><code>Reading symbols from test...(No debugging symbols found in test)</code></pre><p>（当然还有其他的一些信息会显示，如gdb版本等等。）</p><ul><li>带有调试信息（debug）</li></ul><p>如果带有调试信息，是debug版本，那么会显示：</p><pre><code>Reading symbols from test...</code></pre><p>也就是比不带有调试信息的少一行<code>(No debugging symbols found in test)</code>提示。</p><ol start="2"><li>使用 readelf 命令</li></ol><p>还可以使用命令readlef查看可执行文件是否带有调试功能。</p><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果其不是debug版本，不带有调试信息，那么不会显示任何内容。</p><ul><li>带有调试信息（debug）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果是debug版本，带有调试信息，那么类似于以下的内容：</p><pre><code>[28] .debug_aranges    PROGBITS         0000000000000000  0000303b[29] .debug_info       PROGBITS         0000000000000000  0000306b[30] .debug_abbrev     PROGBITS         0000000000000000  00005429[31] .debug_line       PROGBITS         0000000000000000  000059df[32] .debug_str        PROGBITS         0000000000000000  00005b41[33] .debug_line_str   PROGBITS         0000000000000000  00006cfb</code></pre><p>总之带调试信息的会显示内容，不带调试信息的不显示任何内容。</p><h1>2. GDB 命令汇总</h1><table><thead><tr><th>指令</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td><code>l</code></td><td><code>list</code></td><td>显示对应的代码，每次10行。可以指定行号或函数名。</td></tr><tr><td><code>r</code></td><td><code>run</code></td><td>无断点直接运行到底，有断点就运行到下一个断点然后停止。</td></tr><tr><td><code>b</code></td><td><code>breakpoint</code></td><td>在指定行号或函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:函数名</code></td><td><code>breakpoint</code></td><td>在该函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:行号</code></td><td><code>breakpoint</code></td><td>在该源文件中的指定行号打上断点。</td></tr><tr><td><code>info b</code></td><td><code>info breakpoints</code></td><td>查看断点的信息。</td></tr><tr><td><code>d</code></td><td><code>delete</code></td><td>删除指定编号的断点。</td></tr><tr><td><code>d breakpoints</code></td><td><code>delete breakpoints</code></td><td>删除所有的断点。</td></tr><tr><td><code>disable b</code></td><td><code>disable breakpoints</code></td><td>使所有断点无效。</td></tr><tr><td><code>disable b 编号</code></td><td><code>disable breakpoint</code></td><td>使指定编号的断点无效。</td></tr><tr><td><code>enable b</code></td><td><code>enable breakpoints</code></td><td>使所有断点有效。</td></tr><tr><td><code>enable b 编号</code></td><td><code>enable breakpoint</code></td><td>使指定编号的断点有效。</td></tr><tr><td><code>n</code></td><td><code>next</code></td><td>逐过程。</td></tr><tr><td><code>s</code></td><td><code>step</code></td><td>单步调试。</td></tr><tr><td><code>bt</code></td><td><code>backtrace</code></td><td>查看函数调用。</td></tr><tr><td><code>set var</code></td><td><code>set variable</code></td><td>修改变量的值。</td></tr><tr><td><code>p</code></td><td><code>print</code></td><td>打印变量的值。</td></tr><tr><td><code>display</code></td><td><code>display</code></td><td>追踪变量，每次停下来都显示它的值。</td></tr><tr><td><code>undisplay</code></td><td><code>undisplay</code></td><td>取消追踪。</td></tr><tr><td><code>until</code></td><td><code>until</code></td><td>继续执行，直至下一个断点处停止。</td></tr><tr><td><code>finish</code></td><td><code>finish</code></td><td>单步跳出，执行完当前所在函数后停止。</td></tr><tr><td><code>c</code></td><td><code>continue</code></td><td>从一个断点处，直接运行至下一个断点处。</td></tr></tbody></table><h1>3. GDB调试实践</h1><h2 id="3-1-编译出debug版本的二进制可执行文件">3.1 编译出debug版本的二进制可执行文件</h2><p>以下是将要用于调试的C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，用于计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，用于演示指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pointerDemo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *ptr = <span class="number">100</span>; <span class="comment">// 修改指针指向的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">factorial</span>(num); <span class="comment">// 计算阶乘</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Factorial of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;value;</span><br><span class="line">    <span class="built_in">pointerDemo</span>(ptr); <span class="comment">// 演示指针操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value after pointerDemo: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个简单的循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Loop iteration: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态内存分配</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放动态内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> test.cpp -g</span><br></pre></td></tr></table></figure><p>进行编译可得带调试信息的二进制可执行文件test。</p><h2 id="3-2-启动GDB">3.2 启动GDB</h2><p>可以使用gdb [要调试的二进制可执行文件名称]如gdb test来启动gdb调试，此时会进入gdb的命令行。也可以直接输入gdb回车进入gdb命令行后输入file test后回车来调试test。</p><h2 id="3-3-部分命令详解">3.3 部分命令详解</h2><h3 id="3-3-1-list">3.3.1 list</h3><p>简写为l（小写L），输入后便会展示10行代码，第一次使用会随机展示连续的10行代码。</p><p>如果输入<code>l [函数名]</code>，那么就会展示函数名所在的上面5行和包括函数名所在行在内的下面5行，至少10行。</p><p>如果输入<code>l [行号]</code>，那么就会展示那行代码所在的上面5行和包括那行行在内的下面5行，至少10行。</p><p>如果继续按住<code>Enter</code>，那么会展示接下来的几行代码。因为gdb会自动记忆你上次敲入的指令。</p><h3 id="3-3-2-breakpoint（插入断点）">3.3.2 breakpoint（插入断点）</h3><p>简写为b。</p><pre><code>b 行号 —— 在那一行打断点</code></pre><p>如<code>b 20</code>就是在第20行打上断点。</p><pre><code>b 源文件：函数名 —— 在该函数的第一行打上断点</code></pre><p>如<code>b test.cpp: main</code>就是在源文件的该函数的第一行打上断点。</p><pre><code>b 源文件：行号 —— 在该源文件中的这行加上一个断点</code></pre><p>如<code>b test.cpp: 20</code>就是在源文件的第20行打上断点。</p><h3 id="3-3-3-info">3.3.3 info</h3><p>直接执行info命令，就会显示所有的调试信息。</p><pre><code>info b —— 查看断点的信息</code></pre><p>info b会展示以下信息：</p><pre><code>Num —— 编号Type —— 类型Disp —— 状态Enb —— 是否可用Address —— 地址What —— 在此文件的哪个函数以及此文件的第几行</code></pre><h3 id="3-3-4-删除断点">3.3.4 删除断点</h3><pre><code>d 编号 —— 删除此编号的断点d —— 删除所有断点</code></pre><h3 id="3-3-5-开启-禁用断点">3.3.5 开启/禁用断点</h3><pre><code>disable b —— 使所有断点无效disable b 编号 —— 使此编号的断点无效enable b —— 使所有断点有效enable b 编号 —— 使此编号的断点有效</code></pre><h3 id="3-3-6-run">3.3.6 run</h3><p>简写为r，无断点直接运行到底，有断点就运行到下一个断点然后停止。</p><h3 id="3-3-7-逐过程-和-单步调试">3.3.7 逐过程 和 单步调试</h3><p>next简写为n，为逐过程，会一行一行地执行源文件中的代码。</p><p>step简写为s，为单步调试，也是一行一行地执行源文件中的代码，不同的是，它还会跳转库函数的代码。</p><h3 id="3-3-8-打印-和-追踪">3.3.8 打印 和 追踪</h3><p>print简写为p，为打印</p><pre><code>p 变量名 —— 打印变量值</code></pre><p>display，为追踪</p><pre><code>display 变量名 —— 追踪查看一个变量，每次停下来都显示它的值</code></pre><p>undisplay为取消追踪</p><pre><code>undisplay + 变量名编号 —— 取消对该编号变量的跟踪</code></pre><h3 id="3-3-9-bt">3.3.9 bt</h3><p>bt命令用于查看当前调用了哪些函数。</p><h3 id="3-3-10-修改变量的值">3.3.10 修改变量的值</h3><pre><code>set var —— 修改变量的值</code></pre><p>如<code>set var i = 0</code>就是将变量i的值设为0。</p><h3 id="3-3-11-until">3.3.11 until</h3><pre><code>until 行号 —— 继续执行当前代码，直到执行到该行号为止。</code></pre><h3 id="3-3-12-finish">3.3.12 finish</h3><pre><code>finish —— 执行完当前所在函数后停止。</code></pre><p>finish应该就是单步跳出了。</p><h3 id="3-3-13-continue">3.3.13 continue</h3><p>简写为c。</p><pre><code>c —— 继续执行，直至下一个断点处停止。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GDB是Linux下非常好用且强大的调试工具。GDB可以调试C、C++等多种语言。&lt;/p&gt;
&lt;h1&gt;1. 判断文件是否带有调试信息&lt;/h1&gt;
&lt;p&gt;C/C++的编译文件有两种版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;release版本&lt;/li&gt;
&lt;li&gt;debug版本&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>左值引用 与 右值引用</title>
    <link href="http://malone-ai.github.io/2025/03/05/cpp-interview3/"/>
    <id>http://malone-ai.github.io/2025/03/05/cpp-interview3/</id>
    <published>2025-03-05T15:40:27.000Z</published>
    <updated>2025-03-06T03:15:19.939Z</updated>
    
    <content type="html"><![CDATA[<p>来复习总结一下左值引用与右值引用。</p><p>左值引用和右值引用是 C++ 中用于管理对象生命周期的两种引用类型，主要区别在于它们绑定的对象类型和使用场景</p><h1>左值引用（Lvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp; 声明的引用，只能绑定到 左值（有名字、有内存地址的对象）。</p><ol start="2"><li>特点</li></ol><ul><li>左值对象通常可以被修改（除非被 const 修饰）。</li><li>常用于函数参数传递（避免拷贝）或为现有对象起别名。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref_a = a;  <span class="comment">// 正确：左值引用绑定左值</span></span><br><span class="line"><span class="comment">// int&amp; ref_b = 10;  // 错误：不能绑定到右值（字面量）</span></span><br></pre></td></tr></table></figure><h1>右值引用（Rvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp;&amp; 声明的引用，只能绑定到 右值（临时对象、字面量、即将销毁的对象）。<br>2. 特点</p><ul><li>C++11 引入，用于实现<code>移动语义</code>和<code>完美转发</code>。</li><li>允许“窃取”右值的资源（如动态内存），避免不必要的拷贝。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span>;  <span class="comment">// 正确：右值引用绑定右值</span></span><br><span class="line"><span class="comment">// int&amp;&amp; rref2 = a;  // 错误：不能直接绑定左值</span></span><br></pre></td></tr></table></figure><h1>左值引用与右值引用的区别</h1><table><thead><tr><th>特性</th><th>左值引用 (&amp;)</th><th>右值引用 (&amp;&amp;)</th></tr></thead><tbody><tr><td>绑定对象类型</td><td>左值（持久对象）</td><td>右值（临时对象）</td></tr><tr><td>可修改性</td><td>允许修改（除非 const）</td><td>允许修改</td></tr><tr><td>主要用途</td><td>避免拷贝、别名</td><td>移动语义、完美转发</td></tr></tbody></table><h1>应用场景</h1><ol><li>移动语义（Move Semantics）</li></ol><p>右值引用允许将资源（如堆内存）从临时对象“移动”到新对象，避免深拷贝。</p><p>假设有一个管理动态数组的类 MyArray：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyArray</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当发生拷贝时（如 MyArray b = a），默认的拷贝构造函数会执行浅拷贝，导致两个对象共享同一块内存，引发双重释放等问题。为此，我们需要：</p><ul><li>深拷贝：显式实现拷贝构造函数，复制数据（安全但性能差）。</li><li>移动语义：直接“窃取”临时对象的资源（高效且安全）。</li></ul><p>移动语义的<code>核心机制</code><br>（1）右值引用（&amp;&amp;）<br>右值引用只能绑定到右值（临时对象、字面量、std::move 转换后的对象）。<br>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp;&amp; rref = <span class="built_in">MyArray</span>(<span class="number">100</span>);  <span class="comment">// 绑定到临时对象（右值）</span></span><br></pre></td></tr></table></figure><p>（2）移动构造函数和移动赋值运算符</p><ul><li>移动构造函数：接受右值引用参数，直接转移资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyArray</span>(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">    : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">    other.size_ = <span class="number">0</span>;        <span class="comment">// 原对象置空</span></span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;   <span class="comment">// 防止原对象析构时释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动赋值运算符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp; <span class="keyword">operator</span>=(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;      <span class="comment">// 释放当前资源</span></span><br><span class="line">        data_ = other.data_; <span class="comment">// 窃取资源</span></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么何时会触发移动语义？</p><p>场景 1：传递临时对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">createArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">arr</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> arr;  <span class="comment">// 返回时，arr 是右值，触发移动构造函数（而非拷贝）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray a = <span class="built_in">createArray</span>();  <span class="comment">// 移动构造</span></span><br></pre></td></tr></table></figure><p>场景 2：显式使用 std::move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);  <span class="comment">// 将左值 a 转为右值，触发移动构造</span></span><br><span class="line"><span class="comment">// 此时 a.data_ = nullptr，a 不可再使用！</span></span><br></pre></td></tr></table></figure><p>场景 3：标准库优化（如 vector::push_back）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;MyArray&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">MyArray</span>(<span class="number">1000</span>));  <span class="comment">// 传递右值，触发移动构造</span></span><br></pre></td></tr></table></figure><ol start="2"><li>完美转发（Perfect Forwarding）</li></ol><p>结合 std::forward 保持参数的值类别（左值/右值），是 C++ 中实现完美转发的核心机制，用于泛型编程。</p><p>假设你写了一个泛型包装函数 wrapper，它需要将参数传递给另一个函数 process：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);   <span class="comment">// 直接传递arg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里有一个问题：无论 arg 原始是左值还是右值，在 wrapper 内部，arg 始终是左值（因为它有名字，可以取地址）。因此，process 永远只能收到左值，无法触发右值重载的优化（如移动语义）。</p><p>使用std::forward可以解决这个问题。std::forward的作用是根据模板参数 T 的类型，有条件地将参数转换为左值或右值。修改后的 wrapper：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持 arg 的原始值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时：</p><ul><li>如果 arg 原始是左值，std::forward<T> 返回左值引用。</li><li>如果 arg 原始是右值，std::forward<T> 返回右值引用，从而允许移动语义。</li></ul><p>举个栗子：</p><p>定义两个 process 重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理左值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理右值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况 1：不使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);  <span class="comment">// arg 始终是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bad_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">bad_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理左值: 20 （但 20 是右值！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论传入左值还是右值，arg 在 bad_wrapper 内部都是左值，导致右值无法触发移动优化。</p><p>情况 2：使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持原始值类别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">good_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">good_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理右值: 20 （正确触发右值重载！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 std::forward 根据传入参数的值类别，正确选择 process 的左值或右值版本。</p><p>那么 std::forward 是如何做到的呢？是靠引用折叠规则。</p><p>引用折叠规则<br>当模板参数 T 推导为左值或右值时，T&amp;&amp; 会触发引用折叠：</p><ul><li>如果 T 是 X&amp;（左值引用），T&amp;&amp; 折叠为 X&amp;（仍是左值引用）。</li><li>如果 T 是 X 或 X&amp;&amp;，T&amp;&amp; 变为 X&amp;&amp;（右值引用）。</li></ul><p>简化版的 std::forward 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 T 是左值引用（如 int&amp;），T&amp;&amp; 折叠为 int&amp;，返回左值引用。</li><li>如果 T 是普通类型（如 int），T&amp;&amp; 是 int&amp;&amp;，返回右值引用。</li></ul><ol start="3"><li>优化临时对象</li></ol><p>通过 std::move 将左值显式转换为右值引用，触发移动操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; v1;</span><br><span class="line">std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s));  <span class="comment">// 移动 s 的资源到 vector，s 变为空</span></span><br></pre></td></tr></table></figure><h1>注意事项</h1><ol><li>右值引用本身是左值<br>右值引用变量有名字，因此是左值。若需继续传递右值，需用 std::move</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 是左值（有名字），若需传递给其他函数，需转为右值</span></span><br><span class="line">    <span class="built_in">another_process</span>(std::<span class="built_in">move</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>避免滥用 std::move<br>对局部变量使用 std::move 可能导致意外悬空引用。</li></ol><p>移动后的对象处于有效但未定义状态（通常被置空）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="comment">// a.data_ 变为 nullptr，不可再访问 a 的数据！</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>std::move 的本质<br>std::move 只是将对象强制转换为右值引用，本身不执行任何移动操作。真正的资源转移在移动构造函数或移动赋值运算符中完成。</p></li><li><p>异常安全<br>移动操作应标记为 noexcept，否则某些标准库操作（如 vector 扩容）可能回退到拷贝语义。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来复习总结一下左值引用与右值引用。&lt;/p&gt;
&lt;p&gt;左值引用和右值引用是 C++ 中用于管理对象生命周期的两种引用类型，主要区别在于它们绑定的对象类型和使用场景&lt;/p&gt;
&lt;h1&gt;左值引用（Lvalue Reference）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ol</summary>
      
    
    
    
    <category term="C/C++ 面试" scheme="http://malone-ai.github.io/categories/C-C-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C++" scheme="http://malone-ai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 里的 lower_bound 和 upper_bound</title>
    <link href="http://malone-ai.github.io/2025/03/04/chores1/"/>
    <id>http://malone-ai.github.io/2025/03/04/chores1/</id>
    <published>2025-03-04T15:20:21.000Z</published>
    <updated>2025-03-06T03:16:40.738Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++ 中，lower_bound 和 upper_bound 是标准库 <algorithm> 中提供的两个非常实用的函数，用于在已排序的序列中进行二分查找。它们的功能和用法非常相似，但在细节上有一些区别。</p><h1>使用条件</h1><p>由于 lower_bound 和 upper_bound 底层是基于二分查找的，故lower_bound 和 upper_bound 都要求输入的序列是已排序的（默认是升序）。</p><h1>lower_bound 的功能</h1><p>lower_bound 用于在已排序的序列中查找第一个大于或等于目标值的元素的位置。通俗地讲，就是在这个序列中为目标值找一个位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于或等于 value 的元素的迭代器。如果所有元素都小于 value，则返回 last。</li></ul><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt;= 6 is 7 at index 3</code></pre><h1>upper_bound 的功能</h1><p>upper_bound 用于在已排序的序列中查找第一个大于目标值的元素的位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于 value 的元素的迭代器。如果所有元素都小于或等于 value，则返回 last。</li></ul><p>参数与lower_bound相同，返回值就不同了。</p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt; 6 is 7 at index 3</code></pre><h1>lower_bound 和 upper_bound 的区别</h1><table><thead><tr><th>特性</th><th><code>lower_bound</code></th><th><code>upper_bound</code></th></tr></thead><tbody><tr><td><strong>查找条件</strong></td><td>第一个 <strong>大于或等于</strong> 目标值的元素</td><td>第一个 <strong>大于</strong> 目标值的元素</td></tr><tr><td><strong>返回值</strong></td><td>指向第一个满足条件的元素的迭代器</td><td>指向第一个满足条件的元素的迭代器</td></tr><tr><td><strong>目标值存在时</strong></td><td>返回目标值的第一个位置</td><td>返回目标值的下一个位置</td></tr><tr><td><strong>目标值不存在时</strong></td><td>返回第一个大于目标值的位置</td><td>返回第一个大于目标值的位置</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 C++ 中，lower_bound 和 upper_bound 是标准库 &lt;algorithm&gt; 中提供的两个非常实用的函数，用于在已排序的序列中进行二分查找。它们的功能和用法非常相似，但在细节上有一些区别。&lt;/p&gt;
&lt;h1&gt;使用条件&lt;/h1&gt;
&lt;p&gt;由于 lower_</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划六：最长递增子序列</title>
    <link href="http://malone-ai.github.io/2025/03/04/dp6/"/>
    <id>http://malone-ai.github.io/2025/03/04/dp6/</id>
    <published>2025-03-04T12:08:05.000Z</published>
    <updated>2025-03-05T15:37:14.044Z</updated>
    
    <content type="html"><![CDATA[<p>今日学习灵茶山艾府出品的<a href="https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">最长递增子序列【基础算法精讲 20】</a>。</p><p>UP通过Leetcode官方题<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列</a>进行讲解。</p><h1>300. 最长递增子序列</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p><code>子序列</code>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><h1>基本思路</h1><p>由于子序列是数组的一个子集，因此用子集型回溯来思考，也就是[选或不选]或者[枚举选哪个]。</p><p>对于nums = [1, 6, 7, 2, 4, 5, 3]：</p><ul><li>如果我们倒着思考，假设3是严格递增子序列中的最后一个数，考虑选或不选，需要与前面的数字进行比较，需要知道当前数的下标以及上一个数的下标。</li><li>如果考虑枚举选哪个，可以直接枚举3前面比3小的数字，当作严格递增子序列的倒数第二个数，只需要知道当前数字的下标即可。</li></ul><p>经过对比，枚举选哪个的思路只需要一个参数，更方便。</p><p>因此最终的思路为：<br>- 枚举以nums[i]结尾的严格递增子序列的长度<br>- 接着需要枚举以nums[j]为倒数第二个元素的严格递增子序列的长度<br>- 其中j &lt; i，nums[j] &lt; nums[i]</p><p>以下是灵茶山艾府总结的回溯三问：</p><ul><li>子问题？以nums[i]结尾的严格递增子序列的长度</li><li>当前操作？枚举nums[j]</li><li>下一个子问题？以nums[j]结尾的严格递增子序列的长度</li></ul><p>定义dfs(i)为以nums[i]结尾的严格递增子序列的长度，枚举满足要求的nums[j]，子问题就变成了以nums[j]结尾的严格递增子序列的长度，这些子问题求个最大值再+1，就得到了以nums[i]结尾的严格递增子序列的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i) = max&#123;dfs(j)&#125; + 1， j &lt; i &amp;&amp; nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure><h1>递归</h1><p>递归实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// dfs(i)表示以nums[i]结尾的严格递增子序列的长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(j), res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ++res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，一定要将i = 0 ~ n - 1当参数传给dfs，也就是最后的循环里挨个调用。如果直接dfs(n-1)的话，只有当j &lt; i &amp;&amp; nums[j] &lt; nums[i]的时候才能递归到其他状态，可能会导致0~n-2中的某些递归不到。并且dfs(n-1)的意义是以nums[n-1]结尾的严格递增子序列的长度，但是最长的严格递增子序列并不一定以nums[n-1]结尾，也可能是以前面的某个数字结尾。</p><h1>递推</h1><p>递归很容易翻译成递推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++f[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>贪心 + 二分</h1><p>这一块开始听不懂了，主要感觉灵茶山艾府的证明不是很清晰。</p><p>通过贪心 + 二分查找求解<code>最长严格递增子序列（LIS）</code>问题的核心思想是：<code>尽可能地让递增子序列的末尾元素更小，从而为后续的元素提供更多的扩展机会</code>。</p><h2 id="贪心思想">贪心思想</h2><p>贪心算法的核心是：在每一步选择中，都采取当前最优的策略，从而希望最终得到全局最优解。</p><p>在这个问题中，我们希望找到一个尽可能长的递增子序列。为了达到这个目标，我们需要让子序列的末尾元素尽可能小，因为较小的末尾元素更容易被后续的元素扩展。</p><p>因此，贪心策略是<code>对于相同长度的递增子序列，我们只保留末尾元素最小的那个</code>。</p><p>g[i] 表示长度为 i+1 的递增子序列的最小末尾元素</p><h2 id="二分查找的作用">二分查找的作用</h2><p>对于每个新元素 num，我们需要找到它在 g 中的位置：</p><ul><li>如果 num 比 g 中的所有元素都大，说明它可以扩展当前的最长递增子序列，因此将其添加到 g 的末尾。</li><li>否则，找到 g 中第一个大于等于 num 的位置 pos，并用 num 替换 g[pos]。这是因为 num 可以作为一个更小的末尾元素来构成长度为 pos+1 的递增子序列。</li></ul><p>通过二分查找，我们可以在 O(log n) 的时间内找到 num 应该插入或替换的位置，从而保证算法的高效性。</p><h2 id="为什么贪心-二分查找是正确的？">为什么贪心 + 二分查找是正确的？</h2><p>我们需要证明：通过贪心策略维护的数组 g，最终的长度就是最长递增子序列的长度。</p><p>关键点：</p><ol><li><p>g 的长度就是 LIS 的长度：</p><ul><li>每次向 g 中添加一个新元素时，都意味着我们发现了一个更长的递增子序列。</li><li>每次替换 g 中的元素时，只是优化了相同长度的递增子序列的末尾元素，而不会改变 g 的长度。</li></ul></li><li><p>g 的严格递增性：</p><ul><li>由于我们总是用更小的元素替换 g 中的元素，g 始终保持严格递增。</li><li>这种性质保证了我们可以通过二分查找快速定位 num 应该插入或替换的位置。</li></ul></li><li><p>替换操作不会影响最终结果：</p><ul><li>当我们用 num 替换 g[pos] 时，虽然我们改变了长度为 pos+1 的递增子序列的末尾元素，但这并不影响更长递增子序列的构建。</li><li>因为 num 比原来的 g[pos] 更小，它为后续的元素提供了更多的扩展机会。</li></ul></li></ol><h2 id="一个例子">一个例子</h2><p>假设 nums = [10, 9, 2, 5, 3, 7, 101, 18]，我们通过贪心 + 二分查找来求解：</p><ul><li>初始化 g = []。</li><li>遍历 nums：<ol><li>num = 10：<ul><li>g 为空，直接添加：g = [10]。</li></ul></li><li>num = 9：<ul><li>找到第一个大于等于 9 的位置是 0，替换：g = [9]。</li></ul></li><li>num = 2：<ul><li>找到第一个大于等于 2 的位置是 0，替换：g = [2]。</li></ul></li><li>num = 5：<ul><li>5 比 g 中的所有元素都大，添加到末尾：g = [2, 5]。</li></ul></li><li>num = 3：<ul><li>找到第一个大于等于 3 的位置是 1，替换：g = [2, 3]。</li></ul></li><li>num = 7：<ul><li>7 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7]。</li></ul></li><li>num = 101：<ul><li>101 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7, 101]。</li></ul></li><li>num = 18：<ul><li>找到第一个大于等于 18 的位置是 3，替换：g = [2, 3, 7, 18]。</li></ul></li></ol></li></ul><p>最终，g 的长度是 4，因此最长递增子序列的长度是 4。</p><p>这种方法的时间复杂度是 O(n log n)，空间复杂度是 O(n)，是一种非常高效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心 + 二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;num: nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), num);</span><br><span class="line">            <span class="keyword">if</span> (it == g.<span class="built_in">end</span>())</span><br><span class="line">                g.<span class="built_in">emplace_back</span>(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>变形</h1><p>如果允许最长递增子序列中有重复元素，那么按照<code>贪心+二分</code>的思路，在g中需要寻找的就是第一个大于（原来是大于等于）num的位置，也就是把原来使用的lower_bound改成upper_bound即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日学习灵茶山艾府出品的&lt;a href=&quot;https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.1387.collection.video_card.click&amp;amp;vd_source=a0f19e79</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 集成Element-Plus</title>
    <link href="http://malone-ai.github.io/2025/03/04/project-test2/"/>
    <id>http://malone-ai.github.io/2025/03/04/project-test2/</id>
    <published>2025-03-04T08:29:23.000Z</published>
    <updated>2025-03-04T10:24:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1GLKweAEHj/?spm_id_from=333.1245.0.0">【带小白做毕设】02. 使用Vue3集成Element-Plus快速搭建一个管理系统的页面</a>并进行一个学习记录。</p><h1>Element-Plus</h1><p>Element-Plus 是一套前端 UI 框架，提供了许多精美的样式，Ctrl-C + Ctrl-V即可使用。<a href="https://element-plus.org/zh-CN/">官网跳转</a>。</p><p>使用以下命令安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-plus -S</span><br></pre></td></tr></table></figure><p>在main.js中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/css/global.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>) <span class="comment">// 这一行</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后直接从官网找到以下代码粘贴到Home.vue体验：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    主页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span>&gt;</span>Info<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span>&gt;</span>Warning<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span>&gt;</span>Danger<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1>使用 icon</h1><p>首先安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @element-plus/icons-vue</span><br></pre></td></tr></table></figure><p>然后需要从 @element-plus/icons-vue 中导入所有图标并进行全局注册：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您正在使用CDN引入，请删除下面一行。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ElementPlusIconsVue</span> <span class="keyword">from</span> <span class="string">&#x27;@element-plus/icons-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, component] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="title class_">ElementPlusIconsVue</span>)) &#123;</span><br><span class="line">  app.<span class="title function_">component</span>(key, component)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环部分放在main.js的末尾即可。</p><p>然后就可以从官网复制一个icon放到Home.vue中即可使用icon了。</p><p>使用图标:</p><ul><li>el-input：当你在输入框组件里面使用图标，你需要单独导入图标</li><li>el-icon、el-button：按钮或者图标组件里面，不需要单独导入图标</li></ul><h1>Element-Plus 主题色设置</h1><p>安装依赖 sass、unplugin-vue-components、unplugin-auto-import</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D sass unplugin-vue-components unplugin-auto-import</span><br></pre></td></tr></table></figure><p>配置index.scss放在 src/assets/css 目录下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@forward <span class="string">&quot;element-plus/theme-chalk/src/common/var.scss&quot;</span> <span class="title function_">with</span>(</span><br><span class="line">    <span class="attr">$colors</span>:(</span><br><span class="line">            <span class="string">&quot;primary&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #2c82ff),</span><br><span class="line">            <span class="string">&quot;success&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #31bf00),</span><br><span class="line">            <span class="string">&quot;warning&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #ffade0),</span><br><span class="line">            <span class="string">&quot;danger&quot;</span>:   (<span class="string">&quot;base&quot;</span>:  #e52f2f), </span><br><span class="line">            <span class="string">&quot;info&quot;</span>:     (<span class="string">&quot;base&quot;</span>: #8855ff),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置vite.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span><span class="string">&#x27;unplugin-auto-import/vite&#x27;</span><span class="comment">//自动导入vue中的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span><span class="comment">//自动导入ui-组件 比如 element-plus等</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span><span class="comment">//对应组件引入</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line"><span class="comment">//element-plus按简导入</span></span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [</span><br><span class="line">            <span class="comment">//配置elementPlus采用sass样式配置系统</span></span><br><span class="line">            <span class="title class_">ElementPlusResolver</span>(&#123;<span class="attr">importStyle</span>:<span class="string">&quot;sass&quot;</span>&#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="attr">css</span>:&#123;</span><br><span class="line">  <span class="attr">preprocessorOptions</span>:&#123;</span><br><span class="line">    <span class="attr">scss</span>: &#123;</span><br><span class="line">      <span class="attr">additionalData</span>: <span class="string">`@use&quot;@/assets/css/index.scss&quot; as *;`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1>创建后台基本框架</h1><p>创建vue/src/views/Manager.vue文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1GLKweAEHj/?spm_id_from=333.1245.0.0&quot;&gt;【带小白做毕设】02. 使用Vue3集成Element-Plus快速搭建一个管理</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端" scheme="http://malone-ai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="http://malone-ai.github.io/tags/Vue/"/>
    
    <category term="Element-Plus" scheme="http://malone-ai.github.io/tags/Element-Plus/"/>
    
  </entry>
  
  <entry>
    <title>前端 Vue3 框架搭建</title>
    <link href="http://malone-ai.github.io/2025/03/04/project-test1/"/>
    <id>http://malone-ai.github.io/2025/03/04/project-test1/</id>
    <published>2025-03-04T02:56:11.000Z</published>
    <updated>2025-03-04T12:12:01.727Z</updated>
    
    <content type="html"><![CDATA[<p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV16dKHeiE92?spm_id_from=333.788.videopod.sections&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】01. 前端Vue3 框架的快速搭建以及项目工程的讲解</a>并进行一个学习记录。</p><h1>安装NodeJS</h1><p>vue3 建议 nodejs v22.14.0，npm 版本 10.9.2<br>使用安装包安装nodejs时，会自动配置Node和npm的环境变量。<br>npm要配置淘宝镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h1>搭建Vue工程</h1><p>创建一个工程目录（我就叫它Project吧），在工程目录下打开CMD，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure><p>然后会让你输入项目名称，我起名为vue。</p><p>紧接着会让你选择<br>√ 是否使用 TypeScript 语法？ 选否<br>√ 是否启用 JSX 支持？ 选否<br>√ 是否引入 Vue Router 进行单页面应用开发？ 选是<br>√ 是否引入 Pinia 用于状态管理？ 选否<br>√ 是否引入 Vitest 用于单元测试？ 选否<br>√ 是否要引入一款端到端（End to End）测试工具？ » 选不需要<br>√ 是否引入 ESLint 用于代码质量检测？ » 选否</p><p>也就是除了“是否引入 Vue Router 进行单页面应用开发？”选是以外，其余均选择否或者不需要。</p><p>然后会提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目初始化完成，可执行以下命令：</span><br><span class="line"></span><br><span class="line">  cd vue</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure><p>输入<code>cd vue</code>，进入vue的工程目录。</p><p>然后输入<code>npm install</code>安装依赖，并且会有类似提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">added 147 packages <span class="keyword">in</span> 20s</span><br><span class="line"></span><br><span class="line">43 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p>再输入<code>npm run dev</code>即可运行这个vue项目，会有提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VITE v6.2.0  ready <span class="keyword">in</span> 585 ms</span><br><span class="line"></span><br><span class="line">➜  Local:   http://localhost:5173/</span><br><span class="line">➜  Network: use --host to expose</span><br><span class="line">➜  Vue DevTools: Open http://localhost:5173/__devtools__/ as a separate window</span><br><span class="line">➜  Vue DevTools: Press Alt(⌥)+Shift(⇧)+D <span class="keyword">in</span> App to toggle the Vue DevTools</span><br><span class="line">➜  press h + enter to show <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>在浏览器中输入网址：<a href="http://localhost:5173/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E8%BF%99%E4%B8%AAvue%E9%A1%B9%E7%9B%AE%E3%80%82">http://localhost:5173/，即可查看这个vue项目。</a></p><h1>Vue 工程精简</h1><p>使用idea打开Project目录（也就是上面vue工程目录的上一级目录）。</p><p>目前工程目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─.idea</span><br><span class="line">└─vue</span><br><span class="line">    ├─.vscode</span><br><span class="line">    ├─node_modules</span><br><span class="line">    ├─public</span><br><span class="line">    ├─src</span><br><span class="line">    │   ├─assets</span><br><span class="line">    │   ├─components</span><br><span class="line">    │   │  └─icons</span><br><span class="line">    │   ├─router</span><br><span class="line">    │   └─views</span><br><span class="line">    ├─.gitignore</span><br><span class="line">    ├─index.html</span><br><span class="line">    ├─jsconfig.json</span><br><span class="line">    ├─package.json</span><br><span class="line">    ├─package-lock.json</span><br><span class="line">    ├─README.md</span><br><span class="line">    └─vite.config.js</span><br></pre></td></tr></table></figure><p>.vscode、.gitignore、README.md三个文件不需要，直接删除。</p><p>找到设置，输入enc，点击<code>File Encodings</code>，把global Encodings、Project Encodings、Default encoding for properties files全部设为<code>UTF-8</code>，并勾选Transparent native-to-ascii conversion。</p><p>还有一些文件也是不需要的，继续删除以下文件：</p><ul><li>vue/src/assets目录下的base.css、main.css</li><li>vue/src/components下的所有文件和文件夹</li><li>vue/src/views 目录下的AboutView.vue</li></ul><p>将vue/src/views/HomeView.vue的内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        主页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>并将HomeView.vue重命名为Home.vue</p><p>将vue/src/App.vue的内容编辑为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;RouterView /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>vue/src/router/index.js的内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vue/src/main.js的第一行有对vue/src/assets/main.css的导入，但是其已被我们删除，故将这一行删除。</p><h1>Vue 工程目录解读</h1><ul><li>node_modules：依赖包存放文件</li><li>public：存放全局静态文件</li><li>src：<ul><li>assets：存放代码引用的静态文件，css、js等</li><li>components：存放vue的组件（可复用代码块）</li><li>router：存放路由文件的目录</li><li>views：存放vue网页的目录</li><li>App.vue：vue页面全局入口</li><li>main.js：全局的配置文件，引入第三方的组件或者自定义的组件</li></ul></li><li>index.html：vue编译成的网页</li><li>package.json：定义依赖库的文件</li><li>package-lock.json：安装依赖时用于锁定版本的文件</li><li>vite.config.js：全局的配置文件</li></ul><h1>全局css</h1><p>在vue/src/assets目录下新建css目录，再在css目录下新建global.css文件（全局样式表），内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    box-<span class="attr">sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    <span class="attr">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">color</span>: #<span class="number">333</span>;</span><br><span class="line">    font-<span class="attr">size</span>: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">    text-<span class="attr">decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在main.js文件中引用，添加这行代码即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/css/global.css&#x27;</span></span><br></pre></td></tr></table></figure><h1>定义404页面</h1><p>将一张404的图片放在vue/src/assets/imgs目录下，在vue/src/views目录下新建404.vue，编辑内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div style=&quot;height: 100vh; display: flex; align-items: center; justify-content: center&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;img style=&quot;width: 100%&quot; src=&quot;@/assets/imgs/404.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;div style=&quot;text-align: center; padding: 20px 0; font-size: 20px; color: #3741fb&quot;&gt;&lt;a href=&quot;/&quot;&gt;返回主页&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后定义路由，在vue/src/router/index.js文件中一行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),&#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/notFount&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/404.vue&#x27;</span>),&#125;, <span class="comment">// 添加的那行代码</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>此时访问<a href="http://localhost:5174/notFount%E5%B0%B1%E4%BC%9A%E8%B7%B3%E8%BD%AC%E5%88%B0404%E9%A1%B5%E9%9D%A2%E3%80%82%E4%BD%86%E5%85%B6%E5%AE%9E%E6%88%91%E4%BB%AC%E6%83%B3%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%98%AF%E5%8F%AA%E8%A6%81%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B7%AF%E7%94%B1%E5%B0%B1%E8%B7%B3%E8%BD%AC404%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:5174/notFount就会跳转到404页面。但其实我们想实现的是只要访问一个未定义的路由就跳转404页面。</a></p><p>只需要再在index.js中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/notFound&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV16dKHeiE92?spm_id_from=333.788.videopod.sections&amp;amp;vd_source=a0f19e79b7da02f</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端" scheme="http://malone-ai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="http://malone-ai.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>智能指针模板类：auto_ptr，shared_ptr，unique_ptr</title>
    <link href="http://malone-ai.github.io/2025/03/03/cpp-interview2/"/>
    <id>http://malone-ai.github.io/2025/03/03/cpp-interview2/</id>
    <published>2025-03-03T06:54:44.000Z</published>
    <updated>2025-03-06T03:15:26.500Z</updated>
    
    <content type="html"><![CDATA[<p>今日通过阅读《c++ Primer Plus》来学习一下智能指针。部分内容参考<a href="https://blog.csdn.net/weixin_45031801/article/details/140594215">【C++11】智能指针深度详解（什么是智能指针？为什么需要智能指针？如何使用智能指针？）</a>（CSDN博客链接，点击即可跳转）。</p><h1>What is it ?</h1><p><code>智能指针</code>这个名词听着挺唬人，其实也没啥，无非就是会自动销毁 new 出来的对象，避免内存泄漏。毕竟 C/C++ 没有类似<code>Java</code>的垃圾回收机制，需要手动释放 new 出来的对象，<code>智能指针</code>可以自动地完成这个工作。</p><h1>Why ? 为什么需要智能指针？</h1><p>先看这个函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string* ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的缺陷就是忘了释放new出来的内存，但是只要别忘了return前加上<code>delete ps</code>释放内存。</p><p>但是但凡是涉及<code>别忘了</code>的解决方法，往往不佳。即使没有忘记，依然可能出现问题，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string* ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现异常时，将不会执行delete ps，导致内存泄漏。</p><p>当remodel()这样的函数终止(不管是正常终止，还是由于出现了异常而终止)，本地变量都将从栈内存中删除，因此指针ps占据的内存将被释放。</p><p>如果ps指向的内存也被释放，就nice了。</p><p>如果ps有一个<code>析构函数</code>，该析构函数将在ps过期时释放它指向的内存。如果ps是对象，则可以在对象过期时，让它的析构函数删除指向的内存。这正是为什么出现<code>auto_ptr</code>、<code>unique_ptr</code>和<code>shared _ptr</code>的原因了。</p><h1>使用智能指针</h1><p>要创建智能指针对象，就得包含头文件memory。</p><p>模板auto_ptr的构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="explicit">explicit</h2><p><code>explicit</code>关键字用于<code>禁止隐式类型转换</code>。</p><ol><li><p>隐式转换是什么？<br>隐式转换是指编译器在不需要显式调用构造函数或转换函数的情况下，自动将一种类型转换为另一种类型。<br>例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 隐式调用 MyClass(10)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，func(10) 会自动调用 MyClass(int x) 构造函数，将 int 隐式转换为 MyClass 对象。</p></li><li><p>隐式转换在<code>auto_ptr</code>中的问题<br>假设 auto_ptr 的构造函数没有 explicit：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(X* p = <span class="number">0</span>) <span class="keyword">throw</span>() : <span class="built_in">ptr</span>(p) &#123;&#125; <span class="comment">// 没有 explicit</span></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">X* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    X* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// 隐式调用构造函数</span></span><br></pre></td></tr></table></figure><ul><li>发生了什么？<ol><li>new int(5) 返回一个 int* 类型的指针。</li><li>由于 auto_ptr 的构造函数没有 explicit，编译器会自动调用 auto_ptr<int>(int*) 构造函数，将 int* 隐式转换为 auto_ptr<int>。</li><li>最终，ap 是一个 auto_ptr<int> 对象，接管了 new int(5) 返回的指针。</li></ol></li></ul><ol start="3"><li><p>为什么隐式转换会导致问题？<br>隐式转换可能导致以下问题：<br>(1) 意外的所有权转移<br>auto_ptr 的核心特性是<code>独占所有权</code>，即一个 auto_ptr 对象独占一个资源，不能有多个 auto_ptr 对象同时管理同一个资源。</p><p>如果允许隐式转换，以下代码会导致意外的所有权转移：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// ap1 接管指针</span></span><br><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap2 = ap1;         <span class="comment">// ap1 的所有权转移到 ap2</span></span><br></pre></td></tr></table></figure><ul><li>在第二行，ap1 的所有权被转移到 ap2，ap1 变为空指针。</li><li>如果后续代码继续使用 ap1，会导致未定义行为（如访问空指针）。</li></ul></li></ol><p>(2) 资源管理问题<br>隐式转换可能导致资源泄漏或重复释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(auto_ptr&lt;<span class="type">int</span>&gt; ap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* raw_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(raw_ptr);  <span class="comment">// 隐式转换，raw_ptr 的所有权被转移</span></span><br><span class="line">    <span class="comment">// 此时 raw_ptr 已被释放，后续访问会导致未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>func(raw_ptr) 隐式调用了 auto_ptr<int>(int*) 构造函数，raw_ptr 的所有权被转移到 func 的参数 ap。</li><li>当 func 返回时，ap 被销毁，raw_ptr 指向的内存被释放。</li><li>如果后续代码继续使用 raw_ptr，会导致未定义行为。</li></ul><p>因此，通过将构造函数声明为 explicit，可以禁止隐式转换，强制要求显式调用构造函数。</p><h2 id="noexcept">noexcept</h2><p><code>noexcept</code>表示auto_ptr类的构造函数保证不会抛出任何异常。<br>如果函数声明了 noexcept 但实际上抛出了异常，程序会调用 std::unexpected()，通常导致程序终止。</p><h2 id="使用智能指针">使用智能指针</h2><p>继续回过头看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后申请X类型的auto_ptr将获得一个指向X类型的auto_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>; <span class="comment">// pd是一个指向double类型的auto_ptr</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string)</span></span>; <span class="comment">// ps是一个指向string的auto_ptr</span></span><br></pre></td></tr></table></figure><p>new double 是new 返回的指针，指向new出来的内存块。new double 是构造函数auto_ptr<double>的参数，对应于原型中形参p的实参。同样，new string也是构造函数的实参。其他两种智能指针的使用也是同样的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">double</span>&gt; <span class="title">pdu</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>; <span class="comment">// pd 是一个指向double的unique_ptr</span></span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">pss</span><span class="params">(<span class="keyword">new</span> string)</span></span>; <span class="comment">// pd 是一个指向string的shared_ptr</span></span><br></pre></td></tr></table></figure><p>要改造先前的remodel()函数，需要包含memory头文件、将指向string的指针改为指向string的智能指针、删除delete语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::string* ps = new std::string(str);</span></span><br><span class="line">    <span class="function">std::auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> std::string(str))</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="comment">// delete ps;</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于所有的智能指针类的构造函数都有<code>explicit</code>关键字修饰，该构造函数将指针作为参数，并且要显式地调用构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pd;</span><br><span class="line"><span class="type">double</span> *p_reg = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">pd = p_reg; <span class="comment">// 错误，使用了隐式转换</span></span><br><span class="line">pd = <span class="built_in">shared_ptr</span>&lt;<span class="type">double</span>&gt;(p_reg); <span class="comment">// 正确，显示转换</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pshared = p_reg; <span class="comment">// 错误，使用了隐式转换</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">double</span>&gt; <span class="title">pshared</span><span class="params">(p_reg)</span></span>;  <span class="comment">// 正确，显示转换</span></span><br></pre></td></tr></table></figure><p>此外，三类智能指针都应该避免一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vacation</span><span class="params">(<span class="string">&quot;I wandered lonely as a cloud.&quot;</span>&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">shared_ptr&lt;string&gt; pvac(&amp;vacation);</span></span></span><br></pre></td></tr></table></figure><p>pvac的生命周期时，自动释放其指向的内存，这回导致delete一个不是new出来的内存。</p><p>对于auto_ptr，对于以下赋值语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; vocation;</span><br><span class="line">vocation = ps;</span><br></pre></td></tr></table></figure><p>它有明显的bug，因为ps和vocation的生命周期结束时，ps的析构函数会将这块new出来的内存释放一次，vocation的析构函数又会再释放一次。</p><p>可以采用以下方法解决：</p><ul><li>重载赋值运算符，使用深拷贝</li><li>建立所有权的概念，对于特定的对象，只允许一个智能指针可以拥有它。这样只有拥有该对象的智能指针的析构函数会删除该对象。auto_ptr和unique_ptr采用此策略</li><li>创建更智能的指针，跟踪引用特定对象的智能指针的个数（称为引用计数）。例如，赋值时，计数将+1，而指针的生命周期结束时，计数-1。只有当最后一个指针的生命周期也结束时，才delete。shared_ptr采用此策略。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日通过阅读《c++ Primer Plus》来学习一下智能指针。部分内容参考&lt;a href=&quot;https://blog.csdn.net/weixin_45031801/article/details/140594215&quot;&gt;【C++11】智能指针深度详解（什么是智能指针？</summary>
      
    
    
    
    <category term="C/C++ 面试" scheme="http://malone-ai.github.io/categories/C-C-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
    <category term="智能指针" scheme="http://malone-ai.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>动态规划五：线性DP</title>
    <link href="http://malone-ai.github.io/2025/03/02/dp5/"/>
    <id>http://malone-ai.github.io/2025/03/02/dp5/</id>
    <published>2025-03-02T14:15:51.000Z</published>
    <updated>2025-03-03T04:46:20.257Z</updated>
    
    <content type="html"><![CDATA[<p>今日继续学习灵茶山艾府的基础算法精讲系列中的<a href="https://www.bilibili.com/video/BV1TM4y1o7ug/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">最长公共子序列 编辑距离【基础算法精讲 19】</a>（本文内容参考该视频，点击即可跳转视频，非商业引用，侵权联系删）。</p><p>灵茶山艾府主要通过两道Leetcode题进行讲解：<a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a>和<a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离</a>。</p><h1>1143. 最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长<code>公共子序列</code>的长度。如果不存在<code>公共子序列</code>，返回 0 。</p><p>一个字符串的<code>子序列</code>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li></ul><p>两个字符串的<code>公共子序列</code>是这两个字符串所共同拥有的子序列。</p><p>公共子序列就是两个字符串都有的子序列，我们需要计算所有公共子序列中的最长长度。</p><p>把两个字符串分别设为s和t，长度设为n和m，和背包问题一样，子序列也是考虑每个字符<code>选或不选</code>，从最后一个字母开始考虑，s的最后一个字母设为x，t的最后一个字母设为y，分为四种情况：</p><ul><li>不选x，不选y</li><li>不选x，选y</li><li>选x，不选y</li><li>选x，选y</li></ul><p>上述是灵茶山艾府给出的启发思路，再来看看他总结的回溯三问：</p><ul><li>当前操作？考虑s[i]和t[j]选或不选</li><li>子问题？s的前i个字母和t的前j个字母的LCS长度</li><li>下一个子问题？<ul><li>s的前i-1个字母和t的前j-1个字母的LCS长度</li><li>s的前i-1个字母和t的前j个字母的LCS长度</li><li>s的前i个字母和t的前j-1个字母的LCS长度</li></ul></li></ul><p>这样可以确定递归参数中的i和j表示的子问题，就是s的前i个字母和t的前j个字母的LCS长度。</p><p>另外注意，都选和都不选两种情况的下一个子问题是一样的，并且只有s[i] == t[j]的时候才能都选。</p><p>可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">    <span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] != t[j])</span><br><span class="line">    <span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>));</span><br></pre></td></tr></table></figure><p>可以简化成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>)) + (s[i] == t[j]);</span><br></pre></td></tr></table></figure><p>然后灵茶山艾府提出了两个问题：</p><ol><li>在s[i] == t[j]的时候，我们需要考虑只选其中一个的情况吗？</li><li>在s[i] != t[j]的时候，我们需要考虑都不选的情况吗？</li></ol><p>答案是都不需要。灵茶山艾府对这一块的讲解有点没听明白，谈谈自己的理解。</p><p>对于问题<code>在s[i] == t[j]的时候，我们需要考虑只选其中一个的情况吗？</code>，我认为反证法更好理解。</p><p>假设在 s[i] == t[j] 时，我们不将这两个字符加入 LCS 中，而是选择忽略其中一个。那么：</p><ul><li>如果忽略s[i]，那么 LCS 的长度最多是 dfs(i-1, j)。</li><li>如果忽略t[j]，那么 LCS 的长度最多是 dfs(i, j-1)。</li></ul><p>然而，如果我们选择将 s[i] 和 t[j] 加入 LCS 中，那么 LCS 的长度是 dfs(i-1, j-1) + 1。由于 dfs(i-1, j-1) + 1 一定大于或等于 dfs(i-1, j) 或 dfs(i, j-1)，因此选择匹配这两个字符一定不会使结果变差，反而可能使结果更好。</p><p>因此s[i] === t[j]时，我们只需要考虑都选的情况就可以了。</p><p>对于问题<code>在s[i] != t[j]的时候，我们需要考虑都不选的情况吗？</code></p><p>如果 s 的第 i 个字符和 t 的第 j 个字符不相等，此时，我们需要考虑两种情况：</p><ul><li>忽略 s[i]，即只考虑 s 的前 i-1 个字符和 t 的前 j 个字符的 LCS。</li><li>忽略 t[j]，即只考虑 s 的前 i 个字符和 t 的前 j-1 个字符的 LCS。</li></ul><p>然后，我们取这两种情况的最大值。</p><ul><li>为什么不需要考虑“都不选”的情况？<br>因为“都不选”的情况已经被包含在上述两种情况中了。如果我们既不选 s[i] 也不选 t[j]，那么这种情况等价于 dfs(i-1, j-1)。而在 s[i] != t[j] 时，dfs(i-1, j-1)的值一定小于或等于 dfs(i-1, j) 或 dfs(i, j-1)，所以不需要单独考虑。</li></ul><h2 id="递归解法">递归解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// dfs(i, j)表示s[0...i-1]和t[0...j-1]的LCS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>)), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>) + (s[i] == t[j]));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(nm)，空间复杂度也为O(nm)。</p><h2 id="递推">递推</h2><p>能否继续优化空间复杂度？Of course！</p><p>先改为递推（空间复杂度仍为O(nm)）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[i<span class="number">+1</span>][j], f[i][j<span class="number">+1</span>]), f[i][j] + (s[i] == t[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两个数组">两个数组</h3><p>很容易优化成以下空间复杂度为O(m)的形式（使用两个数组）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[(i<span class="number">+1</span>) % <span class="number">2</span>][j], f[i % <span class="number">2</span>][j<span class="number">+1</span>]), f[i % <span class="number">2</span>][j] + (s[i] == t[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一个数组">一个数组</h3><p>画个图很容易发现，当前状态由左边、上边以及左上三个状态转移而来，当前状态还需要参与右边状态的转移，此时存在覆盖问题，因此用一个pre临时存储一下当前状态转移之前的值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pre = f[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = f[j<span class="number">+1</span>];</span><br><span class="line">                f[j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[j], f[j<span class="number">+1</span>]), pre + (s[i] == t[j]));</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>72. 编辑距离</h1><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。<br>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>依然记它们分别为s和t，基于上述三种操作把s改成t。</p><p>分析方法和上一题类似。</p><p><code>删除</code>一个字母相当于去掉s[i]。</p><p><code>插入</code>一个字母的话，由于需要保持和t[j]一样，那s插入一个字母相当于去掉t[j]。</p><p>如果s[i] == t[j]，那么就都去掉。</p><p>如果s[i] != t[j]则可以通过<code>替换</code>操作，比如说对于s=&quot;horse&quot;和t=&quot;ros&quot;的最后一个字母都不同，那么把s的最后一个字母替换成’s’，然后把s和t的最后一个字母都去掉即可。</p><p>可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, j), <span class="built_in">dfs</span>(i, j - <span class="number">1</span>)), <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中s[i] != t[j]的时候dfs(i - 1, j)相当于<code>删除</code>操作，dfs(i, j - 1)相当于<code>插入</code>操作，dfs(i - 1, j - 1) + 1相当于替换操作。</p><p>还有一些边界条件就是i &lt; 0或者 j &lt; 0 需要处理。</p><ul><li>i &lt; 0<ul><li>s为空t不为空，需要在s中插入和t相等长度的字符</li><li>故返回 j + 1</li></ul></li><li>j &lt; 0<ul><li>s不为空t为空，需要把s中字母全部删除，删除长度为t的长度</li><li>return i + 1;</li></ul></li></ul><h2 id="递归">递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j + <span class="number">1</span>; <span class="comment">// s为空t不为空，需要在s中插入和t相等长度的字符</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// s不为空t为空，需要把s中字母全部删除，删除长度为t的长度</span></span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">                <span class="keyword">return</span> res = <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, j), <span class="built_in">dfs</span>(i, j - <span class="number">1</span>)), <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递推-2">递推</h2><p>递归很容易翻译成递推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[<span class="number">0</span>][j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i<span class="number">+1</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[i<span class="number">+1</span>][j<span class="number">+1</span>] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i][j<span class="number">+1</span>], f[i<span class="number">+1</span>][j]), f[i][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递推解法-空间复杂度O-m-两个数组">递推解法 空间复杂度O(m) 两个数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[<span class="number">0</span>][j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[(i<span class="number">+1</span>) % <span class="number">2</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = f[i % <span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i % <span class="number">2</span>][j<span class="number">+1</span>], f[(i<span class="number">+1</span>) % <span class="number">2</span>][j]), f[i % <span class="number">2</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递推解法-空间复杂度O-m-一个数组：">递推解法 空间复杂度O(m) 一个数组：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pre = f[<span class="number">0</span>];</span><br><span class="line">            f[<span class="number">0</span>] = i<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = f[j<span class="number">+1</span>];</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[j<span class="number">+1</span>] = pre;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[j<span class="number">+1</span>], f[j]), pre) + <span class="number">1</span>;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日继续学习灵茶山艾府的基础算法精讲系列中的&lt;a href=&quot;https://www.bilibili.com/video/BV1TM4y1o7ug/?spm_id_from=333.1007.top_right_bar_window_history.content.cli</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划四：完全背包</title>
    <link href="http://malone-ai.github.io/2025/03/02/dp4/"/>
    <id>http://malone-ai.github.io/2025/03/02/dp4/</id>
    <published>2025-03-02T13:21:30.000Z</published>
    <updated>2025-03-02T14:15:20.105Z</updated>
    
    <content type="html"><![CDATA[<p>今日继续学习B站Up主出品的基础算法精讲系列，<a href="https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">0-1背包 完全背包【基础算法精讲 18】</a>（点击即可跳转视频链接）。</p><p>0-1背包和完全背包是非常重要的DP模型，灵茶山艾府认为一定程度上它们就是“选或不选”思想的代表。</p><p>本片博客主要关注完全背包。</p><h1>完全背包</h1><p><code>完全背包</code>：有n种物品，第i种物品的体积为 w[i]，价值为 v[i]，每种物品<code>无限次重复选</code>，求体积和不超过 capacity时的最大价值和。</p><p>递归做法的回溯三问为：</p><ul><li>当前操作?枚举<code>第</code>i种物品选一个或不选:<ul><li>不选，剩余容量不变;</li><li>选一个，剩余容量减少 w[i]</li></ul></li><li>子问题?在剩余容量为c时，从<code>前</code>i种物品中得到的最大价值和</li><li>下一个子问题?分类讨论：<ul><li>不选：在剩余容量为c时，从<code>前</code>i-1 种物品中得到的最大价值和:</li><li>选一个，在剩余容量为c-w[i]时，从<code>前</code>i种物品中得到的最大价值和</li></ul></li></ul><p>这里和0-1背包的回溯<code>区别</code>为，在选了一个物品之后，i是不变的，表示可以继续选第i中物品。因此不是递归到i-1，而是递归到i。</p><p>很容易得到其实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">unbounded_knapsack</span><span class="params">(<span class="type">int</span> c, vector&lt;<span class="type">int</span>&gt;&amp; w, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i, c), <span class="built_in">dfs</span>(i, c-w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>322. 零钱兑换</h1><p>看一道Leetcode题<a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span><br><span class="line"></span><br><span class="line">计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</span><br><span class="line"></span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure><p>背包问题的常见变形：</p><ol><li>至多装capacity，求方案数/最大价值和</li><li>恰好装capacity，求方案数/最大/最小价值和</li><li>至少装capacity，求方案数/最小价值和</li></ol><p>这道Leetcode题也是完全背包的一种变形，把物品价值看成是1，把求最大改成求最小，可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i, c) = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i, c-w[i]) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>dfs(i, c)表示前i种硬币组合金额恰好为c的所需的硬币个数。由于要求恰好组成amount，所以当c=0时才能返回0表示前i个物品组成金额c（金额0）需要0枚硬币，否则返回无穷大表示方案不合法。这样后面取min时自然就取到了不是无穷大的方案。</p><p>最后还需要判断一下，如果ans小于无穷大表示这是一个合法方案，否则无合法方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, <span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : INT_MAX / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][c];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">                <span class="keyword">return</span> res = <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i, c-w[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">dfs</span>(n<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] w;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.w = w;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> dfs(n-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][c] != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][c];</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i]) </span><br><span class="line">            <span class="keyword">return</span> memo[i][c] = dfs(i-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> memo[i][c] = Math.min(dfs(i-<span class="number">1</span>, c), dfs(i, c-w[i]) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化为递推">优化为递推</h2><p>依然是使用f数组，根据递归边界条件当<code>i == 0 &amp;&amp; c == 0</code>时才是0，其他都是无穷大，所以f数组可以初始化为无穷大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i]) </span><br><span class="line">                    f[i<span class="number">+1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i<span class="number">+1</span>][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">+1</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = f[n][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: f) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    f[i+<span class="number">1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i+<span class="number">1</span>][j] = Math.min(f[i][j], f[i+<span class="number">1</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[n][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间优化">空间优化</h2><h3 id="两个数组">两个数组</h3><p>同0-1背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i]) </span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][j] = f[i%<span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][j] = <span class="built_in">min</span>(f[i%<span class="number">2</span>][j], f[(i<span class="number">+1</span>)%<span class="number">2</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = f[n%<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][c+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row: f) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = f[i%<span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = Math.min(f[i%<span class="number">2</span>][j], f[(i+<span class="number">1</span>)%<span class="number">2</span>][j-w[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[n%<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个数组">一个数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(amount<span class="number">+1</span>, INT_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= amount; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= coins[i])</span><br><span class="line">                    f[c] = <span class="built_in">min</span>(f[c], f[c-coins[i]]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount] &lt; INT_MAX / <span class="number">2</span> ? f[amount] : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日继续学习B站Up主出品的基础算法精讲系列，&lt;a href=&quot;https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a&quot;&gt;0-1背包 完全背包【基础算法精</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>MySQL二：使用C++连接MySQL</title>
    <link href="http://malone-ai.github.io/2025/03/02/mysql2/"/>
    <id>http://malone-ai.github.io/2025/03/02/mysql2/</id>
    <published>2025-03-02T09:01:13.000Z</published>
    <updated>2025-03-03T05:59:55.170Z</updated>
    
    <content type="html"><![CDATA[<p>在Visual Studio Code 下使用C++连接MySQL进行基本操作，参考CSDN博客<a href="https://blog.csdn.net/weixin_40582034/article/details/115562097?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522fb76f6ed18bf4ea960962a642e3d6c29%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=fb76f6ed18bf4ea960962a642e3d6c29&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-115562097-null-null.nonecase&amp;utm_term=mysql&amp;spm=1018.2226.3001.4450">C/C++访问MySQL数据库</a>、<a href="https://blog.csdn.net/weixin_41987016/article/details/135668803?spm=1001.2014.3001.5501">VsCode + CMake构建项目 C/C++连接Mysql数据库 | 数据库增删改查C++封装 | 信息管理系统通用代码 ---- 课程笔记</a>以及<a href="https://blog.csdn.net/weixin_52273949/article/details/130613224">windows下使用vscode原生态配置c++链接mysql数据库</a>三篇博客文章（点击即可跳转文章，非商业引用，侵权联系删）。</p><h1>配置工程环境</h1><ol><li>新建一个文件夹作为工程目录</li><li>将mysql下的<code>include文件夹</code>直接拷贝到工程目录下【或者只拷贝include中的mysql.h文件】<code>方便引用mysql.h头文件</code></li><li>拷贝<code>libmysql.dll</code> 、<code>libmysql.lib</code>、<code>mysqlclient.lib</code>文件直接放在工程目录下<code>因为这里可执行文件在其所在目录下直接寻找动态链接源文件</code></li><li>将<code>libmysql.dll</code> 、<code>libmysql.lib</code>再拷贝到工程的lib目录下<code>方便编译写库路径</code></li></ol><p>然后工程目录如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">工程目录</span><br><span class="line">│  libmysql.dll</span><br><span class="line">│  libmysql.lib</span><br><span class="line">│  mysqlclient.lib</span><br><span class="line">│</span><br><span class="line">├─include</span><br><span class="line">│</span><br><span class="line">└─lib</span><br><span class="line">    libmysql.dll</span><br><span class="line">    libmysql.lib</span><br></pre></td></tr></table></figure><p>到此工程环境配置完成。</p><h1>编写代码</h1><h2 id="连接数据库">连接数据库</h2><p>先连接数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * user = <span class="string">&quot;root&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * pw = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * database_name = <span class="string">&quot;database_test&quot;</span>; <span class="comment">// 数据库名</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> port = <span class="number">3306</span>; <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL * con = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mysql_real_connect</span> (con, host, user, pw, database_name, port, <span class="literal">nullptr</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to connect to database: Error:%s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码保存到main.cpp文件中，然后在cmd使用以下命令进行编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ .\main.cpp -Llib -lmysql -Iinclude</span><br></pre></td></tr></table></figure><p>解释一下这段命令：</p><ol><li>g++<ul><li>这是 GNU C++ 编译器</li></ul></li><li>.\main.cpp<ul><li>这是要编译的源文件，.\main.cpp 表示当前目录下的 main.cpp 文件。</li></ul></li><li>-Llib<ul><li>-L 选项用于指定库文件的搜索路径。</li><li>lib 是库文件所在的目录。编译器会在 lib 目录中查找链接时需要的库文件。</li></ul></li><li>-lmysql<ul><li>-l（小写l） 选项用于链接指定的库。</li><li>mysql 是要链接的库名称。</li><li>在Linux中，编译器会查找名为 libmysql.a（静态库）或 <a href="http://libmysql.so">libmysql.so</a>（动态库）的文件。</li><li>在Windows中，编译器会查找名为 libmysql.lib（静态库）或 libmysql.dll（动态库）的文件。</li></ul></li><li>-Iinclude<ul><li>-I（大写I） 选项用于指定头文件的搜索路径。</li><li>include 是头文件所在的目录。编译器会在 include 目录中查找 #include 指令中引用的头文件。</li></ul></li></ol><p>这条命令的作用是：</p><ol><li>编译 main.cpp 文件。</li><li>在 include 目录中查找头文件。</li><li>在 lib 目录中查找 libmysql 库文件。</li><li>将 main.cpp 编译成可执行文件，并链接 libmysql 库。</li><li>最终生成a.exe（windows）或者a.out（linux）的可执行文件</li></ol><h2 id="增删查改">增删查改</h2><p>我使用的数据库名称为database_test，里面有个表名称为students，表中内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------+--------------+--------------+</span><br><span class="line">| student_id | student_name | class_id     |</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">|      10000 | 张三         | 软件工程一班 |</span><br><span class="line">+------------+--------------+--------------+</span><br></pre></td></tr></table></figure><p>为了方便增删查改和管理，定义一个结构体组织信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> student_id;</span><br><span class="line">    string student_name;</span><br><span class="line">    <span class="type">int</span> class_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="插入">插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * user = <span class="string">&quot;root&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * pw = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * database_name = <span class="string">&quot;database_test&quot;</span>; <span class="comment">// 数据库名</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> port = <span class="number">3306</span>; <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> student_id;</span><br><span class="line">    string student_name;</span><br><span class="line">    string class_id;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL * con = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mysql_real_connect</span> (con, host, user, pw, database_name, port, <span class="literal">nullptr</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to connect to database: Error: %s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">        <span class="built_in">mysql_close</span>(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    Student stu&#123;<span class="number">10002</span>, <span class="string">&quot;李华&quot;</span>, <span class="string">&quot;计算机科学与技术二班&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> sql[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into students (student_id, student_name, class_id) values (%d,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, </span><br><span class="line">        stu.student_id, stu.student_name.<span class="built_in">c_str</span>(), stu.class_id.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(con, sql)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to insert data: Error: %s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">        <span class="built_in">mysql_close</span>(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 Student 对象 stu，并初始化其数据。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu&#123;<span class="number">10002</span>, <span class="string">&quot;李华&quot;</span>, <span class="string">&quot;计算机科学与技术二班&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>构造 SQL 插入语句</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> sql[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into students (student_id, student_name, class_id) values (%d,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, </span><br><span class="line">    stu.student_id, stu.student_name.<span class="built_in">c_str</span>(), stu.class_id.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><ul><li>使用 sprintf 构造一个 SQL 插入语句。<ul><li>sprintf 是 C 标准库中的一个函数，用于将格式化的数据写入字符串中。</li><li>它的作用类似于 printf，但 printf 是将数据输出到标准输出（如终端），而 sprintf 是将数据写入一个字符数组中</li><li>sprintf 的 %s 格式说明符要求传入的参数是一个 C 风格字符串（即 const char* 类型），使用c_str成员函数将string转换为 C 风格字符串</li><li><code>C 风格字符串</code>：是一个以 \0 结尾的字符数组（char[] 或 const char*）</li></ul></li><li>students 是目标表名，student_id、student_name 和 class_id 是表的字段。</li><li>stu.student_id、stu.student_name 和 stu.class_id 是待插入的数据。</li></ul><ol start="3"><li>执行 SQL 语句</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">mysql_query</span>(con, sql)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to insert data: Error: %s\n&quot;</span>, <span class="built_in">mysql_error</span>(con));</span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mysql_query 执行 SQL 语句。<ul><li>如果执行失败，输出错误信息并关闭连接。</li><li>如果执行成功，数据将被插入到数据库中。</li><li>mysql_query 是 MySQL C API 中的一个函数，用于向 MySQL 服务器发送 SQL 查询并执行。</li><li>mysql_query 是 MySQL C API 中最常用的函数之一，适用于执行各种 SQL 语句</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Visual Studio Code 下使用C++连接MySQL进行基本操作，参考CSDN博客&lt;a href=&quot;https://blog.csdn.net/weixin_40582034/article/details/115562097?ops_request_misc</summary>
      
    
    
    
    <category term="MySQL" scheme="http://malone-ai.github.io/categories/MySQL/"/>
    
    
    <category term="C++" scheme="http://malone-ai.github.io/tags/C/"/>
    
    <category term="MySQL" scheme="http://malone-ai.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://malone-ai.github.io/2025/03/02/designPattern1/"/>
    <id>http://malone-ai.github.io/2025/03/02/designPattern1/</id>
    <published>2025-03-02T00:50:59.000Z</published>
    <updated>2025-03-03T05:43:06.946Z</updated>
    
    <content type="html"><![CDATA[<p>通过他人博客学习一下单例模式以及C++实现，博客文章链接<a href="https://blog.csdn.net/trackxiaoxin321/article/details/110749781">C++设计模式之单例模式详解（懒汉模式、饿汉模式、双重锁）</a>。</p><h1>走进单例模式</h1><p>我们希望类的实例对象有且仅有一个，比如数据库连接配置、应用设置时，系统中需要一个全局对象，所有模块共享同一配置。再比如数据库连接池也需要全局管理，避免频繁创建与销毁。</p><p>感觉上述例子并不直观，再举个直观通俗的例子——家里的电表。家里的电表记录整个家庭的用电量。无论你在厨房、卧室还是客厅用电，电表都是同一个。你不会希望每个房间都有一个独立的电表，因为那样会导致用电量的计算混乱。</p><p>我们希望实例对象有且只有一个，此时就需要用到单例模式了。单例模式保证一个类有且仅有一个实例，并且会提供一个全局访问点。</p><p>如何实现让一个类的实例只有一个呢？那么就需要在构造函数上做点“手脚”。如果构造函数是public，那么就没有任何限制地可以构造对象了。因此，需要将构造函数私有化即设置为private属性，并对外提供一个接口，并且这个接口得是静态的即static关键字修饰的接口。如果不使用static关键字修饰，那么调用这个接口就需要创建对象，而构造函数又被私有化了，无法创建对象。因此这个接口得是静态的。</p><p>此外，还需要禁用拷贝构造函数和复制运算符。</p><h2 id="补充拷贝构造函数">补充拷贝构造函数</h2><p>复习一下拷贝构造函数。</p><p>拷贝构造函数是C++中的一个特殊成员函数，用于创建一个新对象，并将其初始化为另一个同类型对象的副本。它在以下情况下会被调用：</p><ul><li>用一个对象初始化另一个对象时。</li><li>将对象作为参数按值传递给函数时。</li><li>从函数按值返回对象时。</li></ul><p>拷贝构造函数的典型形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 拷贝函数逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拷贝构造函数的参数是一个常量引用（const MyClass&amp;），表示被拷贝的对象。</p><p>拷贝构造函数常见问题是<code>浅拷贝</code>的问题，不再多说啦。</p><h1>具体实现</h1><p>单例模式实现有两种方式：</p><ul><li>懒汉方式</li><li>饿汉方式</li></ul><h2 id="懒汉方式">懒汉方式</h2><p>懒汉方式：顾名思义，很“懒”，只有用到了才实例化对象并返回（调用了对外的接口才会实例化对象）。代码实现如下：</p><h3 id="不加锁">不加锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton* singlep1 = Singleton::<span class="built_in">getInstance</span>();   <span class="comment">// 通过类域获取接口</span></span><br><span class="line">Singleton* singlep2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; singlep1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; singlep2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现是<code>线程不安全</code>的，原因在于<code>getInstance</code>方法中的条件判断和实例创建操作不是原子的。在多线程环境下，可能会导致多个线程同时创建实例，从而破坏单例模式的唯一性。</p><p>在 getInstance 方法中，以下代码是问题的根源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) </span><br><span class="line">    instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure><ul><li>多个线程可能同时进入 if (instance == nullptr) 的判断。</li><li>如果 instance 为 nullptr，多个线程会同时执行 instance = new singleClass()，导致创建多个实例。</li><li>最终，instance 可能指向不同的对象，破坏了单例模式的唯一性。</li></ul><h3 id="加锁后检查">加锁后检查</h3><p>为了解决这一问题，很容易想到使用互斥信号量也就是互斥锁来解决，于是就有以下方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br><span class="line">mutex Singleton::mtx; <span class="comment">// 类外初始化 </span></span><br></pre></td></tr></table></figure><p>这种实现方法有很明显的优缺点:</p><ul><li>优点<ul><li>简单直观</li></ul></li><li>缺点<ul><li>每次调用<code>getInstance</code>都需要加锁，性能开销较大。</li></ul></li></ul><h3 id="二重锁">二重锁</h3><p>因此继续进行改进，使用<code>双重检查锁定</code>的方式，又称为<code>二重锁</code>。不同于前一种上锁方法，二重锁的<code>核心思想</code>是通过两次检查实例是否为空来减少加锁的次数：</p><ol><li>第一次检查（不加锁）：检查实例是否已经创建。如果已经创建，直接返回实例，避免加锁的开销。</li><li>第二次检查（加锁）：如果实例未创建，加锁后再次检查实例是否为空。如果仍然为空，则创建实例。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>; <span class="comment">// 初始化静态变量</span></span><br><span class="line">mutex Singleton::mtx; <span class="comment">// 类外初始化</span></span><br></pre></td></tr></table></figure><h4 id="二重锁优点">二重锁优点</h4><ol><li>减少加锁开销<ul><li>只有在实例未创建时才加锁，避免了每次调用 getInstance 都加锁的性能开销。</li></ul></li><li>线程安全<ul><li>通过加锁确保实例创建过程的线程安全。</li></ul></li></ol><h4 id="额外补充">额外补充</h4><p>上述实现中对于互斥信号量mtx的上锁使用的是<code>mtx.lock()</code>，解锁使用的是<code>mtx.unlock()</code>。其实可以使用<code>lock_guard&lt;mutex&gt; lock(mtx)</code>来实现。</p><ol><li><p>mtx.lock() 和 mtx.unlock()</p><ul><li>手动加锁和解锁：<ul><li>mtx.lock()：手动加锁。</li><li>mtx.unlock()：手动解锁。</li></ul></li><li>需要显式调用解锁：<ul><li>如果忘记调用 mtx.unlock()，会导致锁未被释放，可能引发死锁。</li></ul></li><li>灵活性：<ul><li>可以在代码的任何地方加锁和解锁，适合需要精细控制锁的场景。</li></ul></li></ul></li><li><p>lock_guard<mutex> lock(mtx)</p><ul><li>自动加锁和解锁：<ul><li>lock_guard 是一个 RAII（资源获取即初始化）封装类。</li><li>在构造时自动加锁，在析构时自动解锁。</li></ul></li><li>无需手动解锁：<ul><li>即使函数提前返回或抛出异常，lock_guard 也能保证锁被释放。</li></ul></li><li>简洁性和安全性：<ul><li>代码更简洁，不易出错。</li></ul></li></ul></li><li><p>lock_guard<mutex> lock(mtx) 和 mtx.lock() 的区别</p></li></ol><table><thead><tr><th>特性</th><th>lock_guard<mutex> lock(mtx)</th><th>mtx.lock() 和 mtx.unlock()</th></tr></thead><tbody><tr><td>加锁方式</td><td>自动加锁（构造时）</td><td>手动加锁</td></tr><tr><td>解锁方式</td><td>自动解锁（析构时）</td><td>手动解锁</td></tr><tr><td>异常安全</td><td>是（即使抛出异常也能解锁）</td><td>否（需要手动处理异常）</td></tr><tr><td>代码简洁性</td><td>高</td><td>低</td></tr><tr><td>灵活性</td><td>低（锁的作用域由 lock_guard 的生命周期决定）</td><td>高（可以在任意位置加锁和解锁）</td></tr><tr><td>适用场景</td><td>简单的加锁和解锁场景</td><td>需要精细控制锁的场景</td></tr></tbody></table><h4 id="静态局部变量实例化实现懒汉方式">静态局部变量实例化实现懒汉方式</h4><p>C++11 标准规定，静态局部变量的初始化是线程安全的。因此可以使用静态局部变量初始化来实现懒汉模式。</p><ol><li>核心思想<ul><li>延迟初始化：单例对象在第一次调用 getInstance 时才被创建，而不是在程序启动时。</li><li>线程安全：C++11 标准规定，局部静态变量的初始化是线程安全的，编译器会自动处理线程同步问题。</li><li>简洁高效：无需手动管理锁或静态成员变量，代码更简洁。</li></ul></li><li>静态局部变量的特性<ul><li>生命周期：静态局部变量的生命周期从第一次执行到它的声明语句开始，直到程序结束。</li><li>线程安全：C++11 及以上标准保证，静态局部变量的初始化是线程安全的。</li><li>唯一性：静态局部变量只会被初始化一次。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton&amp; singlep1 = Singleton::<span class="built_in">getInstance</span>();   <span class="comment">//通过类域获取接口</span></span><br><span class="line">Singleton&amp; singlep2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; &amp;singlep1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;singlep2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉方式">饿汉方式</h2><p>以上是单例模式的懒汉实现方法，接下来介绍饿汉实现方法。</p><p>饿汉模式：不管调不调用对外接口，都已经实例化对象了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式：不管用不用得到，都构造出来。本身就是线程安全的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> Singleton* instance;   <span class="comment">// 静态成员变量，类内声明，类外初始化</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;  <span class="comment">// 构造函数属性设置为私有</span></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; sc) = <span class="keyword">delete</span>; <span class="comment">// 禁用赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); <span class="comment">// 初始化静态变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton* singlep1 = Singleton::<span class="built_in">getInstance</span>();   <span class="comment">//通过类域获取接口</span></span><br><span class="line">Singleton* singlep2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; singlep1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; singlep2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过他人博客学习一下单例模式以及C++实现，博客文章链接&lt;a href=&quot;https://blog.csdn.net/trackxiaoxin321/article/details/110749781&quot;&gt;C++设计模式之单例模式详解（懒汉模式、饿汉模式、双重锁）&lt;/a&gt;。&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://malone-ai.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="http://malone-ai.github.io/tags/C/"/>
    
    <category term="设计模式" scheme="http://malone-ai.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="http://malone-ai.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java开发环境搭建</title>
    <link href="http://malone-ai.github.io/2025/03/01/java1/"/>
    <id>http://malone-ai.github.io/2025/03/01/java1/</id>
    <published>2025-03-01T09:36:40.000Z</published>
    <updated>2025-03-07T12:42:10.422Z</updated>
    
    <content type="html"><![CDATA[<h1>1. JDK的下载与安装</h1><p>百度搜索JDK21到Oracle官网下载jdk21即可，需要注册账号。</p><p>下载好对应电脑版本的安装包后直接安装，记得把安装目录给记清楚，配置环境需要使用。</p><h1>2. jre 目录的生成</h1><p>准备配环境变量，突然发现jdk下没有jre目录。百度一搜发现需要手动生成jre。</p><ol><li>首先以管理员身份运行CMD</li><li>进入到jdk的安装目录</li><li>运行命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure><ol start="4"><li>此时会发现jre目录已经生成</li></ol><h1>3. 配置环境目录</h1><ol><li>编辑系统环境变量<ul><li>创建一个新的系统环境变量，名称为<code>JAVA_HOME</code>，值为java的安装路径</li></ul></li><li>配置PATH变量<ul><li>在PATH变量中添加<code>%JAVA_HOME%\bin</code></li><li>在PATH变量中添加<code>%JAVA_HOME%\jre\bin</code></li></ul></li><li>验证<ul><li>在cmd中输入<code>java -version</code></li><li>显示java的版本等信息即为成功</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1. JDK的下载与安装&lt;/h1&gt;
&lt;p&gt;百度搜索JDK21到Oracle官网下载jdk21即可，需要注册账号。&lt;/p&gt;
&lt;p&gt;下载好对应电脑版本的安装包后直接安装，记得把安装目录给记清楚，配置环境需要使用。&lt;/p&gt;
&lt;h1&gt;2. jre 目录的生成&lt;/h1&gt;
&lt;p&gt;准备</summary>
      
    
    
    
    <category term="Java" scheme="http://malone-ai.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL一：MySQL环境配置</title>
    <link href="http://malone-ai.github.io/2025/03/01/mysql1/"/>
    <id>http://malone-ai.github.io/2025/03/01/mysql1/</id>
    <published>2025-03-01T08:31:58.000Z</published>
    <updated>2025-03-02T08:33:28.839Z</updated>
    
    <content type="html"><![CDATA[<p>即日起学习Mysql并进行记录。</p><h1>数据库分类</h1><h2 id="关系型数据库">关系型数据库</h2><ul><li>称作SQL</li><li>Mysql，Oracle，Sql Server， DB2， SQLlite</li><li>通过表与表之间，行与行之间的关系进行数据存储</li></ul><h2 id="非关系型数据库">非关系型数据库</h2><ul><li>称作NoSQL即Not only SQL</li><li>Redis， MongDB</li><li>对象存储，通过对象自身的属性来进行存储</li></ul><h2 id="DBMS">DBMS</h2><ul><li>DBMS即数据库管理系统</li></ul><h2 id="MySQL">MySQL</h2><ul><li>MySQL是一个关系型数据库管理系统</li><li>由瑞典 MySQL AB 公司开发</li><li>属于 Oracle 旗下产品</li><li>MySQL是最流行的关系型数据库管理系统之一</li><li>在 WEB 应用方面，MySQL是最好的RDBMS (Relational Database Management System，关系数据库管理系统)应用软件之一。</li></ul><h1>MySQL 安装</h1><h2 id="建议">建议</h2><ul><li>尽量使用压缩包，不用exe文件（貌似与注册表有关）</li></ul><h2 id="详细安装说明">详细安装说明</h2><ol><li>解压到合适的位置（我的安装目录为D:\ProgramFiles\mysql-5.7.44）</li><li>为解压后文件中的bin目录配置环境变量</li><li>在解压后的目录下创建一个my.ini文件（D:\ProgramFiles\mysql-5.7.44\my.ini）</li><li>编辑my.ini文件为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=D:\ProgramFiles\mysql-5.7.44\</span><br><span class="line">datadir=D:\ProgramFiles\mysql-5.7.44\data\</span><br><span class="line">port=3306</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>注意：虽然没有data目录也不用去手动创建！</p><ol start="5"><li>启动管理员模式下的cmd，并将目录切换到mysql的bin目录下，然后输入<code>mysqld --install</code><ul><li>显示Service successfully installed.即成功</li></ul></li><li>再输入<code>mysqld --initialize-insecure --user=mysql</code>初始化数据文件<ul><li>此时会在mysql目录下产生data文件夹</li></ul></li><li>输入<code>net start mysql</code>启动mysql服务</li><li>输入<code>mysql -u root -p</code>，注意-p后不要＋任何东西，包括空格。提示输入密码，直接回车跳过</li><li>输入<code>update mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost';</code>修改密码为123456，最后输入<code>flush priviledges;</code>刷新权限（注意MySQL语句以分号结尾）<ul><li>如果使用的是MySQL 5.7.6 及以上版本，输入<code>ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';</code>，然后<code>flush priviledges</code></li></ul></li><li>将my.ini文件<code>skip-grant-tables</code>删除</li><li>重启MySQL服务即可使用<ul><li>net stop mysql</li><li>net start mysql</li></ul></li><li>输入<code>mysql -u root -p</code>再键入密码即可使用</li></ol><h2 id="基本命令行">基本命令行</h2><ol><li>查询所有数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><ol start="2"><li>切换数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use [数据库名称]</span><br></pre></td></tr></table></figure><ol start="3"><li>查看数据库中所有的表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看显示数据库中所有表的信息</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descibe [表名]</span><br></pre></td></tr></table></figure><ol start="5"><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [数据库名称]</span><br></pre></td></tr></table></figure><ol start="6"><li>退出连接</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="sqlyog的使用">sqlyog的使用</h2><p>参考CSDN博客<a href="https://blog.csdn.net/weixin_43364551/article/details/116754626">https://blog.csdn.net/weixin_43364551/article/details/116754626</a></p><h2 id="数据库基本操作">数据库基本操作</h2><p>数据库 XXX 语言</p><ol><li>DDL 定义</li><li>DML 操作</li><li>DQL 查询</li><li>DCL 控制</li></ol><h1>操作数据库</h1><p>操作数据库-&gt;操作数据库中的表-&gt;操作数据库中的表的数据</p><ol><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [数据库名称]</span><br></pre></td></tr></table></figure><ol start="2"><li>删除数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] [数据库名称]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;即日起学习Mysql并进行记录。&lt;/p&gt;
&lt;h1&gt;数据库分类&lt;/h1&gt;
&lt;h2 id=&quot;关系型数据库&quot;&gt;关系型数据库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;称作SQL&lt;/li&gt;
&lt;li&gt;Mysql，Oracle，Sql Server， DB2， SQLlite&lt;/li&gt;
&lt;li&gt;通过</summary>
      
    
    
    
    <category term="MySQL" scheme="http://malone-ai.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://malone-ai.github.io/tags/MySQL/"/>
    
    <category term="关系型数据库" scheme="http://malone-ai.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>动态规划三：0-1背包</title>
    <link href="http://malone-ai.github.io/2025/02/28/dp3/"/>
    <id>http://malone-ai.github.io/2025/02/28/dp3/</id>
    <published>2025-02-28T15:49:07.000Z</published>
    <updated>2025-03-07T07:19:45.961Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今日继续学习B站Up主出品的基础算法精讲系列，<a href="https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">0-1背包 完全背包【基础算法精讲 18】</a>（点击即可跳转视频链接）。</p><p>0-1背包和完全背包是非常重要的DP模型，灵茶山艾府认为一定程度上它们就是“选或不选”思想的代表。</p><p>这篇博客主要关注<code>0-1背包</code>。</p><h1>1. 0-1 背包</h1><h1>1.1 问题描述</h1><p><code>0-1 背包</code>:有 n 个物品，第i个物品的体积为 w[i]，价值为 v[i]，每个物品至多选一个，求体积和不超过 capacity 时的最大价值和。</p><h1>1.2 基本思路</h1><p>先从回溯开始思考，这里先附上灵茶山艾府总结的关于该问题的回溯三问：</p><ul><li>当前操作？枚举<code>第</code>i个物品选还是不选：<ul><li>不选，剩余容量不变</li><li>选，剩余容量变小</li></ul></li><li>子问题？即在剩余容量为c时，从<code>前</code>i个物品中得到的最大价值和</li><li>下一个子问题？分类讨论<ul><li>不选，剩余容量仍为c，从<code>前</code>i个物品中得到的最大价值和</li><li>选，剩余容量变为c-w[i]，从<code>前</code>i-1个物品中得到的最大价值和</li></ul></li></ul><p>先从回溯开始思考，也就是考虑第i个物品选还是不选，不选-&gt;容量不变，选-&gt;容量变小，由此确定递归参数中的i和c。对应的<code>子问题</code>就变成从前i个物品中能得到的最大价值和。</p><ul><li>不选<ul><li>就递归到它表示在剩余容量为c时，从前i-1个物品中获得的最大价值和。</li></ul></li><li>选<ul><li>就递归到它表示在剩余容量为c-w[i]时，从前i-1个物品中获得的最大价值和。<br>上述两个取最大值就是dfs(i, c)的结果了。</li></ul></li></ul><h1>1.3 具体实现</h1><p>基于上述结果可以编写代码，我忽略的一点是当剩余容量c小于第i个物品即<code>c &lt; w[i]</code>时，我们只能不选第i个物品，因此直接返回<code>dfs(i-1, c)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">zero_one_knapsack</span><span class="params">(<span class="type">int</span> capacity, vector&lt;<span class="type">int</span>&gt;&amp; w, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, c), <span class="built_in">dfs</span>(i<span class="number">-1</span>, c-w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2. 494.目标和</h1><p>然后看Leetcode题<a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a>：</p><p>给你一个非负整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个<code>表达式</code>：</p><pre><code>例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 &quot;+2-1&quot; 。</code></pre><p>返回可以通过上述方法构造的、运算结果等于 target 的不同<code>表达式</code>的数目。</p><h1>2.1 基本思路</h1><p>这道题看上去和0-1背包没有关系。</p><p>假设添加正号的数的和为p，那么添加负号的数的和为所有元素的和s减去p。那么<code>p - (s - p)</code>就是target了，即<code>p - (s - p) = t</code>=&gt;<code>2p=s+t</code>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">p=\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>。</p><p>现在问题就变成从nums中选择一些数字，使得他们的和恰好等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>的方案数。注意s+t既然要除以2那么s+t就得为偶数，并且由于nums[i]为非负数，故无论怎么选s+t都不会为负数。</p><h1>2.2 背包问题的常见变形</h1><p>背包问题的常见变形：</p><ol><li>至多装capacity，求方案数/最大价值和</li><li>恰好装capacity，求方案数/最大/最小价值和</li><li>至少装capacity，求方案数/最小价值和</li></ol><p>经过灵茶山艾府的巧妙转换，494. 目标和 问题就变形为上述第2中情况下的：恰好装capacity，求方案数。</p><h1>2.3 递归解法</h1><p>接下来编写代码。首先计算s+t，如果s+t是负数或者说s+t是一个奇数，则不满足要求，方案数为0。否则将s+t除以2（整除）记为p。</p><p>对于递归函数dfs，dfs(i, c)表示前i个数相加和为c的方案数。对于递归的边界条件，因为是从target倒着减，当c=0时说明找到了一个合法的方案数，因此返回1。否则返回0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t); <span class="comment">// p = (s + t)</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c) + <span class="built_in">dfs</span>(i<span class="number">-1</span>, c - w[i]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        p /= <span class="number">2</span>; <span class="comment">// p = (s + t) / 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w.<span class="built_in">size</span>() - <span class="number">1</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.length-<span class="number">1</span>, p, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c, <span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c, w) + dfs(i-<span class="number">1</span>, c - w[i], w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化为递推">优化为递推</h2><p>如何将记忆化搜索改成递推？灵茶山艾府总结如下：</p><ol><li>dfs -&gt; f数组</li><li>递归 -&gt; 循环</li><li>递归边界 -&gt; 数组初始值</li></ol><p>dfs改成f数组，这里的f数组是一个二维数组f[i][c]表示前i个数相加和为c的方案数。需要重点处理一下边界条件，从原递归中的边界条件入手。递归的边界条件有<code>i &lt; 0 &amp;&amp; c == 0</code>时return 1，每次向下递归时都传参i-1，故负数下标为边界。原来的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以更改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>只对<code>i &lt; 0 &amp;&amp; c == 0</code>的边界条件转换为数组边界<code>f[0][0] = 1</code>，而没有处理<code>i &lt; 0 &amp;&amp; c != 0</code>是因为c != 0时不为f数组边界。</p><p>递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c) + <span class="built_in">dfs</span>(i<span class="number">-1</span>, c - w[i]);</span><br></pre></td></tr></table></figure><p>改成循环为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][c] = f[i<span class="number">-1</span>][c] + f[i<span class="number">-1</span>][c-w[i]]</span><br></pre></td></tr></table></figure><p>为了避免负数下标将f中出现i的地方全部+1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+1</span>][c] = f[i][c] + f[i][c-w[i]]</span><br></pre></td></tr></table></figure><p>相应的数组的第一维大小应为nums.size() + 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (p + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][c] = f[i][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[i<span class="number">+1</span>][c] += f[i][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][c] = f[i][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[i+<span class="number">1</span>][c] += f[i][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继续优化空间复杂度">继续优化空间复杂度</h2><h3 id="两个数组">两个数组</h3><p>每次把f[i+1]算完之后，后面就不会用到f[i]了，也就是每时每刻数组中只有两个元素在参与状态转移，干脆就只用两个数组。比如把f[1]算完了，那么计算f[2]时直接把结果填到f[0]当中。然后计算f[3]时，f[1]没用，就把f[3]填到f[1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">+1</span>][c] = f[i][c];</span><br><span class="line"><span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">    f[i<span class="number">+1</span>][c] += f[i][c-w[i]];</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line"><span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">    f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br></pre></td></tr></table></figure><p>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (p + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[(i<span class="number">+1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= p; ++c) &#123;</span><br><span class="line">                f[(i+<span class="number">1</span>)%<span class="number">2</span>][c] = f[i%<span class="number">2</span>][c];</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[(i+<span class="number">1</span>)%<span class="number">2</span>][c] += f[i%<span class="number">2</span>][c-w[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个数组">一个数组</h3><p>能否进一步优化？Of course！<br>两行数组对于第一维是正向计算，有覆盖问题。但是如果反向计算就没有覆盖问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(p<span class="number">+1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = p; c &gt;= <span class="number">0</span>; --c) </span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[c] += f[c-w[i]];</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(w).sum();</span><br><span class="line">        <span class="keyword">if</span> (s + t &lt; <span class="number">0</span> || (s + t) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (s + t) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[p+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> p; c &gt;= <span class="number">0</span>; --c) </span><br><span class="line">                <span class="keyword">if</span> (c &gt;= w[i])</span><br><span class="line">                    f[c] += f[c-w[i]];</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;今日继续学习B站Up主出品的基础算法精讲系列，&lt;a href=&quot;https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a&quot;&gt;0-1背</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
