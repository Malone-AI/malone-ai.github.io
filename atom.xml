<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零一世界</title>
  
  
  <link href="http://malone-ai.github.io/atom.xml" rel="self"/>
  
  <link href="http://malone-ai.github.io/"/>
  <updated>2025-03-13T12:59:51.813Z</updated>
  <id>http://malone-ai.github.io/</id>
  
  <author>
    <name>Malone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeNet 推导</title>
    <link href="http://malone-ai.github.io/2025/03/13/LeNet/"/>
    <id>http://malone-ai.github.io/2025/03/13/LeNet/</id>
    <published>2025-03-13T12:58:42.000Z</published>
    <updated>2025-03-13T12:59:51.813Z</updated>
    
    <content type="html"><![CDATA[<p>LeNet-5是LeNet系列的最终稳定版，它被美国银行用于手写数字识别，该网络有以下特点：</p><ul><li>所有卷积核均为5x5，步长为1</li><li>所有池化方法为平均池化</li><li>所有激活函数采用Sigmoid</li></ul><hr><h1>1. LeNet 损失函数</h1><p>LeNet 的损失函数使用 <strong>交叉熵损失（Cross-Entropy Loss）</strong>，这是分类任务中最常用的损失函数之一。交叉熵损失用于衡量模型输出的概率分布与真实标签之间的差异。</p><hr><h2 id="1-1-交叉熵损失的数学公式">1.1 交叉熵损失的数学公式</h2><p>对于多分类问题，假设：</p><ul><li>模型的输出是一个概率分布 ( \hat{y} = (\hat{y}_1, \hat{y}_2, \dots, \hat{y}_C) )，其中 ( C ) 是类别数（LeNet 中 ( C = 10 )）。</li><li>真实标签是一个 one-hot 编码的向量 ( y = (y_1, y_2, \dots, y_C) )，其中只有一个元素为 1，其余为 0。</li></ul><p>交叉熵损失的公式为：<br>[<br>\text{Loss} = -\sum_{i=1}^{C} y_i \log(\hat{y}_i)<br>]<br>其中：</p><ul><li>( y_i ) 是真实标签的第 ( i ) 个元素。</li><li>( \hat{y}_i ) 是模型预测的第 ( i ) 个类别的概率。</li></ul><hr><h2 id="1-2-LeNet-的输出层和损失函数">1.2 LeNet 的输出层和损失函数</h2><p>LeNet 的输出层是一个全连接层，输出 10 个值（对应 0-9 的数字类别）。为了将这些值转换为概率分布，通常使用 <strong>softmax 激活函数</strong>：<br>[<br>\hat{y}<em>i = \frac{e^{z_i}}{\sum</em>{j=1}^{C} e^{z_j}}<br>]<br>其中：</p><ul><li>( z_i ) 是输出层的第 ( i ) 个值。</li><li>( \hat{y}_i ) 是第 ( i ) 个类别的预测概率。</li></ul><p>然后，使用交叉熵损失计算模型输出与真实标签之间的差异。</p><hr><h1>1.3 交叉熵损失的特点</h1><p>交叉熵损失是分类任务中最常用的损失函数之一，它直接衡量模型输出的概率分布与真实分布之间的差异。此外，它与 softmax 结合时，梯度计算简单且稳定，适合反向传播。</p><p>LeNet 的损失函数使用 <strong>交叉熵损失</strong>，用于衡量模型输出与真实标签之间的差异。通过最小化交叉熵损失，模型可以学习到更好的参数，从而提高分类准确率。交叉熵损失与 softmax 激活函数结合，是分类任务中的经典组合。</p><h1>2. 网络架构</h1><p>网络架构图：</p><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><h1>2.1 输入层</h1><p>LeNet-5 的输入是 <strong>32x32 的灰度图像</strong>，通道数为 1（因为是灰度图）。输入张量的形状为 <code>(1, 32, 32)</code>。</p><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><hr><h1>2.2 卷积层 C1</h1><ul><li><strong>卷积核大小</strong>：5x5</li><li><strong>卷积核数量</strong>：6</li><li><strong>步长（stride）</strong>：1</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>卷积操作的输出尺寸公式为：<br>[<br>\text{输出尺寸} = \frac{\text{输入尺寸} - \text{卷积核大小} + 2 \times \text{填充}}{\text{步幅}} + 1<br>]</p><p>对于 C1 层：<br>[<br>\text{输出尺寸} = \frac{32 - 5 + 2 \times 0}{1} + 1 = 28<br>]<br>因此，C1 层的输出是 <strong>6 个 28x28 的特征图</strong>，形状为 <code>(6, 28, 28)</code>。</p><hr><h1>2.3 池化层 S2</h1><ul><li><strong>池化类型</strong>：平均池化</li><li><strong>池化核大小</strong>：2x2</li><li><strong>步幅（stride）</strong>：2</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>池化操作的输出尺寸公式为：<br>[<br>\text{输出尺寸} = \frac{\text{输入尺寸} - \text{池化核大小}}{\text{步幅}} + 1<br>]</p><p>对于 S2 层：<br>[<br>\text{输出尺寸} = \frac{28 - 2}{2} + 1 = 14<br>]<br>因此，S2 层的输出是 <strong>6 个 14x14 的特征图</strong>，形状为 <code>(6, 14, 14)</code>。</p><hr><h1>2.4 卷积层 C3</h1><ul><li><strong>卷积核大小</strong>：5x5</li><li><strong>卷积核数量</strong>：16</li><li><strong>步幅（stride）</strong>：1</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>对于 C3 层：<br>[<br>\text{输出尺寸} =\frac{\text{输入尺寸} - \text{卷积核大小} + 2 \times \text{填充}}{\text{步幅}} + 1 = \frac{14 - 5 + 2 \times 0}{1} + 1 = 10<br>]<br>因此，C3 层的输出是 <strong>16 个 10x10 的特征图</strong>，形状为 <code>(16, 10, 10)</code>。</p><hr><h1>2.5 池化层 S4</h1><ul><li><strong>池化类型</strong>：平均池化</li><li><strong>池化核大小</strong>：2x2</li><li><strong>步幅（stride）</strong>：2</li><li><strong>填充（padding）</strong>：0</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>对于 S4 层：<br>[<br>\text{输出尺寸} = \frac{\text{输入尺寸} - \text{池化核大小}}{\text{步幅}} + 1 = \frac{10 - 2}{2} + 1 = 5<br>]<br>因此，S4 层的输出是 <strong>16 个 5x5 的特征图</strong>，形状为 <code>(16, 5, 5)</code>。</p><hr><h1>2.6 全连接层 C5</h1><ul><li><strong>输入</strong>：将 S4 层的输出展平为一维向量。</li><li><strong>输入大小</strong>：(16 \times 5 \times 5 = 400)</li><li><strong>输出大小</strong>：120</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>C5 层是一个全连接层，将 400 维的输入映射到 120 维的输出：<br>[<br>\text{输出} = W \cdot \text{输入} + b<br>]<br>其中，(W) 是权重矩阵，形状为 <code>(120, 400)</code>，(b) 是偏置向量，形状为 <code>(120,)</code>。</p><hr><h1>2.7 全连接层 F6</h1><ul><li><strong>输入大小</strong>：120</li><li><strong>输出大小</strong>：84</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>F6 层将 120 维的输入映射到 84 维的输出：<br>[<br>\text{输出} = W \cdot \text{输入} + b<br>]<br>其中，(W) 是权重矩阵，形状为 <code>(84, 120)</code>，(b) 是偏置向量，形状为 <code>(84,)</code>。</p><hr><h1>2.8 输出层</h1><ul><li><strong>输入大小</strong>：84</li><li><strong>输出大小</strong>：10（对应 0-9 的数字类别）</li></ul><p><img src="image.png" alt=""><br><img src="/images/LeNet_1.png" alt=""></p><p><strong>计算过程</strong>：<br>输出层将 84 维的输入映射到 10 维的输出。其计算为：<br>[<br>\text{输出} = W \cdot \text{输入} + b<br>]<br>其中，(W) 是权重矩阵，形状为 <code>(10, 84)</code>，(b) 是偏置向量，形状为 <code>(10,)</code>。</p><p>最后，使用 <strong>softmax 激活函数</strong> 将输出转换为概率分布。</p><hr><h1>总结</h1><p>LeNet 通过卷积层提取局部特征，通过卷积核共享权重减少参数。使用池化层降低特征图维度，增强平移不变性。最后通过全连接层整合特征，输出分类结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LeNet-5是LeNet系列的最终稳定版，它被美国银行用于手写数字识别，该网络有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有卷积核均为5x5，步长为1&lt;/li&gt;
&lt;li&gt;所有池化方法为平均池化&lt;/li&gt;
&lt;li&gt;所有激活函数采用Sigmoid&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
      
    
    
    
    <category term="深度学习" scheme="http://malone-ai.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="http://malone-ai.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LeNet" scheme="http://malone-ai.github.io/tags/LeNet/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 + vue3 实现增删查改、分页查询、批量删除</title>
    <link href="http://malone-ai.github.io/2025/03/12/project-test5/"/>
    <id>http://malone-ai.github.io/2025/03/12/project-test5/</id>
    <published>2025-03-12T09:58:12.000Z</published>
    <updated>2025-03-12T15:46:33.647Z</updated>
    
    <content type="html"><![CDATA[<h1>1.</h1><p>在vue工程目录打开cmd，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios -S</span><br></pre></td></tr></table></figure><p>安装插件</p><p>在vue/src/views/Home.vue中<code>&lt;script&gt;&lt;/script&gt;</code>之间添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#x27;http://localhost:9999/admin/selectAll&#x27;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行vue工程后进入manager/home路由，右键检查，在控制台里就发现了请求错误。</p><p>这个错误，其实是因为vue项目的端口和上面使用的端口不一样，这种情况下浏览器默认会有一个跨域的限制，不允许在不一样的端口号里请求数据：</p><pre><code>Failed to load resource: net::ERR_CONNECTION_REFUSED</code></pre><h2 id="1-2-处理跨域限制">1.2 处理跨域限制</h2><p>需要在springboot里设置统一的跨域处理。</p><p>在springboot工程的com.example.common里新建CorsConfig类，并对这个类添加<code>@Configuration</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">cosConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行springboot工程、vue工程，访问前端的manager/home，右键检查，查看控制台，就会发现有数据传过来了。</p><h1>2. 封装统一的请求工具 request.js</h1><p>在vue/src中新建一个utils目录，在这个目录下在创建request.js。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1.&lt;/h1&gt;
&lt;p&gt;在vue工程目录打开cmd，运行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>YOLO</title>
    <link href="http://malone-ai.github.io/2025/03/11/yolo1/"/>
    <id>http://malone-ai.github.io/2025/03/11/yolo1/</id>
    <published>2025-03-11T03:35:43.000Z</published>
    <updated>2025-03-13T12:59:25.744Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 目标检测综述</h1><p>目标检测分为：</p><ul><li>one-stage detector（单阶段模型）<ul><li>代表有Yolo、SSD、Retina-net</li></ul></li><li>two-stage detector（两阶段模型）<ul><li>先从图像提取若干候选框，再逐一对这些候选框做分类、甄别以及调整它们的坐标。</li><li>代表有RCNN、SPPNet、Fast RCNN</li></ul></li></ul><p>R-CNN——Regions with CNN features</p><ol><li>输入图像</li><li>提取候选区域（~2k）</li><li>计算CNN特征</li><li>将区域分类</li></ol><p>YOLO论文链接<a href="https://arxiv.org/pdf/1506.02640">You Only Look Once:Unifed, Real-Time Obiect Detection</a></p><h1>2. 预测阶段（前向推断）</h1><p>此时模型是已经训练好的，输入未知图片进行预测，此时没有反向传播，只有前向推断。</p><h2 id="2-1-Yolo-网络架构">2.1 Yolo 网络架构</h2><p><img src="/images/yolo1_1.png" alt=""><br><img src="image.png" alt="alt text"></p><p>24层卷积层提取图像特征，2层全连接层回归得到7x7x30的向量。</p><p>输入是448x448x3的图像，也就是先将一张彩色图片缩放成448x448像素的图片，3是3通道RGB。然后经过若干个卷积层、池化层，最后变成一个7x7x1024维的feature map。再把它拉直，喂到一个4096个神经元的全连接层中输出4096维的向量。再把这个4096维向量喂到1470（7x7x30）个神经元的全连接层中，输出1470维的向量（其实最后是把这个1470维的向量Reshape成了7x7x30的向量）。最后输出的7x7x30维的向量包含就包含了所有预测框的坐标、置信度和类别结果。我们只需要解析这个向量就可以获得最终的结果。这个就是整个黑箱子的框架。</p><h2 id="2-2-为什么是7x7x30呢？">2.2 为什么是7x7x30呢？</h2><p>因为网络先把图像划分为SxS个grid cell（也就是网格），在YOLOV1中S=7。每个grid cell预测出B个bounding box（预测框），YOLOV1中B=2。每个grid cell预测出的两个bounding box可能很大也可能很小，也可能与其他的bounding box存在重叠，但是无所谓，只要bounding box的中心点落在这个grid cell里，就说明这个bounding box是由这个grid cell生成的。</p><p><img src="/images/yolo1_2.png" alt=""><br><img src="image-1.png" alt="alt text"></p><p>7x7=49个grid cell，每个grid cell生成两个bounding box，那么就生成了98个bounding box。bounding box包含x、y、h、w这四个坐标，由这四个坐标可以确定bounding box的位置。另外bounding box还包含一个它含不含有一个object的置信度（我理解为这个bounding box中含有物体的概率P(object)），在图像中置信度由bounding box边框线的粗细来表示，越粗置信度越高。这样一个bounding box可以由四个位置参数和一个置信度参数组成的(x,y,h,w,c)来表示。可视化出来就是上面图中由密密麻麻黑线的这幅图。</p><p>另外，每个grid cell还能生成所有类别的条件概率。也就是，假设输入在包含object的情况下，这些object是某个类别的概率。也就是上面图中有彩色块的图。把每个bounding box的置信度乘以类别条件概率，就能获得每个bounding box属于各类别的概率。7x7x30中的30为SxSx(5xB+C)。</p><p>再详细解释一些这个30。</p><p>每个grid cell包含2（即B）个预测框，每个预测框有5个参数，然后在Pascal VOC中包含20（即C）个类别。这一个30就是一个grid cell的信息，总共7x7个grid cell，所以是7x7x30维的向量。</p><p><img src="/images/yolo1_3.png" alt=""><br><img src="image-2.png" alt="alt text"><br>注：图中的box即bounding box</p><p>总结一下就是，输入一张图像，YOLO就能SxS个grid cell的信息，每个grid cell包含2个bounding box和20个类别，每个bounding box又包含4个位置参数和一个置信度参数。</p><h2 id="2-3-可视化过程">2.3 可视化过程</h2><ol><li><p>首先把图像分成SxS个grid cell，这里S=7：<br><img src="/images/yolo1_4.png" alt=""><br><img src="image-3.png" alt="alt text"></p></li><li><p>每个grid cell预测出两个bounding box（包含四个位置参数和一个置信度参数）</p></li></ol><p>比如对于下面图中这个红色的grid cell：<br><img src="/images/yolo1_5.png" alt=""><br><img src="image-4.png" alt="alt text"></p><p>它预测出两个bounding box，这两个bounding box一个置信度比较高，一个比较低（由线的粗细表示）：</p><p><img src="/images/yolo1_6.png" alt=""><br><img src="image-5.png" alt="alt text"></p><p>不管如何，输入图像都能预测出SxSx2=98个bounding box，只不过有些bounding box的置信度高，我们将其保留；有些低我们将其忽略。</p><ol start="3"><li>每个grid cell还能生成20个类别的条件概率：</li></ol><p><img src="/images/yolo1_7.png" alt=""><br><img src="image-6.png" alt="alt text"></p><p>这个图就展示了条件概率最高的几个类别所占有的框。比如紫色的grid cell是Bicycle这个类别的条件概率高的区域。每一个grid cell只能有一个类别，它是20个类别中条件概率最高的那一个。因此也说明了一个grid cell最多预测出一个一物体。7x7的grid cell最多预测出49个物体。这也是YOLOV1对小目标和密集目标识别性能差的原因。</p><ol start="4"><li>后处理<br>每个grid cell只有一个条件概率最高的代表类别，把这个grid cell的两个bounding box都赋予这个类别，再进行一系列后处理就得到了最终的目标检测结果。</li></ol><p><img src="/images/yolo1_8.png" alt=""><br><img src="image-7.png" alt="alt text"></p><p>把上面图中用红色部分标出来的部分，也就是所有的bounding box和所有grid cell的代表类别。每个类别赋予不同的颜色，把所有的bounding box的边框都用代表类别的颜色来表示，就得到了下面这幅图：</p><p><img src="/images/yolo1_9.png" alt=""><br><img src="image-8.png" alt="alt text"></p><p>总共98个bounding box，每个bounding box都有最高条件概率所对应的类别，再进行一系列后处理，比如过滤掉低置信度的bounding box，然后再去除掉重复的预测框，就获得了最终的目标检测结果。</p><h1>3. 预测阶段后处理</h1><p>总共98个bounding box，过滤掉低置信度的bounding box，然后再去除掉重复的预测框，就获得了最终的目标检测结果，这个过程称为<strong>NMS非极大值抑制</strong>。</p><p>现在想要讲解的就是YOLOV1输出的7x7x30的向量是如何变为最后的目标检测结果的。</p><p>7x7x30中的7x7即7x7个grid cell，取出其中一个grid cell来看，也就是30个数字。这30个数字是5+5+20。第一个5是第一个bounding box的4个位置坐标和1个置信度坐标，第二个5是第二个bounding box的4个位置坐标和1个置信度坐标，20是这个grid cell中的物体是20个类别的条件概率即P(ci|object)（P(object)是这个grid cell包含物体的概率，这其实就是置信度，ci是第i个类别）。</p><p>第一个bounding box的置信度乘以该grid cell的20个类条件概率：<br><img src="/images/yolo1_10.png" alt=""><br><img src="image-9.png" alt="alt text"><br>得到第一个bounding box的后验概率。</p><p>第二个bounding box的置信度乘以该grid cell的20个类条件概率：<br><img src="/images/yolo1_11.png" alt=""><br><img src="image-10.png" alt="alt text"><br>得到第二个bounding box的后验概率。</p><p>每个grid cell就能获得2个<strong>20个后验概率</strong>：<br><img src="/images/yolo1_12.png" alt=""><br><img src="image-11.png" alt="alt text"></p><p>7x7=49个grid cell就能获得7x7x2=98个<strong>20个后验概率</strong>：<br><img src="/images/yolo1_13.png" alt=""><br><img src="image-12.png" alt="alt text"></p><p>也就是我们获得了这个可视化图：<br><img src="/images/yolo1_9.png" alt=""><br><img src="image-8.png" alt="alt text"></p><p>接下来就是进行后处理得到目标检测结果图。</p><p>98个<strong>20个后验概率</strong>，称其为98个向量，每个向量是20x1的。假设这98个向量每个的第一个值为是狗的后验概率，也就是说是狗的后验概率的值有98个，在这些后验概率中有可能有很多接近于0的，设置一个阈值，假如设为0.2，那么小于0.2的值直接置为0。然后基于上一步处理后的是狗的后验概率对这98个后验概率进行降序排序，然后使用<strong>NMS非极大值抑制</strong>算法再次进行处理。</p><p><img src="/images/yolo1_14.png" alt=""><br><img src="image-13.png" alt="alt text"></p><p>先把第一个后验概率值取出来，也就是最大的后验概率，把它与其他97个后验概率值进行比较，计算它们的IoU（交并比，也就是度量它们的重叠程度）大于某个阈值，那么就认为它们重复识别了一个物体，就把低后验概率的值过滤掉也就是置为0。</p><ul><li>如果这个阈值设得很低，那么NMS非极大值抑制是很强的，它把IoU压得很低，稍微有一点重合就被过滤了</li><li>如果这个阈值设得很高，那么它们的IoU在更大的情况下才可能被过滤掉</li></ul><p>因此如果想增强NMS非极大值抑制就可以设置低阈值。</p><p>然后经过一轮后，第一个后验概率与其他97个后验概率经过了一轮比较，有部分已经被置为0了。然后去找下一个未被置为0的后验概率，接着与后面的后验概率进行比较，与上面相同。</p><p>上面只是对狗这个类别进行了NMS非极大值抑制，对于其他类别也要进行此操作。</p><p>上面的后处理<strong>只在预测阶段进行</strong>，在<strong>训练阶段不需要进行后处理</strong>，因为每一个bounding box都需要在损失函数中占据一席之地，它会影响损失函数。</p><h1>4. 训练阶段（重点）</h1><p>目标检测是一个典型的<strong>监督学习</strong>的过程，训练集已经进行了人工标注，它有点类似于bounding box，但是称它为ground truth（也就是正确打标记的数据）。我们的算法就是要去拟合这些ground truth，使得损失函数最小化。</p><p>ground truth是标准答案，它的中心点落在哪个grid cell，就有哪个grid cell预测出的两个bounding box中的一个负责去拟合这个ground truth，并且这个grid cell输出的类别也应该是这个ground truth的类别（每一个grid cell中有20个类别的类条件概率，这20个类条件概率乘以每一个bounding box的置信度获得后验概率，其中最大的后验概率对应的那个类应与ground truth的类别相同）。每一个grid cell只能预测出一个物体，7x7个grid cell只能预测出49个物体（YOLO在预测小目标和密集目标性能差的原因，前面提过了，再重复一遍）。</p><p>一个grid cell预测出两个bounding box，那由哪个去负责拟合ground truth呢？由和ground truth交并比IoU更大的那个bounding box。因此损失函数设计就要做到让负责拟合ground truth的那个bounding box与ground truth尽可能得一致。</p><p>刚刚说的grid cell是有ground truth的中心点落在里面的grid cell。没有ground truth中心点落入的grid cell，其预测出的两个bounding box就都被忽略了。</p><p>接下来的工作就是构建YOLOV1的损失函数。</p><h2 id="4-1-损失函数">4.1 损失函数</h2><p>损失函数包含5项：<br><img src="/images/yolo1_15.png" alt=""><br><img src="image-14.png" alt="alt text"></p><p>这5项都是残差平方和的回归问题的损失函数。因此YOLO是把目标检测问题当作了回归问题解决。</p><p>第一项是负责预测物体的bounding box<strong>中心点定位的误差</strong>，也就是负责预测物体的bounding box的横纵坐标要和ground truth的横纵坐标尽可能的一致。</p><p>第二项是负责预测物体的bounding box<strong>宽高定位的误差</strong>，也就是负责预测物体的bounding box的宽高要和ground truth的宽高尽可能的一致。加根号是为了使得小框对误差更敏感（也就是同样的偏差小框造成的损失更大，大框造成的损失更小）。</p><p>第三项是负责检测物体的bounding box的<strong>置信度误差</strong>。标签值是bounding box与ground truth的IoU，预测值即置信度。</p><p>第四项是<strong>不</strong>负责检测物体的bounding box的<strong>置信度误差</strong>。也就是所有被忽略的bounding box它们的置信度最好都为0，即标签值最好为0。不负责检测物体的bounding box包含两类：</p><ul><li>负责检测物体的grid cell中被忽略的bounding box</li><li>本身就不负责检测物体的grid cell预测出的bounding box</li></ul><p>第五项是负责检测物体的grid cell的<strong>分类误差</strong>。也就是ground truth的中心点落入的那个grid cell，它的20个类条件概率的最大值所对应的类别应与ground truth相同，并且这个概率越接近1越好。</p><p>前两项是<strong>坐标回归误差</strong>，第三、四项是<strong>置信度Confidence回归误差</strong>，最后一项是<strong>类别预测误差</strong>。</p><h1>声明</h1><p>本文是学习<a href="https://www.bilibili.com/video/BV15w411Z7LG/?spm_id_from=333.1245.0.0">【精读AI论文】YOLO V1目标检测，看我就够了</a>的记录，点击即可跳转视频链接。</p><p>注：本文图片来源于视频以及论文中，侵权联系删。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1. 目标检测综述&lt;/h1&gt;
&lt;p&gt;目标检测分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one-stage detector（单阶段模型）
&lt;ul&gt;
&lt;li&gt;代表有Yolo、SSD、Retina-net&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;two-stage detector</summary>
      
    
    
    
    <category term="Yolo" scheme="http://malone-ai.github.io/categories/Yolo/"/>
    
    
    <category term="深度学习" scheme="http://malone-ai.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Yolo" scheme="http://malone-ai.github.io/tags/Yolo/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 配置 MyBatis</title>
    <link href="http://malone-ai.github.io/2025/03/10/project-test4/"/>
    <id>http://malone-ai.github.io/2025/03/10/project-test4/</id>
    <published>2025-03-10T10:17:01.000Z</published>
    <updated>2025-03-12T04:39:09.666Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1AQAZeNEUJ/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】04. Springboot3整合MyBatis实现数据库操作</a>。</p><p>MyBatis 是一个持久层的框架，它可以连接数据库，实现数据库的增删查改。</p><h1>1. 创建数据库</h1><p><a href="https://malone-ai.github.io/2025/03/01/mysql1/">MySQL一：MySQL环境配置</a>。之前学习MySQL时的学习记录。</p><p>UP用的时Navicat，我用的是SQLyog</p><p>创建一个数据库，名称为code2025。<br>字符集选<code>utf8mb4</code>，排序规则选<code>utf8mb4_unicode_ci</code>。</p><p><img src="/images/project-test4_1.png" alt=""></p><p>新建一个表admin。另外注意，所有表的主键名称叫id，都是自动递增的，删除后无法再填充回去。比如删除id=2的数据，那么id=2就永远没有了。</p><p><img src="/images/project-test4_2.png" alt=""></p><p>还需要添加其他项，最终表如下：<br><img src="/images/project-test4_3.png" alt=""></p><p>找到表的DDL信息，复制下来：</p><p><img src="/images/project-test4_4.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `admin` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci COMMENT<span class="operator">=</span><span class="string">&#x27;管理员信息&#x27;</span></span><br></pre></td></tr></table></figure><p>这就是admin表的结构。</p><p>通过以下操作设置账号唯一：<br><img src="/images/project-test4_5.png" alt=""></p><p>向表中插入两条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+----------+---------+-------------+-----------------+</span><br><span class="line">| id | username | password | name    | phone       | email           |</span><br><span class="line">+----+----------+----------+---------+-------------+-----------------+</span><br><span class="line">|  1 | admin    | admin    | 管理员  | 13877886677 | admin@code.com  |</span><br><span class="line">|  2 | admin1   | admin1   | 管理员1 | 13877886678 | admin1@code.com |</span><br><span class="line">+----+----------+----------+---------+-------------+-----------------+</span><br></pre></td></tr></table></figure><h1>2. 添加工程依赖</h1><p><a href="https://mybatis.net.cn/index.html">MyBatis中文官网</a>。</p><p>在springboot工程下的pom.xml添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后点击：<br><img src="/images/project-test4_4.png" alt=""></p><p>即可加载新增的依赖。</p><p>在springboot工程下的src/main/resources/application.yml添加数据库配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 数据库配置</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: &#x27;123456&#x27;</span><br><span class="line">    url: jdbc:mysql://localhost:3306/code2025?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2b8</span><br></pre></td></tr></table></figure><p>其中username、password是自己设定的，url中3306/后的code2025是数据库的名称。</p><p>接着添加MyBatis配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 配置mybatis实体和xml映射</span><br><span class="line">mybatis:</span><br><span class="line">  # 映射xml</span><br><span class="line">  mapper-locations: classpath:mapper/*xml # classpath表示resources目录</span><br><span class="line">  configuration:</span><br><span class="line">    # 配置日志</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">    map-underscore-to-camel-case: true</span><br></pre></td></tr></table></figure><p>然后在resources目录下新建mapper目录。</p><h1>3. 添加实体类</h1><h2 id="3-1-新建Admin实体类">3.1 新建Admin实体类</h2><p>在springboot工程下的com.example里新建entity包（entity即实体类，它跟我们数据库的表所对应的一个java类，这个java类里面它的所有属性名字跟我们数据库表里面的属性名字是一致的），在这个包下再新建Admin实体类。</p><p>在这个Admin实体类里添加private属性，这些属性同前面我们创建的数据库中的表的属性一致，然后按住ALT+Insert快速添加setter和getter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id; <span class="comment">// 用Integer是因为可以允许null，但int不允许null</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-创建AdminMapper-xml文件">3.2 创建AdminMapper.xml文件</h2><p>在springboot工程下的src/main/resources/mapper目录下新建AdminMapper.xml文件，编辑内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.example.mapper.AdminMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.example.entity.Admin&quot;&gt;</span><br><span class="line">        select * from `admin` order by id desc</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/project-test4_7.png" alt=""></p><p>上面图中标注的部分对于mapper目录下的所有文件都是一样的。然后接下来的一行的namespace与接口层映射。</p><p>下载MyBatisX插件。</p><h2 id="3-3-创建AdminMapper接口">3.3 创建AdminMapper接口</h2><p>在springboot下的com.example下新建mapper包，再在这个包下创建AdminMapper接口。这个AdminMapper与前面创建的AdminMapper.xml对应。</p><p>在这个类下添加一个<code>selectAll</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdminMapper</span> &#123;</span><br><span class="line">    List&lt;Admin&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实对应于AdminMapper.xml文件中的<code>selectAll</code>，它提供了一个对外查询的接口。</p><p>这个接口是定义在mapper层，不能直接使用，得通过controller层来进行访问。</p><h2 id="3-4-在启动类中扫描mapper接口层">3.4 在启动类中扫描mapper接口层</h2><p>在springboot工程目录下的src/main/java/com/example/SpringbootApplication.java中添加<code>@MapperScan(&quot;com.example.mapper&quot;)</code>（这意为在主类中扫描mapper接口层）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-将接口从mapper传递到controller层">3.5 将接口从mapper传递到controller层</h2><p>在com.example.Service中的AdminService中添加方法<code>public List&lt;Admin&gt; selectAll</code>（先通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AdminMapper adminMapper;</span><br></pre></td></tr></table></figure><p>注入com/example/service/AdminService.java中的AdminService，便于通过它来调用mapper里的selectAll）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminMapper adminMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomerException</span>(<span class="string">&quot;账号错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Admin&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adminService.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在service层有了数据查询的方法。</p><p>接下来需要交给controller层使用。</p><p>在com.example.controller下新建AdminController类，并将这个类注册为controller（添加<code>@RestController</code>），通过<code>@Resource</code>将com.example.service下的AdminService注入，然后定义一个<strong>selectAll</strong>接口，并注册selectAll路由：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.example.controller.AdminController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/selectAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Admin&gt; admins = adminService.selectAll();</span><br><span class="line">        <span class="keyword">return</span> Result.success(admins);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面添加了<code>RequsetMapping(&quot;/admin&quot;)</code>是为了便于区分，为 它使得 AdminController 中的所有方法提供一个公共的 URL 前缀 /admin。</p><p>这样selectAll就被传递到了controller接口层，访问路径为<code>localhost:9999/admin/selectAll</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1AQAZeNEUJ/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>手撕线程池</title>
    <link href="http://malone-ai.github.io/2025/03/09/cpp-interview4/"/>
    <id>http://malone-ai.github.io/2025/03/09/cpp-interview4/</id>
    <published>2025-03-09T04:24:58.000Z</published>
    <updated>2025-03-10T08:37:12.484Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>学习一下线程池，主要参考Github代码仓库<a href="https://github.com/progschj/ThreadPool">https://github.com/progschj/ThreadPool</a></p><h1>1. 为什么需要线程池</h1><p>在多线程编程中，频繁创建和销毁线程会导致以下问题：</p><ul><li>资源开销大：线程创建需要分配栈空间、寄存器等资源。</li><li>调度开销高：操作系统频繁切换线程上下文。</li><li>管理复杂：线程数量过多时难以控制。</li></ul><p>因此引入线程池来解决这些问题。线程池的核心思想是<code>预先创建一组线程，通过任务队列管理待执行的任务。线程循环从队列中获取任务执行，避免频繁创建和销毁线程的开销</code>。</p><h1>2. 设计思想与关键机制</h1><ol><li>核心组件</li></ol><ul><li>任务队列（Task Queue）：存储待执行的任务（封装为std::function&lt;void()&gt;）。</li><li>工作线程（Workers）：多个线程循环从任务队列中获取任务。</li><li>同步机制：互斥锁（std::mutex）保护队列，条件变量（std::condition_variable）实现线程等待/唤醒。</li></ul><ol start="2"><li>工作流程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   [主线程]        |       [工作线程]</span><br><span class="line">      |            |            |</span><br><span class="line">提交任务到队列      |      等待任务到来</span><br><span class="line">      |            |            |</span><br><span class="line">  任务入队         |      从队列取任务</span><br><span class="line">      |            |            |</span><br><span class="line"> 唤醒工作线程       |      执行任务</span><br><span class="line">      |            |            |</span><br></pre></td></tr></table></figure><h1>3. 任务队列与enqueue函数</h1><h1>3.1 任务队列</h1><p>在实现线程池时，任务队列是核心组件之一。它的作用是存放待执行的任务，线程池中的工作线程会从队列中取出任务并执行。那么，什么是任务呢？</p><p>从编程的角度来看，任务本质上就是一个<code>函数</code>。</p><p>因此使用一个队列，并且队列存储的类型是函数，来组成任务队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt; std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br></pre></td></tr></table></figure><p>std::function是一个通用的函数封装器，其中的void代表没有返回值（或者返回值类型为void），圆括号表示没有参数。再比如<code>std::function&lt;int(int, int)&gt;</code>代表接收两个int类型参数并且返回值为int。</p><p>但是有一个问题？线程池需要支持<code>任意类型</code>的任务：</p><ul><li>可以是普通函数、类成员函数、Lambda表达式等</li><li>可以携带任意参数和返回值</li></ul><p>但为什么这里却使用了无参无返回值的<code>std::function&lt;void()&gt;</code>当作任务队列的成员的基本类型呢？</p><p>这看似矛盾的设计背后，实际上体现了<code>类型擦除</code>和<code>任务适配</code>的巧妙结合。</p><p>为了统一管理任务，必须将这些任务<code>适配</code>为一个统一的接口。std::function&lt;void()&gt;就是这个统一的接口。</p><ol><li>为什么选择void()？</li></ol><ul><li>最小接口：void()是最简单的函数签名，不涉及参数和返回值。</li><li>通用性：任何任务都可以通过<code>适配器</code>转换为void()类型。</li><li>执行与结果分离：线程池只负责<code>执行任务</code>，结果通过其他机制返回。</li></ul><ol start="2"><li>如何适配？<br>通过<code>任务包装器</code>将任意类型的任务转换为void()类型。具体来说：</li></ol><ul><li>使用std::bind绑定任务和参数，生成一个无参的可调用对象。</li><li>使用std::packaged_task将任务包装为void()类型，也就是没有返回值。如何获取返回值呢？使用该对象的get_future成员函数获取一个std::future对象，后续在调用这个对象的get成员函数即可。</li></ul><p>总的来说，就是为了方便管理才使用<code>std::function&lt;void()&gt;</code>当作任务队列的成员的基本类型，并且线程池只是执行这些任务，而任务的执行结果线程池并不在乎，使用其他办法来返回这个结果。</p><p>更具体的，我觉得应该结合成员函数enqueue来说明，</p><h1>3.2 成员函数enqueue</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用了C++11的模板（template&lt;class F, class… Args&gt;）和尾置返回类型（由<code>-&gt;</code>指明，<code>-&gt;</code>后即为返回值类型）。<code>F</code>是一个可调用对象的类型，<code>Args</code>是参数包的类型（<code>...</code>是 参数包展开的语法，用于处理可变模板参数）。<code>enqueue</code>函数的作用是将任务<code>f</code>和参数<code>args</code>打包成一个任务，放入线程池的任务队列中，并返回一个<code>std::future</code>以便获取任务执行的结果。</p><p>接下来，函数内部的第一行是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure><p>这里有几个关键点：</p><ol><li><p>std::result_of<br><code>std::result_of</code>是一个类型萃取工具（Type Trait），用于推导可调用对象（函数、Lambda、函数对象等）在给定参数类型下的返回类型。</p></li><li><p>typename<br><code>typename</code>在这里的作用是告诉编译器<code>std::result_of&lt;F(Args...)&gt;::type</code>是一个 类型，而不是一个静态成员变量或其他东西。这是C++模板编程中的一个常见语法规则，称为<code>依赖名称解析</code>。</p></li><li><p>using<br><code>using</code>在这里用于定义类型别名，类似于typedef。</p></li></ol><p>这里使用了<code>std::result_of</code>来推导调用<code>F</code>类型对象使用<code>Args...</code>参数后的返回类型。这行代码定义了<code>return_type</code>作为任务执行后的返回类型，用于后续的<code>std::packaged_task</code>和<code>std::future</code>的模板参数。</p><p>然后，创建了一个<code>std::packaged_task</code>对象，并将其包装在<code>std::shared_ptr</code>中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br></pre></td></tr></table></figure><p>它的核心目的是将用户提交的任务（可能带有参数和返回值）适配为线程池可以处理的统一形式（void()类型），同时保留任务的返回值以便异步获取。</p><p>这里有几个关键点：</p><ol><li>std::packaged_task</li></ol><p>std::packaged_task 是一个模板类，用于 包装一个可调用对象，并将其与一个 std::future 关联起来，从而支持 异步获取任务的返回值。它的核心功能包括：</p><ul><li>任务包装：将任意可调用对象（函数、Lambda、函数对象等）包装为一个可以延迟执行的任务。</li><li>结果关联：通过 get_future() 方法生成一个 std::future 对象，用于异步获取任务的返回值。</li></ul><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;)</span></span>;  <span class="comment">// 包装一个任务</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();         <span class="comment">// 获取 future</span></span><br><span class="line"><span class="built_in">task</span>();                                              <span class="comment">// 执行任务</span></span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;              <span class="comment">// 获取结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li>std::bind</li></ol><p><code>std::bind</code>用于将函数<code>f</code>和参数<code>args...</code>绑定在一起，生成一个新的可调用对象，它位于<code>&lt;functional&gt;</code>头文件中。<br>假设有一个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure><p>使用std::bind绑定参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_task = std::<span class="built_in">bind</span>(add, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>此时，bound_task是一个无参的可调用对象，调用bound_task()会返回5。</p><ol start="3"><li><p>完美转发<br><code>std::forward</code>用于保持参数的左值或右值属性，避免不必要的拷贝，实现完美转发。</p></li><li><p>std::make_shared<br>使用智能指针管理<code>std::packaged_task</code>的生命周期，确保任务在需要时不会被提前销毁。</p></li></ol><p>接下来获取<code>std::future</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure><p><code>std::packaged_task::get_future</code>返回一个与任务结果关联的<code>std::future</code>对象，通过它可以在未来某个时间点获取任务的返回值。</p><p>然后进入一个作用域块，锁定互斥量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(stop)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个关键点：</p><ol><li><p>互斥锁：使用<code>std::unique_lock</code>锁定互斥量，确保对任务队列的访问是线程安全的，当离开作用域时自动解锁。</p></li><li><p>停止检查：如果线程池已经停止（<code>stop</code>为<code>true</code>），则抛出异常，防止新任务被加入已停止的线程池。</p></li><li><p>任务入队：将任务包装成一个lambda表达式，并放入任务队列<code>tasks</code>中。lambda捕获了<code>task</code>的共享指针，当lambda被执行时，会调用<code>(*task)()</code>，即执行绑定的任务。</p></li></ol><p>之后，通知一个等待的线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure><p>通过条件变量<code>condition</code>的<code>notify_one</code>方法，唤醒一个正在等待的工作线程，让它从任务队列中取出并执行新加入的任务。</p><p>最后，返回之前获取的<code>std::future</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>用户可以通过这个<code>std::future</code>对象获取任务的执行结果，或者等待任务完成。</p><p>在整个过程中，需要注意的几个关键点：</p><ol><li><p><strong>完美转发</strong>：在<code>std::bind</code>中使用<code>std::forward</code>保持参数的值类别，确保无论是左值还是右值都能正确传递，避免不必要的拷贝。</p></li><li><p><strong>类型擦除</strong>：任务队列中的元素类型是<code>std::function&lt;void()&gt;</code>，而通过lambda表达式将具体的<code>std::packaged_task</code>包装成无参数、无返回值的函数，实现了类型擦除，使得不同类型的任务可以统一存储在同一个队列中。</p></li><li><p><strong>异常安全</strong>：在互斥锁的保护下检查<code>stop</code>标志，确保线程池停止后不再接受新任务，并且通过智能指针管理任务对象的生命周期，避免资源泄漏。</p></li><li><p><strong>异步结果处理</strong>：通过<code>std::packaged_task</code>和<code>std::future</code>的结合，实现了任务的异步执行和结果的获取，用户可以在适当的时候调用<code>future::get()</code>来等待任务完成并获取结果，或者检查任务是否完成。</p></li></ol><ul><li><strong><code>std::result_of</code>和<code>std::invoke_result</code>的区别？</strong></li></ul><p>C++17中<code>std::result_of</code>被废弃，改用<code>std::invoke_result</code>。但在C++11/14中，<code>std::result_of</code>是推导可调用对象返回类型的方式。其模板参数是一个函数类型，表示调用<code>F</code>类型对象使用<code>Args...</code>参数时的返回类型。</p><h1>4. 线程池的构造与析构</h1><h1>4.1 构造函数：工作线程的启动</h1><p>构造函数的核心任务是初始化线程池并启动指定数量的工作线程。</p><p>其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span></span></span><br><span class="line"><span class="function">    :   stop(false)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的基本流程：</p><ol><li>线程启动</li></ol><ul><li>循环创建 threads 个工作线程，每个线程执行一个 无限循环。</li><li>线程启动后立即进入等待状态（通过条件变量 condition）。</li></ul><ol start="2"><li>同步机制</li></ol><ul><li>条件变量等待：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure><ul><li>线程在以下两种情况下被唤醒：<ul><li>有新任务加入队列（tasks 非空）。</li><li>线程池被要求停止（stop == true）。</li></ul></li><li>当任务队列为空（tasks.empty()）且线程池未收到停止信号（stop == false）时，工作线程会进入阻塞状态，避免空转消耗 CPU 资源。</li><li><code>[this]&#123; return stop || !tasks.empty(); &#125;</code> 这个 Lambda 表达式是唤醒线程的条件判断</li><li>在调用 condition.wait() 时，锁会被自动释放，允许其他线程修改共享资源（例如添加任务或设置停止标志）。</li><li>当线程被唤醒时，会重新尝试获取锁，获取锁后继续操作，保证后续操作（如取任务 tasks.pop()）的线程安全</li><li>防止虚假唤醒<ul><li>条件变量的 wait() 方法可能因系统原因被虚假唤醒（即使条件未满足）。通过传入的 Lambda 表达式，线程在唤醒后必须重新检查条件，确保只有在条件真正满足时才会继续执行。</li></ul></li></ul><ol start="3"><li>任务执行流程：</li></ol><ul><li>从队列头部取出任务（tasks.front()），并通过 std::move 转移所有权。</li><li>在锁外执行任务（task()），避免长时间占用锁。</li></ul><h1>4.2 析构函数：安全关闭线程池</h1><p>析构函数负责停止线程池并等待所有工作线程退出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; worker : workers) &#123;</span><br><span class="line">        worker.<span class="built_in">join</span>();  <span class="comment">// 等待线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有如下关键点：</p><ol><li>停止信号</li></ol><ul><li>设置 stop = true，通知所有工作线程退出循环。</li><li>通过 condition.notify_all() 唤醒所有等待的线程。</li></ul><ol start="2"><li>线程回收：</li></ol><ul><li>使用 join() 等待所有线程自然退出，确保任务队列中的剩余任务被执行完毕。</li><li>析构函数的 异常安全：即使某个线程抛出异常，join() 仍能保证所有线程被正确回收。</li></ul><h1>5. 线程池的工作流程</h1><p>我个人感觉，线程池由多个线程组成，而多线程最重要的就是线程同步，因此同步机制就是线程池中核心中的核心。</p><p>主要解决的问题就是<code>多个线程对共享资源的安全访问</code>。这里的共享资源是任务队列。我们采用经典的<code>生产者-消费者模型</code>来解决这个问题：</p><ul><li>生产者（主线程）：通过enqueue添加任务</li><li>消费者（工作线程）：从队列获取任务执行</li></ul><h1>5.1 生产者-消费者模型</h1><p>其工作流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [生产者线程]                            [消费者线程]</span><br><span class="line">      |                                      |</span><br><span class="line">提交任务到队列                                |</span><br><span class="line">      |                                      |</span><br><span class="line">      |-- 任务入队 --&gt; [任务队列] --&gt; 任务出队 --|</span><br><span class="line">      |                                      |</span><br><span class="line">      |-- 唤醒消费者线程 ----------------------&gt;|</span><br><span class="line">      |                                      |</span><br><span class="line">      |                                执行任务</span><br></pre></td></tr></table></figure><h1>5.2 关键机制</h1><table><thead><tr><th>机制</th><th>作用</th></tr></thead><tbody><tr><td>互斥锁</td><td>保护任务队列的线程安全访问</td></tr><tr><td>条件变量</td><td>协调线程的等待与唤醒，避免忙等待</td></tr><tr><td>任务适配</td><td>将任意任务转换为统一接口（std::function&lt;void()&gt;）</td></tr><tr><td>异步结果反馈</td><td>通过 std::future 实现任务结果的异步获取</td></tr></tbody></table><h1>6. 完整代码</h1><p>完整代码可见代码仓库，这里也附上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>);</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// need to keep track of threads so we can join them</span></span><br><span class="line">    std::vector&lt; std::thread &gt; workers;</span><br><span class="line">    <span class="comment">// the task queue</span></span><br><span class="line">    std::queue&lt; std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronization</span></span><br><span class="line">    std::mutex queue_mutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span></span></span><br><span class="line"><span class="function">    :   stop(false)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">for</span>(std::thread &amp;worker: workers)</span><br><span class="line">        worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;学习一下线程池，主要参考Github代码仓库&lt;a href=&quot;https://github.com/progschj/ThreadPool&quot;&gt;https://github.com/progschj/ThreadPool&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;1. </summary>
      
    
    
    
    <category term="C/C++ 面试" scheme="http://malone-ai.github.io/categories/C-C-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
    <category term="线程池" scheme="http://malone-ai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>她的算法，我解不开</title>
    <link href="http://malone-ai.github.io/2025/03/09/my-feelings3/"/>
    <id>http://malone-ai.github.io/2025/03/09/my-feelings3/</id>
    <published>2025-03-09T03:42:35.000Z</published>
    <updated>2025-03-09T03:43:11.964Z</updated>
    
    
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>动态规划八：区间DP</title>
    <link href="http://malone-ai.github.io/2025/03/08/dp8/"/>
    <id>http://malone-ai.github.io/2025/03/08/dp8/</id>
    <published>2025-03-08T13:01:24.000Z</published>
    <updated>2025-03-08T16:47:22.407Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今日学习灵茶山艾府的<a href="https://www.bilibili.com/video/BV1Gs4y1E7EU/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">区间 DP：最长回文子序列【基础算法精讲 22】</a>。</p><p>前面的几个课程都是在数组的前缀或者后缀上转移的，这类DP叫做线性DP。</p><p>对于区间DP，会把问题规模缩小到数组中间的区间上，而不仅仅是前缀或者后置了。这是区间DP和线性DP的最大区别。</p><p>灵茶山艾府主要通过两道Leetcode题目<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列</a>和<a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/">1039. 多边形三角剖分的最低得分</a>来进行讲解。</p><h1>1. 最长回文子序列</h1><h1>1.1 题目描述</h1><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例 1：</p><pre><code>输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</code></pre><h1>1.2 基本思路</h1><h1>1.2.1 思路一</h1><p>由于回文子序列从左往右读和从右往左读都是一样的，所以可以求s和反转后的s的最长公共子序列，从而可以得到最长回文子序列的长度。</p><h1>1.2.2 思路二</h1><p>选或不选的思路来解决这道题。</p><p>只需要看第一个字母选或不选以及最后一个字母选或不选。</p><p><img src="/images/dp8_1.png" alt=""></p><p>定义dfs(i, j)表示从s[i]到s[j]的最长回文子序列的长度。</p><ul><li>如果s[i] == s[j]，那么就可以都选，i递归到i+1，j递归到j - 1。</li><li>如果s[i] != s[j]，那么要么不选s[i]，要么不选s[j]。</li></ul><p>那么状态转移方程：</p><pre><code>dfs(i, j) = dfs(i+1, j-1) + 2, s[i] == s[j]dfs(i, j) = max(dfs(i+1, j), dfs(i, j-1)), s[i] != s[j]</code></pre><p>如果递归到一个字母的时候，它一个字母也是一个回文子序列，所以返回1。如果没有字母就返回0</p><ul><li>递归边界<ul><li>dfs(i, i) = 1</li><li>dfs(i + 1, i) = 0</li></ul></li><li>递归入口<ul><li>dfs(0, n-1)</li></ul></li></ul><h1>1.3 具体实现</h1><h1>1.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = s[i] == s[j] ? <span class="built_in">dfs</span>(i<span class="number">+1</span>, j<span class="number">-1</span>) + <span class="number">2</span> : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">+1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.2 递推</h1><p>递归翻译成递推，需要注意一下循环顺序。</p><ul><li>由于f[i]从f[i+1]转移过来，所以i要<code>倒序</code>枚举。</li><li>由于f[i][j]从f[i][j-1]转移过来，所以i要<code>倒序</code>枚举。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    f[i][j] = f[i<span class="number">+1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            f[i%<span class="number">2</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    f[i%<span class="number">2</span>][j] = f[(i<span class="number">+1</span>)%<span class="number">2</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i%<span class="number">2</span>][j] = <span class="built_in">max</span>(f[(i<span class="number">+1</span>)%<span class="number">2</span>][j], f[i%<span class="number">2</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2. 多边形三角剖分的最低得分</h1><h1>2.1 题目描述</h1><p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。</p><p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p><p>返回 多边形进行三角剖分后可以得到的最低分 。</p><h1>2.2 基本思路</h1><p>数组values记为v。</p><p>定义<code>从i到j</code>表示沿着边从顶点i顺时针到顶点j的所有顶点（顶点i和顶点j除外），再加上直接从j到i的这条边所组成的多边形（三个顶点组成一个三角形）。</p><p><img src="/images/dp8_2.png" alt=""></p><p>子问题：</p><ul><li>计算从i到j的最低得分 =&gt; 枚举顶点k</li></ul><p>下一个子问题：</p><ul><li>计算从i到k的最低得分</li><li>计算从k到j的最低得分</li></ul><p>定义dfs(i, j)表示从i到j的多边形的最低得分</p><ul><li><p>dfs(i, j) = min{dfs(i, k) + dfs(k, j) + v[i] * v[j] * v[k]}, k = i + 1 ~ j - 1</p></li><li><p>递归边界</p><ul><li>dfs(i, i+1) = 0</li></ul></li><li><p>递归入口</p><ul><li>dfs(0, n-1)</li></ul></li></ul><h1>2.3 具体实现</h1><h1>2.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == j)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res = INT_MAX / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i, k) + <span class="built_in">dfs</span>(k, j) + values[i] * values[j] * values[k]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.2 递推</h1><p>状态转移方程为：</p><pre><code>f[i][j] = max&#123;f[i][k] + f[k][j] + v[i] * v[j] * v[k]&#125;, k = i + 1 ~ j - 1</code></pre><p>这里也需要注意循环顺序：</p><pre><code>i &lt; k，f[i]从f[k]转移过来，i需要倒序枚举j &gt; k, f[i][j]从f[i][k]转移过来，j需要正序枚举</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span>&amp; res = f[i][j];</span><br><span class="line">                res = INT_MAX / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, f[i][k] + f[k][j] + values[i] * values[j] * values[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>为什么 i 从 n-3 开始？</li></ul><ol><li><p>三角形的顶点要求</p><ul><li>要形成一个三角形，至少需要 3 个顶点。因此，i 和 j 之间至少要有 2 个顶点（即 j &gt;= i + 2）。</li><li>如果 i 从 n-1 或 n-2 开始，j 的范围会超出数组的边界，无法形成有效的三角形。</li></ul></li><li><p>边界条件</p><ul><li>当 i = n-3 时，j 可以从 i+2 = n-1 开始，这样 i、j 和中间的 k 可以形成一个有效的三角形。</li><li>如果 i 从 n-2 开始，j 只能从 n 开始，这已经超出了数组的边界。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;今日学习灵茶山艾府的&lt;a href=&quot;https://www.bilibili.com/video/BV1Gs4y1E7EU/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f4fa318d</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Springboot3 项目框架搭建</title>
    <link href="http://malone-ai.github.io/2025/03/07/project-test3/"/>
    <id>http://malone-ai.github.io/2025/03/07/project-test3/</id>
    <published>2025-03-07T13:36:48.000Z</published>
    <updated>2025-03-11T15:46:40.951Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1uZAoeGEqM/?spm_id_from=333.1245.0.0">【带小白做毕设】03. Springboot3框架的快速搭建以及项目工程的讲解</a>并进行一个学习记录。</p><h1>1. 新建工程</h1><p>在idea新建一个工程（注意新建工程页面在左边生成器中选择springboot），工程名为springboot，存放工程的文件夹为存放vue工程的文件夹。语言选Java，类型选Maven，组填com.example，工件填springboot，软件包名称填com.example，jdk选jdk21，java选21，打包选jar。然后选择下一步。</p><p><img src="/images/project-test3_1.png" alt=""></p><p>然后springboot选3.4.3，依赖项中从Web中选择Spring Web，然后点击创建即可。springboot工程就创建完毕了。</p><p><img src="/images/project-test3_2.png" alt=""></p><h1>2. 工程精简</h1><h1>2.1 删除无用文件</h1><p><img src="/images/project-test3_3.png" alt=""></p><p>删除图中画红线的文件。把src/test文件夹、src/main/resources下的static和templates文件夹也删除了。</p><h1>2.2 配置Maven</h1><p>打开设置，直接搜索Maven，配置Maven主路径（也就是Maven的解压路径，我的解压路径为D:\ProgramFiles\apache-maven-3.9.9）。勾选两个重写，然后指定用户设置文件为Maven解压路径下的conf文件夹下的settings.xml。在Maven解压路径下创建repo文件夹，然后选择本地仓库为这个repo文件夹。然后点击确定即可。</p><p><img src="/images/project-test3_4.png" alt=""></p><h1>2.3 pom.xml 文件精简</h1><p>pom.xml文件定义了一些依赖。</p><p><img src="/images/project-test3_5.png" alt=""></p><p><img src="/images/project-test3_6.png" alt=""></p><p>把pom.xml中的上述内容（如上两幅图片所示）删除。</p><h1>2.3 工程目录分析</h1><pre><code>.idea —— idea软件的配置文件src —— 源码目录src/main/java/com/example/SpringbootApplication —— 工程的启动类（文件后缀为.java），main函数就定义在这里。src/main/resources/application.properties —— 整个springboot的配置文件，将其重命名为application.yml，方便编辑    将其编辑为：        server:          port: 9999    以重新设置转发端口号target文件夹 —— 源码编译后的文件pom.xml —— 定义了springboot工程所有的依赖项，springboot加载的时候会扫描这个文件里面所有的依赖项，然后下载</code></pre><h1>2.4 运行工程出现的问题</h1><h1>2.4.1 Error：java 错误 不支持发行版本 5</h1><p>参考链接<a href="https://blog.csdn.net/weixin_43553694/article/details/104118190">Spring项目 Error：java 错误 不支持发行版本 5 IDEA解决办法</a></p><p><img src="/images/project-test3_7.png" alt=""></p><p><img src="/images/project-test3_8.png" alt=""></p><h1>2.4.2 org.springframework.boot不存在</h1><p>参考链接<a href="https://blog.csdn.net/Asa_Prince/article/details/127986463">解决java: 程序包org.springframework.boot不存在的解决方法</a>。</p><p>以及</p><p>File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven -&gt; Runner -&gt; Delegate IDE build/run actions to Maven</p><h1>3. 重启工程</h1><p>关闭这个springboot工程，打开springboot工程和vue工程共存的工程目录。将springboot工程目录下的.idea删除。</p><h1>3.1 重新加载springboot依赖</h1><p>右键springboot工程目录下的pom.xml，选择最下面的添加为Maven项目。</p><p><img src="/images/project-test3_9.png" alt=""></p><h1>3.2 设置编码</h1><p>设置编码为UTF-8。</p><p><img src="/images/project-test3_10.png" alt=""></p><p>然后运行springboot工程，运行成功则配置成功。</p><h1>4. 写一个测试接口</h1><h1>4.1 接口层</h1><p>右键springboot工程下的src/main/java/com/example，选择新建 -&gt; 软件包<br><img src="/images/project-test3_11.png" alt=""></p><p>包名设为controller（controller是对外提供接口的包，在这个包里定义的所有文件，都是对外提供接口数据的，叫接口层controller）。</p><p>springboot一般会分为三层：</p><ul><li>controller<ul><li>提供数据接口</li></ul></li><li>service<ul><li>处理业务逻辑</li></ul></li><li>mapper<ul><li>对接数据库</li></ul></li></ul><p>在controller包里再创建一个WebController，此时它默认会有以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在public class WebController上新增一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br></pre></td></tr></table></figure><p>回车自动补全，会帮助把需要的包也导进来。</p><p>这个行为就是将这个类定义为一个controller。</p><p>在WebController类下写一个get接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键入<code>@GetMapping</code>时按回车自动补全，会自动导包。</p><p>在<code>@GetMapping</code>后键入<code>(&quot;/hello&quot;)</code>定义路由。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口定义的基本格式：</p><ul><li>@GetMapping 表示这是一个get请求接口</li><li>括号里的路径是路由（路由全局唯一）</li></ul><p>此时运行springboot工程在网址<code>localhost:9999/hello</code>下就可以看到&quot;Hello World&quot;。</p><h1>4.2 查看网络请求</h1><p>在网址<code>localhost:9999/hello</code>下按F12，然后：<br><img src="/images/project-test3_12.png" alt=""></p><p>一开始可能不显示，按F5刷新一下即可~</p><h1>4.3 定义接口统一返回的对象</h1><p>前面我们定义的接口返回值类型为String，但也可能是其他数据类型，每个接口返回的数据类型不一样就会造成混乱。为了防止混乱，可以定义一个对象，把我们实际需要返回的数据，包裹在这个对象里面，作为这个对象的一个属性。</p><p>在com.example下新建一个common包（即通用包）。在common下再新建一个Result类。在其中定义三个属性：</p><ul><li>private String code<ul><li>状态码（使用String更通用，既可以返回数字，也可以返回其他等等）</li></ul></li><li>private Object data<ul><li>我们实际返回的数据类型</li></ul></li><li>private String msg<ul><li>当请求错误时返回错误信息（如返回账号或者密码错误）</li></ul></li></ul><p>然后按ALT+Insert，会出现：<br><img src="/images/project-test3_13.png" alt=""></p><p>选择Getter和Setter，接着出现：<br><img src="/images/project-test3_14.png" alt=""></p><p>全选后确定，这样就设置了上述三个private属性的setter和getter方法。</p><p>以上就是Result包装类。</p><h1>4.4 如何使用Result包装类</h1><p>如果我们想在Web类中统一返回这个Result包装类该如何做？</p><p>原来的接口返回的是String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在应该返回一个Result类，并且应该在函数中new一个Result的对象，并调用3.5中定义的setter方法设置这个类的三个属性后返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;200&quot;</span>);</span><br><span class="line">    result.setData(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在修改返回值类型为Result的时候一定要选择com.example.common里的Result类，选它会帮我们自动导包：<br><img src="/images/project-test3_15.png" alt=""></p><p>此时再访问网址<code>localhost:9999/hello</code>：<br><img src="/images/project-test3_16.png" alt=""></p><p>这里的msg为null，也就是为空，因为没有错误消息。</p><p>在前端与后端数据交互的时候，如果拿到消息后判断状态码是否为200，为200则说明请求成功，错误消息就应该为null。如果状态码不为200，说明请求失败，并获取msg来打印错误消息。</p><p>总结一下就是，对于Result包装类：</p><ul><li>code 作为前端判断请求是否成功的依据</li><li>msg 是错误信息</li><li>data 是返回给前端的数据</li></ul><h1>4.5 优化Result包装类</h1><p>如果我们每次写一个接口，都new一个Result类，然后再调用setter方法去设置成员属性，有点繁琐。</p><p>有没有更简单的方法？那就是在Result里写一个静态方法，接收一个参数为Object data：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;200&quot;</span>);</span><br><span class="line">    result.setData(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那使用这样一个静态方法有什么好处呢？就是简化了接口中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是成功的情况，如果是失败的情况呢？那就定义一个error静态方法，此时因为请求失败所有就没有数据了，接收的参数就从Object data变成了String msg（错误消息），并且在方法中将状态码code设置为500：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(<span class="string">&quot;500&quot;</span>);</span><br><span class="line">    result.setMsg(msg);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想自定义code呢？那就重载error静态方法，再额外接收一个String code参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String code, String msg)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    result.setCode(code);</span><br><span class="line">    result.setMsg(msg);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5. 异常处理</h1><h1>5.1 500错误</h1><p>如果在定义接口函数hello的时候：<br><img src="/images/project-test3_17.png" alt=""></p><p>也就是主动去引出一个除0异常，但是这里并没有报错，并且编译也能通过，这个就叫<code>运行时异常</code>，只有在运行时才会发现异常。此时运行springboot工程，访问这个接口会发现：<br><img src="/images/project-test3_18.png" alt=""></p><p>也就是抛出了500错误。</p><p>抛出这些错误非常的用户不友好，我们应该用统一的处理方式（用Result包装类处理）。</p><p>Result怎么去处理它呢？我们可以定义一个全局异常处理GlobalExceptionHandler。在com.example里新建一个包exception，再在这个包里创建GlobalExceptionHandler类。这个类就是全局异常捕获器，它负责把代码里的错误进行捕获，并统一通过Result类返回。</p><p>在public class GlobalExceptionHandler上面一行添加<code>@ControllerAdvice</code>，依然是回车自动补全（这样自动导包）。然后还要提供Controller类的路径，<code>@ControllerAdvice(&quot;com.example.controller&quot;)</code>。</p><p>在GlobalExceptionHandler类内部键入<code>@ExceptionHandler</code>（回车自动补全自动导包），然后圆括号键入Exception.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br></pre></td></tr></table></figure><p>这里的Exception就是Java中所有异常的基类。</p><p>然后换行键入<code>@ResponseBody</code>，@ResponseBody的作用其实是将java对象转为json格式的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br></pre></td></tr></table></figure><p>然后接着换行写error方法，返回值为Result对象，接收一个参数Exception e。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再运行springboot项目，访问接口：<br><img src="/images/project-test3_19.png" alt=""></p><p>就不会在返回500错误了。</p><p>出现异常了看控制台，跳转到出错的代码进行debug。</p><p>也可以使用一个log在控制台打印错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比原来新增两行代码，一个是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br></pre></td></tr></table></figure><p>还有一行是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br></pre></td></tr></table></figure><p>此时运行工程并访问接口，在控制台：<br><img src="/images/project-test3_20.png" alt=""></p><h1>5.2 自定义异常</h1><p>什么是自定义异常呢？比如前端传了一个账号密码过来，但是账号或者密码错了，怎么告诉前端账号或者密码错了呢？假设它在service层，而不是在controller层。</p><p>也就是在service往外抛出错误。不能直接return一个Result对象，因为Result对象是在controller层进行封装的。</p><p>其实就是不在controller层时，如何抛出错误？</p><p>这里就展示如何验证管理员页面也就是admin路由下登陆的账户名是否为&quot;admin&quot;。</p><p>在com.example新建一个service包，再在这个包下创建AdminService类。然后给AdminServie加Servie注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把这个AdminService类注册为了Springboot的一个bean。</p><p>然后在这个类中添加admin方法，接收一个String name参数的方法，如果name与&quot;admin&quot;相等就返回&quot;admin&quot;（也就是admin接口只接受&quot;admin&quot;账号），其他返回错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里先留着</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们到com/example/controller/WebController.java中写一个admin接口，并给这个接口传一个参数String name。这个时候我们需要去访问service中的方法。先通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AdminService adminService;</span><br></pre></td></tr></table></figure><p>注入这个service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在admin接口中通过这个adminService调用它的admin方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdminService adminService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/admin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">admin</span> <span class="operator">=</span> adminService.admin(name);</span><br><span class="line">        <span class="keyword">return</span> Result.success(admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前端调用admin接口传来一个name，当name等于&quot;admin&quot;时，返回&quot;admin&quot;；当不等于&quot;admin&quot;的时候返回错误。</p><p>不能在AdminService中的admin方法中直接返回&quot;账号错误&quot;，因为这个admin方法是通过admin接口调用的，这个&quot;账号错误&quot;返回后被admin接收，然后又通过<code>Result.success(admin)</code>返回，但此时状态码code还是200（请求成功）。</p><p>那么该如何返回错误呢？考虑自定义异常。</p><p>在com/example/exception类中新建一个CustomerException类，然后让这个类继承RuntimeException类（Java通过extends继承）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给这个类添加两个private属性，String code 和 String msg，也就是错误状态码和错误信息。继续利用ALT+Insert来快速实现他们的getter和setter方法以及构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">(String code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = <span class="string">&quot;500&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以完善AdminService类里的admin方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomerException</span>(<span class="string">&quot;账号错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在全局捕获器中捕获我们的自定义异常（原来只捕获Exception基类异常）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/example/exception/GlobalExceptionHandler.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(CustomerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">customerError</span><span class="params">(CustomerException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;自定义错误&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(), e.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中customerError中一定要把CustomerException对象e中包含的msg通过getMsg拿出来。</p><p>现在访问<code>localhost:9999/admin?name=1111</code>，其中<code>?name=1111</code>就是传递参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1uZAoeGEqM/?spm_id_from=333.1245.0.0&quot;&gt;【带小白做毕设】03. Springboot3框架的快速</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://malone-ai.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="http://malone-ai.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>动态规划七：状态机DP</title>
    <link href="http://malone-ai.github.io/2025/03/06/dp7/"/>
    <id>http://malone-ai.github.io/2025/03/06/dp7/</id>
    <published>2025-03-06T12:12:25.000Z</published>
    <updated>2025-03-10T07:24:37.815Z</updated>
    
    <content type="html"><![CDATA[<p>今日学习灵茶山艾府的<a href="https://www.bilibili.com/video/BV1ho4y1W7QK/?spm_id_from=333.1245.0.0&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">买卖股票的最佳时机【基础算法精讲 21】</a>。</p><h1>1. 买卖股票的最佳时机 II</h1><p>Leetcode 官方题目<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a>。</p><h1>1.1 题目描述</h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p>示例 1：</p><pre><code>输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。最大总利润为 4 + 3 = 7 。</code></pre><p>示例 2：</p><pre><code>输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。最大总利润为 4 。</code></pre><p>示例 3：</p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</code></pre><h1>1.2 思路</h1><p><code>启发思路</code>：最后一天发生了什么？</p><p>对于 prices = [7,1,5,3,6,4]</p><pre><code>从第0天开始到第5天结束时的利润= 从第0天开始到第4天结束时的利润 + 第5天的利润= 。。。</code></pre><p>如果第5天什么也没做，那么利润是0。如果买入4块钱的股票，那么利润是-4。如果4块钱卖掉股票，那么利润是4（即赚了4块钱，但是这里说的赚了4块钱没有考虑买入股票花的钱）。假如第5天卖掉的股票是花6块钱买入的，那么这个利润-6需要算在第0天开始到第4天结束时的利润里面。</p><p>那么第i天我们可以做哪些事儿呢？看这张图：<br><img src="/images/dp7_1.png" alt=""></p><ul><li>什么也不做<ul><li>状态不变</li></ul></li><li>买入股票<ul><li>那么就从第i-1天未持有股票的状态，变成第i天结束时持有股票的状态</li></ul></li><li>卖出股票<ul><li>那么就从第i-1天持有股票的状态，变成第i天结束时未持有股票的状态</li></ul></li></ul><p>从图中可以看出状态转移一共有四种状态，其中持有股票或者未持有股票时，既不买入也不卖出是两种状态。</p><ul><li>定义 dfs(i,0)表示到第i天结束时，未持有股票，最大利润</li><li>定义 dfs(i,1)表示到第i天结束时，持有股票，最大利润</li></ul><p>（这里的参数0/1是一个bool类型的值。）</p><p>由于第i-1天的结束就是第i天的开始dfs(i-1,·)也表示到第i天开始时的最大利润。</p><p>继而可以得到以下图：<br><img src="/images/dp7_2.png" alt=""></p><p>从每个状态可以转移到其他状态，将这些其他状态取最大值就可以得到：</p><pre><code>dfs(i, 0) = max(dfs(i-1, 0) + dfs(i-1, 1) - prices[i])dfs(i, 1) = max(dfs(i-1, 1) + dfs(i-1, 0) + prices[i])</code></pre><p>递归边界：</p><pre><code>dfs(-1, 0) = 0  第0天`开始时`未持有股票，利润为0dfs(-1, 1) = 0  第0天`开始时`不可能持有股票</code></pre><p>递归入口：</p><pre><code>max(dfs(n-1, 0), dfs(n-1, 1))= dfs(n-1, 0)</code></pre><p>看上去枚举最后一天是否持有股票就可以了，但是如果最后一天结束时还持有股票，这个股票在后面就卖不出去了（或者说不在题目考虑的范围内）。所以dfs(n-1, 1)是不会比dfs(n-1, 0)大的，故从dfs(n-1, 0)开始递归即可。</p><h1>1.3 具体实现</h1><h1>1.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = j == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.2 递推 空间复杂度O(n)</h1><p>递归很容易翻译成递推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.3 递推 空间复杂度O(1) 两个数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(1) 两个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[(i + <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i % <span class="number">2</span>][<span class="number">0</span>], f[i % <span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[(i + <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i % <span class="number">2</span>][<span class="number">1</span>], f[i % <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.3.4 递推 空间复杂度O(1) 不用数组</h1><p>这种貌似难想，但其实画个图再对照一下两个数组的代码就很容易想到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(1) 不用数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f1 = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> f0_tmp = f0;</span><br><span class="line">            f0 = <span class="built_in">max</span>(f0, f1 + prices[i]);</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1, f0_tmp - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4 变形题目：309. 买卖股票的最佳时机含冷冻期</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期</a>。</p><h1>1.4.1 题目描述</h1><p>给定一个整数数组prices，其中 prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><pre><code>输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><p>示例 2:</p><pre><code>输入: prices = [1]输出: 0</code></pre><h1>1.4.2 思路</h1><p>这道题有冷冻期，就是在卖出后不能立刻买入股票。换句话就是买入股票的时候，前一天不能有卖出操作。这其实和和<a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍</a>很像。在打家劫舍中，从右往左思考，如果选第i个房子，那么第i-1个房子不能选，所以直接递归到第i-2个房子。</p><p>这道题也是一样的。<br>状态转移：</p><ul><li>如果今天不持有股票，那么有两种可能：<ul><li>前一天也不持有股票，今天什么都不做。</li><li>前一天持有股票，今天卖出股票。</li><li>因此，状态转移方程为：dfs(i, 0) = max(dfs(i-1, 0), dfs(i-1, 1) + prices[i])</li></ul></li><li>如果今天持有股票，那么有两种可能：<ul><li>前一天也持有股票，今天什么都不做。</li><li>前两天不持有股票，今天买入股票（因为有冷冻期，所以不能在前一天卖出后立即买入）。</li><li>因此，状态转移方程为：dfs(i, 1) = max(dfs(i-1, 1), dfs(i-2, 0) - prices[i])</li></ul></li></ul><p>当hold为1的时候，当前状态是持有股票。那这个状态可以来自两种情况：要么在i-1天已经持有，继续持有；要么在第i天买入。但买入的话，必须满足之前处于未持有状态，并且没有在i-1天卖出。因为如果有卖出的话，i天不能买入。</p><p>所以，当在第i天买入的话，那么必须保证i-1天处于冷却期，也就是i-1天没有操作。那么i-1天不操作的情况下，说明i-2天的时候可能已经卖出了，这样i-1天是冷却期，i天就可以买入。这就是为什么递归到i-2天的原因。</p><h1>1.4.3 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = j == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-2</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4.4 递推 空间复杂度 O(n)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度 O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i<span class="number">+2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][<span class="number">0</span>], f[i<span class="number">+1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i<span class="number">+2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>1.4.5 递推 空间复杂度 O(1)</h1><p>这个空间复杂度为O(1)的是真想不明白😂。</p><p>现在是3.10，今天复习把这个想出来了，还得是画图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f2 = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> f1_tmp = f1;</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1, f2 + prices[i]);</span><br><span class="line">            f2 = <span class="built_in">max</span>(f2, f0 - prices[i]);</span><br><span class="line">            f0 = f1_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2. 买卖股票的最佳时机 IV</h1><p>Leetcode 官方题目<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV</a>。</p><h1>2.1 题目描述</h1><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1：</p><pre><code>输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</code></pre><p>示例 2：</p><pre><code>输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</code></pre><h1>2.2 基本思路</h1><p>定义 dfs(i,j,0) 表示到第 i 天<code>结束</code>时完成<code>至多</code> j 笔交易，未持有股票的最大利润。<br>定义 dfs(i,j,1) 表示到第 i 天<code>结束</code>时完成<code>至多</code> j 笔交易，持有股票的最大利润。</p><p>状态转移图如下图：</p><p><img src="/images/dp7_3.jpg" alt=""></p><p>既然有次数限制，就应当在递归过程中记录次数。所以在无限次交易的基础上增加一个参数j，表示<code>至多</code>完成j笔交易。转移方程需要修改的地方就是在买入或者卖出的地方把交易次数减1，如果买入减1，后面卖出的时候就不用减1。</p><pre><code>dfs(i,j,0) = max(dfs(i-1,j,0), dfs(i-1,j,1) + prices[i])dfs(i,j,1) = max(dfs(i-1,j,1), dfs(i-1,j-1,0) - prices[i])</code></pre><p>递归边界：</p><pre><code>dfs(·, -1, ·) = -∞, 任何情况下，j都不能为负dfs(-1, j, 0) = 0, 第 0 天开始未持有股票，利润为 0dfs(-1, j, 1) = -∞，第 0 天开始不可能持有股票</code></pre><h1>2.3 具体实现</h1><h1>2.3.1 递归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">memo</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>)));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> l)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> l == <span class="number">0</span> ? <span class="number">0</span> : INT_MIN / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j][l];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = l == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">0</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">1</span>) + prices[i]) : <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j, <span class="number">1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>, <span class="number">0</span>) - prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.2 递推 空间复杂度O(n*k)</h1><ul><li><p>为什么第二维度的大小是 k+2？</p><ul><li>在记忆化搜索中，j 的范围是 [−1,k]，这一共有 k+2 个数。1:1 翻译成递推就需要 k+2 的数组大小。</li></ul></li><li><p>f 数组中的 j=0 表示什么意思？</p><ul><li>这对应着记忆化搜索中的 j=−1 的状态，也就是交易 −1 次的状态。注意这是不合法的，所以初始值一定是 −∞。</li></ul></li><li><p>f 的初始值怎么确定？</p><ul><li>f 的初始值来自记忆化搜索的递归边界，递归边界怎么写，初始值就怎么写。</li></ul></li></ul><p>作者：灵茶山艾府<br>链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(n*k)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN / <span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j)</span><br><span class="line">            f[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">0</span>], f[i][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                f[i<span class="number">+1</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">1</span>], f[i][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][k<span class="number">+1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2.3.3 递推 空间复杂度O(k)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(k)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN / <span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j)</span><br><span class="line">            f[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i%<span class="number">2</span>][j][<span class="number">0</span>], f[i%<span class="number">2</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                f[(i<span class="number">+1</span>)%<span class="number">2</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i%<span class="number">2</span>][j][<span class="number">1</span>], f[i%<span class="number">2</span>][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">2</span>][k<span class="number">+1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日学习灵茶山艾府的&lt;a href=&quot;https://www.bilibili.com/video/BV1ho4y1W7QK/?spm_id_from=333.1245.0.0&amp;amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a&quot;&gt;</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>总结一下最近</title>
    <link href="http://malone-ai.github.io/2025/03/06/my-feelings2/"/>
    <id>http://malone-ai.github.io/2025/03/06/my-feelings2/</id>
    <published>2025-03-06T10:01:04.000Z</published>
    <updated>2025-03-06T12:28:59.197Z</updated>
    
    <content type="html"><![CDATA[<p>回顾一下最近的一个月。2.6号还在家，天天刷着leetcode，看看github上的一些源码，偶尔自己写写，再有空写写博客。</p><p>2.13准备返校，但是突发了一些意外，请假了，最后放了同学鸽子（本来说好一起返校的），不过好在返校后请人家吃了一顿，应该也消气了。</p><p>2.24开始返校，返校后一直在修改简历，想要投递个实习。基本上每天都在学C++的一些新特性以及一些八股文相关，然后刷刷leetcode，写写博客。</p><p>中间甚至在学java和前端🤣。java不难，因为两年前学过，并且java的很多语法与C++类似，只不过java也有很多高级的特性，比如垃圾回收机制等等，当时一度感觉就是因为java的垃圾回收机制，C++才会有智能指针。前端主要是vue3，感觉它比html要强大太多了。</p><p>还有就是，目前写的不少博客，内容基本上是B站上视频的学习的记录或者学习其他的博客，然后进行一个整理。整理和记录视频是因为看视频来进行复习回顾确实费时费力不讨好。整理其他人的博客也是一个很费时的事，说他是造轮子感觉太高大上了，说是搬运工感觉更合适。不过不可否认自己学到了很多东西。</p><p>目前的想法是，对于其他人博客的学习，只提出转载声明然后提供跳转链接，不做过多的整理。但是貌似也不是一件容易的事儿，最怕的还是版权问题。自己消化理解后再撰写博客和那完全是两码事儿。目前没有更好的解决方案了😵。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回顾一下最近的一个月。2.6号还在家，天天刷着leetcode，看看github上的一些源码，偶尔自己写写，再有空写写博客。&lt;/p&gt;
&lt;p&gt;2.13准备返校，但是突发了一些意外，请假了，最后放了同学鸽子（本来说好一起返校的），不过好在返校后请人家吃了一顿，应该也消气了。&lt;/</summary>
      
    
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://malone-ai.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>CMake 保姆级教程[转载]</title>
    <link href="http://malone-ai.github.io/2025/03/06/chores3/"/>
    <id>http://malone-ai.github.io/2025/03/06/chores3/</id>
    <published>2025-03-06T05:48:34.000Z</published>
    <updated>2025-03-06T05:51:01.455Z</updated>
    
    <content type="html"><![CDATA[<p>提供一下一个优秀的个人博客网站中写的CMake教程的跳转链接（侵权删）：</p><ul><li><a href="https://subingwen.cn/cmake/CMake-primer/">CMake 保姆级教程（上）</a></li><li><a href="https://subingwen.cn/cmake/CMake-advanced/">CMake 保姆级教程（下）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提供一下一个优秀的个人博客网站中写的CMake教程的跳转链接（侵权删）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://subingwen.cn/cmake/CMake-primer/&quot;&gt;CMake 保姆级教程（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
    <category term="CMake" scheme="http://malone-ai.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>GDB 调试</title>
    <link href="http://malone-ai.github.io/2025/03/06/chores2/"/>
    <id>http://malone-ai.github.io/2025/03/06/chores2/</id>
    <published>2025-03-06T03:16:07.000Z</published>
    <updated>2025-03-06T05:24:08.695Z</updated>
    
    <content type="html"><![CDATA[<p>GDB是Linux下非常好用且强大的调试工具。GDB可以调试C、C++等多种语言。</p><h1>1. 判断文件是否带有调试信息</h1><p>C/C++的编译文件有两种版本：</p><ul><li>release版本</li><li>debug版本</li></ul><p>gcc和g++默认编译生成的是release版本，release版本不带有调试信息，通常体积更小。</p><p>而如果在编译时带上&quot;-g&quot;参数，那么编译生成的就是debug版本。debug版本带有调试信息，体积通常会更大。</p><p>如果你想对一个C/C++的编译文件进行调试，那么它必须是debug版本，也就是编译时带了&quot;-g&quot;参数，带有调试信息的二进制可执行文件。</p><p>有一个编译好的二进制文件，你不确定是不是debug版本，是否带有调试信息，有两种方法可以确定。</p><ol><li>使用 gdb 命令</li></ol><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行gdb test命令后，如果其不是debug版本，不带有调试信息，那么就会显示：</p><pre><code>Reading symbols from test...(No debugging symbols found in test)</code></pre><p>（当然还有其他的一些信息会显示，如gdb版本等等。）</p><ul><li>带有调试信息（debug）</li></ul><p>如果带有调试信息，是debug版本，那么会显示：</p><pre><code>Reading symbols from test...</code></pre><p>也就是比不带有调试信息的少一行<code>(No debugging symbols found in test)</code>提示。</p><ol start="2"><li>使用 readelf 命令</li></ol><p>还可以使用命令readlef查看可执行文件是否带有调试功能。</p><ul><li>不带有调试信息（release）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果其不是debug版本，不带有调试信息，那么不会显示任何内容。</p><ul><li>带有调试信息（debug）</li></ul><p>对于一个可执行文件test，执行<code>readelf -S test | grep debug</code>命令后，如果是debug版本，带有调试信息，那么类似于以下的内容：</p><pre><code>[28] .debug_aranges    PROGBITS         0000000000000000  0000303b[29] .debug_info       PROGBITS         0000000000000000  0000306b[30] .debug_abbrev     PROGBITS         0000000000000000  00005429[31] .debug_line       PROGBITS         0000000000000000  000059df[32] .debug_str        PROGBITS         0000000000000000  00005b41[33] .debug_line_str   PROGBITS         0000000000000000  00006cfb</code></pre><p>总之带调试信息的会显示内容，不带调试信息的不显示任何内容。</p><h1>2. GDB 命令汇总</h1><table><thead><tr><th>指令</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td><code>l</code></td><td><code>list</code></td><td>显示对应的代码，每次10行。可以指定行号或函数名。</td></tr><tr><td><code>r</code></td><td><code>run</code></td><td>无断点直接运行到底，有断点就运行到下一个断点然后停止。</td></tr><tr><td><code>b</code></td><td><code>breakpoint</code></td><td>在指定行号或函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:函数名</code></td><td><code>breakpoint</code></td><td>在该函数的第一行打上断点。</td></tr><tr><td><code>b 源文件:行号</code></td><td><code>breakpoint</code></td><td>在该源文件中的指定行号打上断点。</td></tr><tr><td><code>info b</code></td><td><code>info breakpoints</code></td><td>查看断点的信息。</td></tr><tr><td><code>d</code></td><td><code>delete</code></td><td>删除指定编号的断点。</td></tr><tr><td><code>d breakpoints</code></td><td><code>delete breakpoints</code></td><td>删除所有的断点。</td></tr><tr><td><code>disable b</code></td><td><code>disable breakpoints</code></td><td>使所有断点无效。</td></tr><tr><td><code>disable b 编号</code></td><td><code>disable breakpoint</code></td><td>使指定编号的断点无效。</td></tr><tr><td><code>enable b</code></td><td><code>enable breakpoints</code></td><td>使所有断点有效。</td></tr><tr><td><code>enable b 编号</code></td><td><code>enable breakpoint</code></td><td>使指定编号的断点有效。</td></tr><tr><td><code>n</code></td><td><code>next</code></td><td>逐过程。</td></tr><tr><td><code>s</code></td><td><code>step</code></td><td>单步调试。</td></tr><tr><td><code>bt</code></td><td><code>backtrace</code></td><td>查看函数调用。</td></tr><tr><td><code>set var</code></td><td><code>set variable</code></td><td>修改变量的值。</td></tr><tr><td><code>p</code></td><td><code>print</code></td><td>打印变量的值。</td></tr><tr><td><code>display</code></td><td><code>display</code></td><td>追踪变量，每次停下来都显示它的值。</td></tr><tr><td><code>undisplay</code></td><td><code>undisplay</code></td><td>取消追踪。</td></tr><tr><td><code>until</code></td><td><code>until</code></td><td>继续执行，直至下一个断点处停止。</td></tr><tr><td><code>finish</code></td><td><code>finish</code></td><td>单步跳出，执行完当前所在函数后停止。</td></tr><tr><td><code>c</code></td><td><code>continue</code></td><td>从一个断点处，直接运行至下一个断点处。</td></tr></tbody></table><h1>3. GDB调试实践</h1><h2 id="3-1-编译出debug版本的二进制可执行文件">3.1 编译出debug版本的二进制可执行文件</h2><p>以下是将要用于调试的C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，用于计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，用于演示指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pointerDemo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *ptr = <span class="number">100</span>; <span class="comment">// 修改指针指向的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">factorial</span>(num); <span class="comment">// 计算阶乘</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Factorial of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;value;</span><br><span class="line">    <span class="built_in">pointerDemo</span>(ptr); <span class="comment">// 演示指针操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value after pointerDemo: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个简单的循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Loop iteration: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态内存分配</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放动态内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> test.cpp -g</span><br></pre></td></tr></table></figure><p>进行编译可得带调试信息的二进制可执行文件test。</p><h2 id="3-2-启动GDB">3.2 启动GDB</h2><p>可以使用gdb [要调试的二进制可执行文件名称]如gdb test来启动gdb调试，此时会进入gdb的命令行。也可以直接输入gdb回车进入gdb命令行后输入file test后回车来调试test。</p><h2 id="3-3-部分命令详解">3.3 部分命令详解</h2><h3 id="3-3-1-list">3.3.1 list</h3><p>简写为l（小写L），输入后便会展示10行代码，第一次使用会随机展示连续的10行代码。</p><p>如果输入<code>l [函数名]</code>，那么就会展示函数名所在的上面5行和包括函数名所在行在内的下面5行，至少10行。</p><p>如果输入<code>l [行号]</code>，那么就会展示那行代码所在的上面5行和包括那行行在内的下面5行，至少10行。</p><p>如果继续按住<code>Enter</code>，那么会展示接下来的几行代码。因为gdb会自动记忆你上次敲入的指令。</p><h3 id="3-3-2-breakpoint（插入断点）">3.3.2 breakpoint（插入断点）</h3><p>简写为b。</p><pre><code>b 行号 —— 在那一行打断点</code></pre><p>如<code>b 20</code>就是在第20行打上断点。</p><pre><code>b 源文件：函数名 —— 在该函数的第一行打上断点</code></pre><p>如<code>b test.cpp: main</code>就是在源文件的该函数的第一行打上断点。</p><pre><code>b 源文件：行号 —— 在该源文件中的这行加上一个断点</code></pre><p>如<code>b test.cpp: 20</code>就是在源文件的第20行打上断点。</p><h3 id="3-3-3-info">3.3.3 info</h3><p>直接执行info命令，就会显示所有的调试信息。</p><pre><code>info b —— 查看断点的信息</code></pre><p>info b会展示以下信息：</p><pre><code>Num —— 编号Type —— 类型Disp —— 状态Enb —— 是否可用Address —— 地址What —— 在此文件的哪个函数以及此文件的第几行</code></pre><h3 id="3-3-4-删除断点">3.3.4 删除断点</h3><pre><code>d 编号 —— 删除此编号的断点d —— 删除所有断点</code></pre><h3 id="3-3-5-开启-禁用断点">3.3.5 开启/禁用断点</h3><pre><code>disable b —— 使所有断点无效disable b 编号 —— 使此编号的断点无效enable b —— 使所有断点有效enable b 编号 —— 使此编号的断点有效</code></pre><h3 id="3-3-6-run">3.3.6 run</h3><p>简写为r，无断点直接运行到底，有断点就运行到下一个断点然后停止。</p><h3 id="3-3-7-逐过程-和-单步调试">3.3.7 逐过程 和 单步调试</h3><p>next简写为n，为逐过程，会一行一行地执行源文件中的代码。</p><p>step简写为s，为单步调试，也是一行一行地执行源文件中的代码，不同的是，它还会跳转库函数的代码。</p><h3 id="3-3-8-打印-和-追踪">3.3.8 打印 和 追踪</h3><p>print简写为p，为打印</p><pre><code>p 变量名 —— 打印变量值</code></pre><p>display，为追踪</p><pre><code>display 变量名 —— 追踪查看一个变量，每次停下来都显示它的值</code></pre><p>undisplay为取消追踪</p><pre><code>undisplay + 变量名编号 —— 取消对该编号变量的跟踪</code></pre><h3 id="3-3-9-bt">3.3.9 bt</h3><p>bt命令用于查看当前调用了哪些函数。</p><h3 id="3-3-10-修改变量的值">3.3.10 修改变量的值</h3><pre><code>set var —— 修改变量的值</code></pre><p>如<code>set var i = 0</code>就是将变量i的值设为0。</p><h3 id="3-3-11-until">3.3.11 until</h3><pre><code>until 行号 —— 继续执行当前代码，直到执行到该行号为止。</code></pre><h3 id="3-3-12-finish">3.3.12 finish</h3><pre><code>finish —— 执行完当前所在函数后停止。</code></pre><p>finish应该就是单步跳出了。</p><h3 id="3-3-13-continue">3.3.13 continue</h3><p>简写为c。</p><pre><code>c —— 继续执行，直至下一个断点处停止。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GDB是Linux下非常好用且强大的调试工具。GDB可以调试C、C++等多种语言。&lt;/p&gt;
&lt;h1&gt;1. 判断文件是否带有调试信息&lt;/h1&gt;
&lt;p&gt;C/C++的编译文件有两种版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;release版本&lt;/li&gt;
&lt;li&gt;debug版本&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>左值引用 与 右值引用</title>
    <link href="http://malone-ai.github.io/2025/03/05/cpp-interview3/"/>
    <id>http://malone-ai.github.io/2025/03/05/cpp-interview3/</id>
    <published>2025-03-05T15:40:27.000Z</published>
    <updated>2025-03-06T03:15:19.939Z</updated>
    
    <content type="html"><![CDATA[<p>来复习总结一下左值引用与右值引用。</p><p>左值引用和右值引用是 C++ 中用于管理对象生命周期的两种引用类型，主要区别在于它们绑定的对象类型和使用场景</p><h1>左值引用（Lvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp; 声明的引用，只能绑定到 左值（有名字、有内存地址的对象）。</p><ol start="2"><li>特点</li></ol><ul><li>左值对象通常可以被修改（除非被 const 修饰）。</li><li>常用于函数参数传递（避免拷贝）或为现有对象起别名。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref_a = a;  <span class="comment">// 正确：左值引用绑定左值</span></span><br><span class="line"><span class="comment">// int&amp; ref_b = 10;  // 错误：不能绑定到右值（字面量）</span></span><br></pre></td></tr></table></figure><h1>右值引用（Rvalue Reference）</h1><ol><li>定义</li></ol><p>用 &amp;&amp; 声明的引用，只能绑定到 右值（临时对象、字面量、即将销毁的对象）。<br>2. 特点</p><ul><li>C++11 引入，用于实现<code>移动语义</code>和<code>完美转发</code>。</li><li>允许“窃取”右值的资源（如动态内存），避免不必要的拷贝。</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span>;  <span class="comment">// 正确：右值引用绑定右值</span></span><br><span class="line"><span class="comment">// int&amp;&amp; rref2 = a;  // 错误：不能直接绑定左值</span></span><br></pre></td></tr></table></figure><h1>左值引用与右值引用的区别</h1><table><thead><tr><th>特性</th><th>左值引用 (&amp;)</th><th>右值引用 (&amp;&amp;)</th></tr></thead><tbody><tr><td>绑定对象类型</td><td>左值（持久对象）</td><td>右值（临时对象）</td></tr><tr><td>可修改性</td><td>允许修改（除非 const）</td><td>允许修改</td></tr><tr><td>主要用途</td><td>避免拷贝、别名</td><td>移动语义、完美转发</td></tr></tbody></table><h1>应用场景</h1><ol><li>移动语义（Move Semantics）</li></ol><p>右值引用允许将资源（如堆内存）从临时对象“移动”到新对象，避免深拷贝。</p><p>假设有一个管理动态数组的类 MyArray：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyArray</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当发生拷贝时（如 MyArray b = a），默认的拷贝构造函数会执行浅拷贝，导致两个对象共享同一块内存，引发双重释放等问题。为此，我们需要：</p><ul><li>深拷贝：显式实现拷贝构造函数，复制数据（安全但性能差）。</li><li>移动语义：直接“窃取”临时对象的资源（高效且安全）。</li></ul><p>移动语义的<code>核心机制</code><br>（1）右值引用（&amp;&amp;）<br>右值引用只能绑定到右值（临时对象、字面量、std::move 转换后的对象）。<br>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp;&amp; rref = <span class="built_in">MyArray</span>(<span class="number">100</span>);  <span class="comment">// 绑定到临时对象（右值）</span></span><br></pre></td></tr></table></figure><p>（2）移动构造函数和移动赋值运算符</p><ul><li>移动构造函数：接受右值引用参数，直接转移资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyArray</span>(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">    : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">    other.size_ = <span class="number">0</span>;        <span class="comment">// 原对象置空</span></span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;   <span class="comment">// 防止原对象析构时释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动赋值运算符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyArray&amp; <span class="keyword">operator</span>=(MyArray&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;      <span class="comment">// 释放当前资源</span></span><br><span class="line">        data_ = other.data_; <span class="comment">// 窃取资源</span></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么何时会触发移动语义？</p><p>场景 1：传递临时对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">createArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">arr</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> arr;  <span class="comment">// 返回时，arr 是右值，触发移动构造函数（而非拷贝）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray a = <span class="built_in">createArray</span>();  <span class="comment">// 移动构造</span></span><br></pre></td></tr></table></figure><p>场景 2：显式使用 std::move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);  <span class="comment">// 将左值 a 转为右值，触发移动构造</span></span><br><span class="line"><span class="comment">// 此时 a.data_ = nullptr，a 不可再使用！</span></span><br></pre></td></tr></table></figure><p>场景 3：标准库优化（如 vector::push_back）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;MyArray&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">MyArray</span>(<span class="number">1000</span>));  <span class="comment">// 传递右值，触发移动构造</span></span><br></pre></td></tr></table></figure><ol start="2"><li>完美转发（Perfect Forwarding）</li></ol><p>结合 std::forward 保持参数的值类别（左值/右值），是 C++ 中实现完美转发的核心机制，用于泛型编程。</p><p>假设你写了一个泛型包装函数 wrapper，它需要将参数传递给另一个函数 process：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);   <span class="comment">// 直接传递arg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里有一个问题：无论 arg 原始是左值还是右值，在 wrapper 内部，arg 始终是左值（因为它有名字，可以取地址）。因此，process 永远只能收到左值，无法触发右值重载的优化（如移动语义）。</p><p>使用std::forward可以解决这个问题。std::forward的作用是根据模板参数 T 的类型，有条件地将参数转换为左值或右值。修改后的 wrapper：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持 arg 的原始值类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时：</p><ul><li>如果 arg 原始是左值，std::forward<T> 返回左值引用。</li><li>如果 arg 原始是右值，std::forward<T> 返回右值引用，从而允许移动语义。</li></ul><p>举个栗子：</p><p>定义两个 process 重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理左值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理右值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况 1：不使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg);  <span class="comment">// arg 始终是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bad_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">bad_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理左值: 20 （但 20 是右值！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论传入左值还是右值，arg 在 bad_wrapper 内部都是左值，导致右值无法触发移动优化。</p><p>情况 2：使用 std::forward</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保持原始值类别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">good_wrapper</span>(a);        <span class="comment">// 输出：处理左值: 10</span></span><br><span class="line">    <span class="built_in">good_wrapper</span>(<span class="number">20</span>);       <span class="comment">// 输出：处理右值: 20 （正确触发右值重载！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 std::forward 根据传入参数的值类别，正确选择 process 的左值或右值版本。</p><p>那么 std::forward 是如何做到的呢？是靠引用折叠规则。</p><p>引用折叠规则<br>当模板参数 T 推导为左值或右值时，T&amp;&amp; 会触发引用折叠：</p><ul><li>如果 T 是 X&amp;（左值引用），T&amp;&amp; 折叠为 X&amp;（仍是左值引用）。</li><li>如果 T 是 X 或 X&amp;&amp;，T&amp;&amp; 变为 X&amp;&amp;（右值引用）。</li></ul><p>简化版的 std::forward 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 T 是左值引用（如 int&amp;），T&amp;&amp; 折叠为 int&amp;，返回左值引用。</li><li>如果 T 是普通类型（如 int），T&amp;&amp; 是 int&amp;&amp;，返回右值引用。</li></ul><ol start="3"><li>优化临时对象</li></ol><p>通过 std::move 将左值显式转换为右值引用，触发移动操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; v1;</span><br><span class="line">std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s));  <span class="comment">// 移动 s 的资源到 vector，s 变为空</span></span><br></pre></td></tr></table></figure><h1>注意事项</h1><ol><li>右值引用本身是左值<br>右值引用变量有名字，因此是左值。若需继续传递右值，需用 std::move</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 是左值（有名字），若需传递给其他函数，需转为右值</span></span><br><span class="line">    <span class="built_in">another_process</span>(std::<span class="built_in">move</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>避免滥用 std::move<br>对局部变量使用 std::move 可能导致意外悬空引用。</li></ol><p>移动后的对象处于有效但未定义状态（通常被置空）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyArray <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">MyArray b = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="comment">// a.data_ 变为 nullptr，不可再访问 a 的数据！</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>std::move 的本质<br>std::move 只是将对象强制转换为右值引用，本身不执行任何移动操作。真正的资源转移在移动构造函数或移动赋值运算符中完成。</p></li><li><p>异常安全<br>移动操作应标记为 noexcept，否则某些标准库操作（如 vector 扩容）可能回退到拷贝语义。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来复习总结一下左值引用与右值引用。&lt;/p&gt;
&lt;p&gt;左值引用和右值引用是 C++ 中用于管理对象生命周期的两种引用类型，主要区别在于它们绑定的对象类型和使用场景&lt;/p&gt;
&lt;h1&gt;左值引用（Lvalue Reference）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ol</summary>
      
    
    
    
    <category term="C/C++ 面试" scheme="http://malone-ai.github.io/categories/C-C-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C++" scheme="http://malone-ai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 里的 lower_bound 和 upper_bound</title>
    <link href="http://malone-ai.github.io/2025/03/04/chores1/"/>
    <id>http://malone-ai.github.io/2025/03/04/chores1/</id>
    <published>2025-03-04T15:20:21.000Z</published>
    <updated>2025-03-06T03:16:40.738Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++ 中，lower_bound 和 upper_bound 是标准库 <algorithm> 中提供的两个非常实用的函数，用于在已排序的序列中进行二分查找。它们的功能和用法非常相似，但在细节上有一些区别。</p><h1>使用条件</h1><p>由于 lower_bound 和 upper_bound 底层是基于二分查找的，故lower_bound 和 upper_bound 都要求输入的序列是已排序的（默认是升序）。</p><h1>lower_bound 的功能</h1><p>lower_bound 用于在已排序的序列中查找第一个大于或等于目标值的元素的位置。通俗地讲，就是在这个序列中为目标值找一个位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于或等于 value 的元素的迭代器。如果所有元素都小于 value，则返回 last。</li></ul><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt;= &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt;= 6 is 7 at index 3</code></pre><h1>upper_bound 的功能</h1><p>upper_bound 用于在已排序的序列中查找第一个大于目标值的元素的位置。</p><p>函数原型1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>函数原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>first 和 last：定义查找范围的迭代器，范围是 [first, last)。</li><li>value：要查找的目标值。</li><li>comp：comp 就是一个比较器，可以传仿函数对象，也可以传函数指针，类似于qsort里的cmp。</li><li>返回值：指向第一个大于 value 的元素的迭代器。如果所有元素都小于或等于 value，则返回 last。</li></ul><p>参数与lower_bound相同，返回值就不同了。</p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; (it - nums.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element &gt; &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为：</p><pre><code>First element &gt; 6 is 7 at index 3</code></pre><h1>lower_bound 和 upper_bound 的区别</h1><table><thead><tr><th>特性</th><th><code>lower_bound</code></th><th><code>upper_bound</code></th></tr></thead><tbody><tr><td><strong>查找条件</strong></td><td>第一个 <strong>大于或等于</strong> 目标值的元素</td><td>第一个 <strong>大于</strong> 目标值的元素</td></tr><tr><td><strong>返回值</strong></td><td>指向第一个满足条件的元素的迭代器</td><td>指向第一个满足条件的元素的迭代器</td></tr><tr><td><strong>目标值存在时</strong></td><td>返回目标值的第一个位置</td><td>返回目标值的下一个位置</td></tr><tr><td><strong>目标值不存在时</strong></td><td>返回第一个大于目标值的位置</td><td>返回第一个大于目标值的位置</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 C++ 中，lower_bound 和 upper_bound 是标准库 &lt;algorithm&gt; 中提供的两个非常实用的函数，用于在已排序的序列中进行二分查找。它们的功能和用法非常相似，但在细节上有一些区别。&lt;/p&gt;
&lt;h1&gt;使用条件&lt;/h1&gt;
&lt;p&gt;由于 lower_</summary>
      
    
    
    
    <category term="C/C++ 那些事儿" scheme="http://malone-ai.github.io/categories/C-C-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划六：最长递增子序列</title>
    <link href="http://malone-ai.github.io/2025/03/04/dp6/"/>
    <id>http://malone-ai.github.io/2025/03/04/dp6/</id>
    <published>2025-03-04T12:08:05.000Z</published>
    <updated>2025-03-05T15:37:14.044Z</updated>
    
    <content type="html"><![CDATA[<p>今日学习灵茶山艾府出品的<a href="https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">最长递增子序列【基础算法精讲 20】</a>。</p><p>UP通过Leetcode官方题<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列</a>进行讲解。</p><h1>300. 最长递增子序列</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p><code>子序列</code>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><h1>基本思路</h1><p>由于子序列是数组的一个子集，因此用子集型回溯来思考，也就是[选或不选]或者[枚举选哪个]。</p><p>对于nums = [1, 6, 7, 2, 4, 5, 3]：</p><ul><li>如果我们倒着思考，假设3是严格递增子序列中的最后一个数，考虑选或不选，需要与前面的数字进行比较，需要知道当前数的下标以及上一个数的下标。</li><li>如果考虑枚举选哪个，可以直接枚举3前面比3小的数字，当作严格递增子序列的倒数第二个数，只需要知道当前数字的下标即可。</li></ul><p>经过对比，枚举选哪个的思路只需要一个参数，更方便。</p><p>因此最终的思路为：<br>- 枚举以nums[i]结尾的严格递增子序列的长度<br>- 接着需要枚举以nums[j]为倒数第二个元素的严格递增子序列的长度<br>- 其中j &lt; i，nums[j] &lt; nums[i]</p><p>以下是灵茶山艾府总结的回溯三问：</p><ul><li>子问题？以nums[i]结尾的严格递增子序列的长度</li><li>当前操作？枚举nums[j]</li><li>下一个子问题？以nums[j]结尾的严格递增子序列的长度</li></ul><p>定义dfs(i)为以nums[i]结尾的严格递增子序列的长度，枚举满足要求的nums[j]，子问题就变成了以nums[j]结尾的严格递增子序列的长度，这些子问题求个最大值再+1，就得到了以nums[i]结尾的严格递增子序列的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i) = max&#123;dfs(j)&#125; + 1， j &lt; i &amp;&amp; nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure><h1>递归</h1><p>递归实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// dfs(i)表示以nums[i]结尾的严格递增子序列的长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(j), res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ++res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，一定要将i = 0 ~ n - 1当参数传给dfs，也就是最后的循环里挨个调用。如果直接dfs(n-1)的话，只有当j &lt; i &amp;&amp; nums[j] &lt; nums[i]的时候才能递归到其他状态，可能会导致0~n-2中的某些递归不到。并且dfs(n-1)的意义是以nums[n-1]结尾的严格递增子序列的长度，但是最长的严格递增子序列并不一定以nums[n-1]结尾，也可能是以前面的某个数字结尾。</p><h1>递推</h1><p>递归很容易翻译成递推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++f[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>贪心 + 二分</h1><p>这一块开始听不懂了，主要感觉灵茶山艾府的证明不是很清晰。</p><p>通过贪心 + 二分查找求解<code>最长严格递增子序列（LIS）</code>问题的核心思想是：<code>尽可能地让递增子序列的末尾元素更小，从而为后续的元素提供更多的扩展机会</code>。</p><h2 id="贪心思想">贪心思想</h2><p>贪心算法的核心是：在每一步选择中，都采取当前最优的策略，从而希望最终得到全局最优解。</p><p>在这个问题中，我们希望找到一个尽可能长的递增子序列。为了达到这个目标，我们需要让子序列的末尾元素尽可能小，因为较小的末尾元素更容易被后续的元素扩展。</p><p>因此，贪心策略是<code>对于相同长度的递增子序列，我们只保留末尾元素最小的那个</code>。</p><p>g[i] 表示长度为 i+1 的递增子序列的最小末尾元素</p><h2 id="二分查找的作用">二分查找的作用</h2><p>对于每个新元素 num，我们需要找到它在 g 中的位置：</p><ul><li>如果 num 比 g 中的所有元素都大，说明它可以扩展当前的最长递增子序列，因此将其添加到 g 的末尾。</li><li>否则，找到 g 中第一个大于等于 num 的位置 pos，并用 num 替换 g[pos]。这是因为 num 可以作为一个更小的末尾元素来构成长度为 pos+1 的递增子序列。</li></ul><p>通过二分查找，我们可以在 O(log n) 的时间内找到 num 应该插入或替换的位置，从而保证算法的高效性。</p><h2 id="为什么贪心-二分查找是正确的？">为什么贪心 + 二分查找是正确的？</h2><p>我们需要证明：通过贪心策略维护的数组 g，最终的长度就是最长递增子序列的长度。</p><p>关键点：</p><ol><li><p>g 的长度就是 LIS 的长度：</p><ul><li>每次向 g 中添加一个新元素时，都意味着我们发现了一个更长的递增子序列。</li><li>每次替换 g 中的元素时，只是优化了相同长度的递增子序列的末尾元素，而不会改变 g 的长度。</li></ul></li><li><p>g 的严格递增性：</p><ul><li>由于我们总是用更小的元素替换 g 中的元素，g 始终保持严格递增。</li><li>这种性质保证了我们可以通过二分查找快速定位 num 应该插入或替换的位置。</li></ul></li><li><p>替换操作不会影响最终结果：</p><ul><li>当我们用 num 替换 g[pos] 时，虽然我们改变了长度为 pos+1 的递增子序列的末尾元素，但这并不影响更长递增子序列的构建。</li><li>因为 num 比原来的 g[pos] 更小，它为后续的元素提供了更多的扩展机会。</li></ul></li></ol><h2 id="一个例子">一个例子</h2><p>假设 nums = [10, 9, 2, 5, 3, 7, 101, 18]，我们通过贪心 + 二分查找来求解：</p><ul><li>初始化 g = []。</li><li>遍历 nums：<ol><li>num = 10：<ul><li>g 为空，直接添加：g = [10]。</li></ul></li><li>num = 9：<ul><li>找到第一个大于等于 9 的位置是 0，替换：g = [9]。</li></ul></li><li>num = 2：<ul><li>找到第一个大于等于 2 的位置是 0，替换：g = [2]。</li></ul></li><li>num = 5：<ul><li>5 比 g 中的所有元素都大，添加到末尾：g = [2, 5]。</li></ul></li><li>num = 3：<ul><li>找到第一个大于等于 3 的位置是 1，替换：g = [2, 3]。</li></ul></li><li>num = 7：<ul><li>7 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7]。</li></ul></li><li>num = 101：<ul><li>101 比 g 中的所有元素都大，添加到末尾：g = [2, 3, 7, 101]。</li></ul></li><li>num = 18：<ul><li>找到第一个大于等于 18 的位置是 3，替换：g = [2, 3, 7, 18]。</li></ul></li></ol></li></ul><p>最终，g 的长度是 4，因此最长递增子序列的长度是 4。</p><p>这种方法的时间复杂度是 O(n log n)，空间复杂度是 O(n)，是一种非常高效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心 + 二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;num: nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), num);</span><br><span class="line">            <span class="keyword">if</span> (it == g.<span class="built_in">end</span>())</span><br><span class="line">                g.<span class="built_in">emplace_back</span>(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>变形</h1><p>如果允许最长递增子序列中有重复元素，那么按照<code>贪心+二分</code>的思路，在g中需要寻找的就是第一个大于（原来是大于等于）num的位置，也就是把原来使用的lower_bound改成upper_bound即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日学习灵茶山艾府出品的&lt;a href=&quot;https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.1387.collection.video_card.click&amp;amp;vd_source=a0f19e79</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 集成Element-Plus</title>
    <link href="http://malone-ai.github.io/2025/03/04/project-test2/"/>
    <id>http://malone-ai.github.io/2025/03/04/project-test2/</id>
    <published>2025-03-04T08:29:23.000Z</published>
    <updated>2025-03-04T10:24:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV1GLKweAEHj/?spm_id_from=333.1245.0.0">【带小白做毕设】02. 使用Vue3集成Element-Plus快速搭建一个管理系统的页面</a>并进行一个学习记录。</p><h1>Element-Plus</h1><p>Element-Plus 是一套前端 UI 框架，提供了许多精美的样式，Ctrl-C + Ctrl-V即可使用。<a href="https://element-plus.org/zh-CN/">官网跳转</a>。</p><p>使用以下命令安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-plus -S</span><br></pre></td></tr></table></figure><p>在main.js中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/css/global.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span> <span class="comment">// 这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>) <span class="comment">// 这一行</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后直接从官网找到以下代码粘贴到Home.vue体验：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    主页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span>&gt;</span>Info<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span>&gt;</span>Warning<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span>&gt;</span>Danger<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1>使用 icon</h1><p>首先安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @element-plus/icons-vue</span><br></pre></td></tr></table></figure><p>然后需要从 @element-plus/icons-vue 中导入所有图标并进行全局注册：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您正在使用CDN引入，请删除下面一行。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ElementPlusIconsVue</span> <span class="keyword">from</span> <span class="string">&#x27;@element-plus/icons-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, component] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="title class_">ElementPlusIconsVue</span>)) &#123;</span><br><span class="line">  app.<span class="title function_">component</span>(key, component)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环部分放在main.js的末尾即可。</p><p>然后就可以从官网复制一个icon放到Home.vue中即可使用icon了。</p><p>使用图标:</p><ul><li>el-input：当你在输入框组件里面使用图标，你需要单独导入图标</li><li>el-icon、el-button：按钮或者图标组件里面，不需要单独导入图标</li></ul><h1>Element-Plus 主题色设置</h1><p>安装依赖 sass、unplugin-vue-components、unplugin-auto-import</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D sass unplugin-vue-components unplugin-auto-import</span><br></pre></td></tr></table></figure><p>配置index.scss放在 src/assets/css 目录下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@forward <span class="string">&quot;element-plus/theme-chalk/src/common/var.scss&quot;</span> <span class="title function_">with</span>(</span><br><span class="line">    <span class="attr">$colors</span>:(</span><br><span class="line">            <span class="string">&quot;primary&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #2c82ff),</span><br><span class="line">            <span class="string">&quot;success&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #31bf00),</span><br><span class="line">            <span class="string">&quot;warning&quot;</span>:  (<span class="string">&quot;base&quot;</span>:  #ffade0),</span><br><span class="line">            <span class="string">&quot;danger&quot;</span>:   (<span class="string">&quot;base&quot;</span>:  #e52f2f), </span><br><span class="line">            <span class="string">&quot;info&quot;</span>:     (<span class="string">&quot;base&quot;</span>: #8855ff),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置vite.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span><span class="string">&#x27;unplugin-auto-import/vite&#x27;</span><span class="comment">//自动导入vue中的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span><span class="comment">//自动导入ui-组件 比如 element-plus等</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span><span class="comment">//对应组件引入</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line"><span class="comment">//element-plus按简导入</span></span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [</span><br><span class="line">            <span class="comment">//配置elementPlus采用sass样式配置系统</span></span><br><span class="line">            <span class="title class_">ElementPlusResolver</span>(&#123;<span class="attr">importStyle</span>:<span class="string">&quot;sass&quot;</span>&#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="attr">css</span>:&#123;</span><br><span class="line">  <span class="attr">preprocessorOptions</span>:&#123;</span><br><span class="line">    <span class="attr">scss</span>: &#123;</span><br><span class="line">      <span class="attr">additionalData</span>: <span class="string">`@use&quot;@/assets/css/index.scss&quot; as *;`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1>创建后台基本框架</h1><p>创建vue/src/views/Manager.vue文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV1GLKweAEHj/?spm_id_from=333.1245.0.0&quot;&gt;【带小白做毕设】02. 使用Vue3集成Element-Plus快速搭建一个管理</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端" scheme="http://malone-ai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="http://malone-ai.github.io/tags/Vue/"/>
    
    <category term="Element-Plus" scheme="http://malone-ai.github.io/tags/Element-Plus/"/>
    
  </entry>
  
  <entry>
    <title>前端 Vue3 框架搭建</title>
    <link href="http://malone-ai.github.io/2025/03/04/project-test1/"/>
    <id>http://malone-ai.github.io/2025/03/04/project-test1/</id>
    <published>2025-03-04T02:56:11.000Z</published>
    <updated>2025-03-12T04:39:04.404Z</updated>
    
    <content type="html"><![CDATA[<p>学习B站UP主程序员青戈出品的视频<a href="https://www.bilibili.com/video/BV16dKHeiE92?spm_id_from=333.788.videopod.sections&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">【带小白做毕设】01. 前端Vue3 框架的快速搭建以及项目工程的讲解</a>并进行一个学习记录。</p><h1>安装NodeJS</h1><p>vue3 建议 nodejs v22.14.0，npm 版本 10.9.2<br>使用安装包安装nodejs时，会自动配置Node和npm的环境变量。<br>npm要配置淘宝镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h1>搭建Vue工程</h1><p>创建一个工程目录（我就叫它Project吧），在工程目录下打开CMD，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure><p>然后会让你输入项目名称，我起名为vue。</p><p>紧接着会让你选择<br>√ 是否使用 TypeScript 语法？ 选否<br>√ 是否启用 JSX 支持？ 选否<br>√ 是否引入 Vue Router 进行单页面应用开发？ 选是<br>√ 是否引入 Pinia 用于状态管理？ 选否<br>√ 是否引入 Vitest 用于单元测试？ 选否<br>√ 是否要引入一款端到端（End to End）测试工具？ » 选不需要<br>√ 是否引入 ESLint 用于代码质量检测？ » 选否</p><p>也就是除了“是否引入 Vue Router 进行单页面应用开发？”选是以外，其余均选择否或者不需要。</p><p>然后会提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目初始化完成，可执行以下命令：</span><br><span class="line"></span><br><span class="line">  cd vue</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure><p>输入<code>cd vue</code>，进入vue的工程目录。</p><p>然后输入<code>npm install</code>安装依赖，并且会有类似提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">added 147 packages <span class="keyword">in</span> 20s</span><br><span class="line"></span><br><span class="line">43 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p>再输入<code>npm run dev</code>即可运行这个vue项目，会有提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VITE v6.2.0  ready <span class="keyword">in</span> 585 ms</span><br><span class="line"></span><br><span class="line">➜  Local:   http://localhost:5173/</span><br><span class="line">➜  Network: use --host to expose</span><br><span class="line">➜  Vue DevTools: Open http://localhost:5173/__devtools__/ as a separate window</span><br><span class="line">➜  Vue DevTools: Press Alt(⌥)+Shift(⇧)+D <span class="keyword">in</span> App to toggle the Vue DevTools</span><br><span class="line">➜  press h + enter to show <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>在浏览器中输入网址：<a href="http://localhost:5173/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E8%BF%99%E4%B8%AAvue%E9%A1%B9%E7%9B%AE%E3%80%82">http://localhost:5173/，即可查看这个vue项目。</a></p><h1>Vue 工程精简</h1><p>使用idea打开Project目录（也就是上面vue工程目录的上一级目录）。</p><p>目前工程目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─.idea</span><br><span class="line">└─vue</span><br><span class="line">    ├─.vscode</span><br><span class="line">    ├─node_modules</span><br><span class="line">    ├─public</span><br><span class="line">    ├─src</span><br><span class="line">    │   ├─assets</span><br><span class="line">    │   ├─components</span><br><span class="line">    │   │  └─icons</span><br><span class="line">    │   ├─router</span><br><span class="line">    │   └─views</span><br><span class="line">    ├─.gitignore</span><br><span class="line">    ├─index.html</span><br><span class="line">    ├─jsconfig.json</span><br><span class="line">    ├─package.json</span><br><span class="line">    ├─package-lock.json</span><br><span class="line">    ├─README.md</span><br><span class="line">    └─vite.config.js</span><br></pre></td></tr></table></figure><p>.vscode、.gitignore、README.md三个文件不需要，直接删除。</p><p>找到设置，输入enc，点击<code>File Encodings</code>，把global Encodings、Project Encodings、Default encoding for properties files全部设为<code>UTF-8</code>，并勾选Transparent native-to-ascii conversion。</p><p>还有一些文件也是不需要的，继续删除以下文件：</p><ul><li>vue/src/assets目录下的base.css、main.css</li><li>vue/src/components下的所有文件和文件夹</li><li>vue/src/views 目录下的AboutView.vue</li></ul><p>将vue/src/views/HomeView.vue的内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        主页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>并将HomeView.vue重命名为Home.vue</p><p>将vue/src/App.vue的内容编辑为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;RouterView /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>vue/src/router/index.js的内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vue/src/main.js的第一行有对vue/src/assets/main.css的导入，但是其已被我们删除，故将这一行删除。</p><h1>Vue 工程目录解读</h1><ul><li>node_modules：依赖包存放文件</li><li>public：存放全局静态文件</li><li>src：<ul><li>assets：存放代码引用的静态文件，css、js等</li><li>components：存放vue的组件（可复用代码块）</li><li>router：存放路由文件的目录</li><li>views：存放vue网页的目录</li><li>App.vue：vue页面全局入口</li><li>main.js：全局的配置文件，引入第三方的组件或者自定义的组件</li></ul></li><li>index.html：vue编译成的网页</li><li>package.json：定义依赖库的文件</li><li>package-lock.json：安装依赖时用于锁定版本的文件</li><li>vite.config.js：全局的配置文件</li></ul><h1>全局css</h1><p>在vue/src/assets目录下新建css目录，再在css目录下新建global.css文件（全局样式表），内容编辑为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    box-<span class="attr">sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    <span class="attr">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">color</span>: #<span class="number">333</span>;</span><br><span class="line">    font-<span class="attr">size</span>: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">    text-<span class="attr">decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在main.js文件中引用，添加这行代码即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/css/global.css&#x27;</span></span><br></pre></td></tr></table></figure><h1>定义404页面</h1><p>将一张404的图片放在vue/src/assets/imgs目录下，在vue/src/views目录下新建404.vue，编辑内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div style=&quot;height: 100vh; display: flex; align-items: center; justify-content: center&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;img style=&quot;width: 100%&quot; src=&quot;@/assets/imgs/404.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;div style=&quot;text-align: center; padding: 20px 0; font-size: 20px; color: #3741fb&quot;&gt;&lt;a href=&quot;/&quot;&gt;返回主页&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后定义路由，在vue/src/router/index.js文件中一行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),&#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/notFount&#x27;</span>, <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;../views/404.vue&#x27;</span>),&#125;, <span class="comment">// 添加的那行代码</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>此时访问 <a href="http://localhost:5174/notFount">http://localhost:5174/notFount</a> 就会跳转到404页面。但其实我们想实现的是只要访问一个未定义的路由就跳转404页面。</p><p>只需要再在index.js中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/notFound&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习B站UP主程序员青戈出品的视频&lt;a href=&quot;https://www.bilibili.com/video/BV16dKHeiE92?spm_id_from=333.788.videopod.sections&amp;amp;vd_source=a0f19e79b7da02f</summary>
      
    
    
    
    <category term="Java 项目" scheme="http://malone-ai.github.io/categories/Java-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端" scheme="http://malone-ai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="http://malone-ai.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>智能指针模板类：auto_ptr，shared_ptr，unique_ptr</title>
    <link href="http://malone-ai.github.io/2025/03/03/cpp-interview2/"/>
    <id>http://malone-ai.github.io/2025/03/03/cpp-interview2/</id>
    <published>2025-03-03T06:54:44.000Z</published>
    <updated>2025-03-10T08:11:02.680Z</updated>
    
    <content type="html"><![CDATA[<p>今日通过阅读《c++ Primer Plus》来学习一下智能指针。部分内容参考<a href="https://blog.csdn.net/weixin_45031801/article/details/140594215">【C++11】智能指针深度详解（什么是智能指针？为什么需要智能指针？如何使用智能指针？）</a>（CSDN博客链接，点击即可跳转）。</p><h1>What is it ?</h1><p><code>智能指针</code>这个名词听着挺唬人，其实也没啥，无非就是会自动销毁 new 出来的对象，避免内存泄漏。毕竟 C/C++ 没有类似<code>Java</code>的垃圾回收机制，需要手动释放 new 出来的对象，<code>智能指针</code>可以自动地完成这个工作。</p><h1>Why ? 为什么需要智能指针？</h1><p>先看这个函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string* ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的缺陷就是忘了释放new出来的内存，但是只要别忘了return前加上<code>delete ps</code>释放内存。</p><p>但是但凡是涉及<code>别忘了</code>的解决方法，往往不佳。即使没有忘记，依然可能出现问题，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string* ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现异常时，将不会执行delete ps，导致内存泄漏。</p><p>当remodel()这样的函数终止(不管是正常终止，还是由于出现了异常而终止)，本地变量都将从栈内存中删除，因此指针ps占据的内存将被释放。</p><p>如果ps指向的内存也被释放，就nice了。</p><p>如果ps有一个<code>析构函数</code>，该析构函数将在ps过期时释放它指向的内存。如果ps是对象，则可以在对象过期时，让它的析构函数删除指向的内存。这正是为什么出现<code>auto_ptr</code>、<code>unique_ptr</code>和<code>shared _ptr</code>的原因了。</p><h1>使用智能指针</h1><p>要创建智能指针对象，就得包含头文件memory。</p><p>模板auto_ptr的构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="explicit">explicit</h2><p><code>explicit</code>关键字用于<code>禁止隐式类型转换</code>。</p><ol><li><p>隐式转换是什么？<br>隐式转换是指编译器在不需要显式调用构造函数或转换函数的情况下，自动将一种类型转换为另一种类型。<br>例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 隐式调用 MyClass(10)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，func(10) 会自动调用 MyClass(int x) 构造函数，将 int 隐式转换为 MyClass 对象。</p></li><li><p>隐式转换在<code>auto_ptr</code>中的问题<br>假设 auto_ptr 的构造函数没有 explicit：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(X* p = <span class="number">0</span>) <span class="keyword">throw</span>() : <span class="built_in">ptr</span>(p) &#123;&#125; <span class="comment">// 没有 explicit</span></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">X* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    X* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// 隐式调用构造函数</span></span><br></pre></td></tr></table></figure><ul><li>发生了什么？<ol><li>new int(5) 返回一个 int* 类型的指针。</li><li>由于 auto_ptr 的构造函数没有 explicit，编译器会自动调用 auto_ptr<int>(int*) 构造函数，将 int* 隐式转换为 auto_ptr<int>。</li><li>最终，ap 是一个 auto_ptr<int> 对象，接管了 new int(5) 返回的指针。</li></ol></li></ul><ol start="3"><li><p>为什么隐式转换会导致问题？<br>隐式转换可能导致以下问题：<br>(1) 意外的所有权转移<br>auto_ptr 的核心特性是<code>独占所有权</code>，即一个 auto_ptr 对象独占一个资源，不能有多个 auto_ptr 对象同时管理同一个资源。</p><p>如果允许隐式转换，以下代码会导致意外的所有权转移：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// ap1 接管指针</span></span><br><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; ap2 = ap1;         <span class="comment">// ap1 的所有权转移到 ap2</span></span><br></pre></td></tr></table></figure><ul><li>在第二行，ap1 的所有权被转移到 ap2，ap1 变为空指针。</li><li>如果后续代码继续使用 ap1，会导致未定义行为（如访问空指针）。</li></ul></li></ol><p>(2) 资源管理问题<br>隐式转换可能导致资源泄漏或重复释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(auto_ptr&lt;<span class="type">int</span>&gt; ap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* raw_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(raw_ptr);  <span class="comment">// 隐式转换，raw_ptr 的所有权被转移</span></span><br><span class="line">    <span class="comment">// 此时 raw_ptr 已被释放，后续访问会导致未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>func(raw_ptr) 隐式调用了 auto_ptr<int>(int*) 构造函数，raw_ptr 的所有权被转移到 func 的参数 ap。</li><li>当 func 返回时，ap 被销毁，raw_ptr 指向的内存被释放。</li><li>如果后续代码继续使用 raw_ptr，会导致未定义行为。</li></ul><p>因此，通过将构造函数声明为 explicit，可以禁止隐式转换，强制要求显式调用构造函数。</p><h2 id="noexcept">noexcept</h2><p><code>noexcept</code>表示auto_ptr类的构造函数保证不会抛出任何异常。<br>如果函数声明了 noexcept 但实际上抛出了异常，程序会调用 std::unexpected()，通常导致程序终止。</p><h2 id="使用智能指针">使用智能指针</h2><p>继续回过头看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后申请X类型的auto_ptr将获得一个指向X类型的auto_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>; <span class="comment">// pd是一个指向double类型的auto_ptr</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string)</span></span>; <span class="comment">// ps是一个指向string的auto_ptr</span></span><br></pre></td></tr></table></figure><p>new double 是new 返回的指针，指向new出来的内存块。new double 是构造函数auto_ptr<double>的参数，对应于原型中形参p的实参。同样，new string也是构造函数的实参。其他两种智能指针的使用也是同样的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">double</span>&gt; <span class="title">pdu</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>; <span class="comment">// pd 是一个指向double的unique_ptr</span></span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">pss</span><span class="params">(<span class="keyword">new</span> string)</span></span>; <span class="comment">// pd 是一个指向string的shared_ptr</span></span><br></pre></td></tr></table></figure><p>要改造先前的remodel()函数，需要包含memory头文件、将指向string的指针改为指向string的智能指针、删除delete语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::string* ps = new std::string(str);</span></span><br><span class="line">    <span class="function">std::auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> std::string(str))</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="comment">// delete ps;</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于所有的智能指针类的构造函数都有<code>explicit</code>关键字修饰，该构造函数将指针作为参数，并且要显式地调用构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pd;</span><br><span class="line"><span class="type">double</span> *p_reg = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">pd = p_reg; <span class="comment">// 错误，使用了隐式转换</span></span><br><span class="line">pd = <span class="built_in">shared_ptr</span>&lt;<span class="type">double</span>&gt;(p_reg); <span class="comment">// 正确，显示转换</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pshared = p_reg; <span class="comment">// 错误，使用了隐式转换</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">double</span>&gt; <span class="title">pshared</span><span class="params">(p_reg)</span></span>;  <span class="comment">// 正确，显示转换</span></span><br></pre></td></tr></table></figure><p>此外，三类智能指针都应该避免一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vacation</span><span class="params">(<span class="string">&quot;I wandered lonely as a cloud.&quot;</span>&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">shared_ptr&lt;string&gt; pvac(&amp;vacation);</span></span></span><br></pre></td></tr></table></figure><p>pvac的生命周期结束时，自动释放其指向的内存，这回导致delete一个不是new出来的内存。</p><p>对于auto_ptr，对于以下赋值语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; vocation;</span><br><span class="line">vocation = ps;</span><br></pre></td></tr></table></figure><p>它有明显的bug，因为ps和vocation的生命周期结束时，ps的析构函数会将这块new出来的内存释放一次，vocation的析构函数又会再释放一次。</p><p>可以采用以下方法解决：</p><ul><li>重载赋值运算符，使用深拷贝</li><li>建立所有权的概念，对于特定的对象，只允许一个智能指针可以拥有它。这样只有拥有该对象的智能指针的析构函数会删除该对象。auto_ptr和unique_ptr采用此策略</li><li>创建更智能的指针，跟踪引用特定对象的智能指针的个数（称为引用计数）。例如，赋值时，计数将+1，而指针的生命周期结束时，计数-1。只有当最后一个指针的生命周期也结束时，才delete。shared_ptr采用此策略。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日通过阅读《c++ Primer Plus》来学习一下智能指针。部分内容参考&lt;a href=&quot;https://blog.csdn.net/weixin_45031801/article/details/140594215&quot;&gt;【C++11】智能指针深度详解（什么是智能指针？</summary>
      
    
    
    
    <category term="C/C++ 面试" scheme="http://malone-ai.github.io/categories/C-C-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C/C++" scheme="http://malone-ai.github.io/tags/C-C/"/>
    
    <category term="智能指针" scheme="http://malone-ai.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>动态规划五：线性DP</title>
    <link href="http://malone-ai.github.io/2025/03/02/dp5/"/>
    <id>http://malone-ai.github.io/2025/03/02/dp5/</id>
    <published>2025-03-02T14:15:51.000Z</published>
    <updated>2025-03-10T02:10:30.975Z</updated>
    
    <content type="html"><![CDATA[<p>今日继续学习灵茶山艾府的基础算法精讲系列中的<a href="https://www.bilibili.com/video/BV1TM4y1o7ug/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=a0f19e79b7da02f4fa318d91be5bc86a">最长公共子序列 编辑距离【基础算法精讲 19】</a>（本文内容参考该视频，点击即可跳转视频，非商业引用，侵权联系删）。</p><p>灵茶山艾府主要通过两道Leetcode题进行讲解：<a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a>和<a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离</a>。</p><h1>1143. 最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长<code>公共子序列</code>的长度。如果不存在<code>公共子序列</code>，返回 0 。</p><p>一个字符串的<code>子序列</code>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li></ul><p>两个字符串的<code>公共子序列</code>是这两个字符串所共同拥有的子序列。</p><p>公共子序列就是两个字符串都有的子序列，我们需要计算所有公共子序列中的最长长度。</p><p>把两个字符串分别设为s和t，长度设为n和m，和背包问题一样，子序列也是考虑每个字符<code>选或不选</code>，从最后一个字母开始考虑，s的最后一个字母设为x，t的最后一个字母设为y，分为四种情况：</p><ul><li>不选x，不选y</li><li>不选x，选y</li><li>选x，不选y</li><li>选x，选y</li></ul><p>上述是灵茶山艾府给出的启发思路，再来看看他总结的回溯三问：</p><ul><li>当前操作？考虑s[i]和t[j]选或不选</li><li>子问题？s的前i个字母和t的前j个字母的LCS长度</li><li>下一个子问题？<ul><li>s的前i-1个字母和t的前j-1个字母的LCS长度</li><li>s的前i-1个字母和t的前j个字母的LCS长度</li><li>s的前i个字母和t的前j-1个字母的LCS长度</li></ul></li></ul><p>这样可以确定递归参数中的i和j表示的子问题，就是s的前i个字母和t的前j个字母的LCS长度。</p><p>另外注意，都选和都不选两种情况的下一个子问题是一样的，并且只有s[i] == t[j]的时候才能都选。</p><p>可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">    <span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] != t[j])</span><br><span class="line">    <span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>));</span><br></pre></td></tr></table></figure><p>可以简化成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>)) + (s[i] == t[j]);</span><br></pre></td></tr></table></figure><p>然后灵茶山艾府提出了两个问题：</p><ol><li>在s[i] == t[j]的时候，我们需要考虑只选其中一个的情况吗？</li><li>在s[i] != t[j]的时候，我们需要考虑都不选的情况吗？</li></ol><p>答案是都不需要。灵茶山艾府对这一块的讲解有点没听明白，谈谈自己的理解。</p><p>对于问题<code>在s[i] == t[j]的时候，我们需要考虑只选其中一个的情况吗？</code>，我认为反证法更好理解。</p><p>假设在 s[i] == t[j] 时，我们不将这两个字符加入 LCS 中，而是选择忽略其中一个。那么：</p><ul><li>如果忽略s[i]，那么 LCS 的长度最多是 dfs(i-1, j)。</li><li>如果忽略t[j]，那么 LCS 的长度最多是 dfs(i, j-1)。</li></ul><p>然而，如果我们选择将 s[i] 和 t[j] 加入 LCS 中，那么 LCS 的长度是 dfs(i-1, j-1) + 1。由于 dfs(i-1, j-1) + 1 一定大于或等于 dfs(i-1, j) 或 dfs(i, j-1)，因此选择匹配这两个字符一定不会使结果变差，反而可能使结果更好。</p><p>因此s[i] === t[j]时，我们只需要考虑都选的情况就可以了。</p><p>对于问题<code>在s[i] != t[j]的时候，我们需要考虑都不选的情况吗？</code></p><p>如果 s 的第 i 个字符和 t 的第 j 个字符不相等，此时，我们需要考虑两种情况：</p><ul><li>忽略 s[i]，即只考虑 s 的前 i-1 个字符和 t 的前 j 个字符的 LCS。</li><li>忽略 t[j]，即只考虑 s 的前 i 个字符和 t 的前 j-1 个字符的 LCS。</li></ul><p>然后，我们取这两种情况的最大值。</p><ul><li>为什么不需要考虑“都不选”的情况？<br>因为“都不选”的情况已经被包含在上述两种情况中了。如果我们既不选 s[i] 也不选 t[j]，那么这种情况等价于 dfs(i-1, j-1)。而在 s[i] != t[j] 时，dfs(i-1, j-1)的值一定小于或等于 dfs(i-1, j) 或 dfs(i, j-1)，所以不需要单独考虑。</li></ul><h2 id="递归解法">递归解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// dfs(i, j)表示s[0...i-1]和t[0...j-1]的LCS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>, j), <span class="built_in">dfs</span>(i, j<span class="number">-1</span>)), <span class="built_in">dfs</span>(i<span class="number">-1</span>, j<span class="number">-1</span>) + (s[i] == t[j]));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(nm)，空间复杂度也为O(nm)。</p><h2 id="递推">递推</h2><p>能否继续优化空间复杂度？Of course！</p><p>先改为递推（空间复杂度仍为O(nm)）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[i<span class="number">+1</span>][j], f[i][j<span class="number">+1</span>]), f[i][j] + (s[i] == t[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两个数组">两个数组</h3><p>很容易优化成以下空间复杂度为O(m)的形式（使用两个数组）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[(i<span class="number">+1</span>) % <span class="number">2</span>][j], f[i % <span class="number">2</span>][j<span class="number">+1</span>]), f[i % <span class="number">2</span>][j] + (s[i] == t[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一个数组">一个数组</h3><p>画个图很容易发现，当前状态由左边、上边以及左上三个状态转移而来，当前状态还需要参与右边状态的转移，此时存在覆盖问题，因此用一个pre临时存储一下当前状态转移之前的值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pre = f[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = f[j<span class="number">+1</span>];</span><br><span class="line">                f[j<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(f[j], f[j<span class="number">+1</span>]), pre + (s[i] == t[j]));</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>72. 编辑距离</h1><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。<br>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>依然记它们分别为s和t，基于上述三种操作把s改成t。</p><p>分析方法和上一题类似。</p><p><code>删除</code>一个字母相当于去掉s[i]。</p><p><code>插入</code>一个字母的话，由于需要保持和t[j]一样，那s插入一个字母相当于去掉t[j]。</p><p>如果s[i] == t[j]，那么就都去掉，此时不执行任何操作。</p><p>如果s[i] != t[j]则可以通过<code>替换</code>操作，比如说对于s=&quot;horse&quot;和t=&quot;ros&quot;的最后一个字母都不同，那么把s的最后一个字母替换成’s’，然后把s和t的最后一个字母都去掉即可。</p><ul><li>如果s[i] == t[j]，那么就都去掉，此时不执行任何操作。</li><li>如果s[i] != t[j]，那么可以执行的操作由删除、插入和替换。</li></ul><p>可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, j), <span class="built_in">dfs</span>(i, j - <span class="number">1</span>)), <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中s[i] != t[j]的时候dfs(i - 1, j)相当于<code>删除</code>操作，dfs(i, j - 1)相当于<code>插入</code>操作，dfs(i - 1, j - 1) + 1相当于替换操作。</p><p>还有一些边界条件就是i &lt; 0或者 j &lt; 0 需要处理。</p><ul><li>i &lt; 0<ul><li>s为空t不为空，需要在s中插入和t相等长度的字符</li><li>故返回 j + 1</li></ul></li><li>j &lt; 0<ul><li>s不为空t为空，需要把s中字母全部删除，删除长度为t的长度</li><li>return i + 1;</li></ul></li></ul><h2 id="递归">递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j + <span class="number">1</span>; <span class="comment">// s为空t不为空，需要在s中插入和t相等长度的字符</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// s不为空t为空，需要把s中字母全部删除，删除长度为t的长度</span></span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][j];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">                <span class="keyword">return</span> res = <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, j), <span class="built_in">dfs</span>(i, j - <span class="number">1</span>)), <span class="built_in">dfs</span>(i - <span class="number">1</span>, j - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递推-2">递推</h2><p>递归很容易翻译成递推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[<span class="number">0</span>][j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i<span class="number">+1</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[i<span class="number">+1</span>][j<span class="number">+1</span>] = f[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i<span class="number">+1</span>][j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i][j<span class="number">+1</span>], f[i<span class="number">+1</span>][j]), f[i][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递推解法-空间复杂度O-m-两个数组">递推解法 空间复杂度O(m) 两个数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[<span class="number">0</span>][j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[(i<span class="number">+1</span>) % <span class="number">2</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = f[i % <span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[(i<span class="number">+1</span>) % <span class="number">2</span>][j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i % <span class="number">2</span>][j<span class="number">+1</span>], f[(i<span class="number">+1</span>) % <span class="number">2</span>][j]), f[i % <span class="number">2</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递推解法-空间复杂度O-m-一个数组：">递推解法 空间复杂度O(m) 一个数组：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) </span><br><span class="line">            f[j<span class="number">+1</span>] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pre = f[<span class="number">0</span>];</span><br><span class="line">            f[<span class="number">0</span>] = i<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = f[j<span class="number">+1</span>];</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) </span><br><span class="line">                    f[j<span class="number">+1</span>] = pre;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[j<span class="number">+1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[j<span class="number">+1</span>], f[j]), pre) + <span class="number">1</span>;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日继续学习灵茶山艾府的基础算法精讲系列中的&lt;a href=&quot;https://www.bilibili.com/video/BV1TM4y1o7ug/?spm_id_from=333.1007.top_right_bar_window_history.content.cli</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划四：完全背包</title>
    <link href="http://malone-ai.github.io/2025/03/02/dp4/"/>
    <id>http://malone-ai.github.io/2025/03/02/dp4/</id>
    <published>2025-03-02T13:21:30.000Z</published>
    <updated>2025-03-10T02:05:58.929Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今日继续学习B站Up主出品的基础算法精讲系列，<a href="https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a">0-1背包 完全背包【基础算法精讲 18】</a>（点击即可跳转视频链接）。</p><p>0-1背包和完全背包是非常重要的DP模型，灵茶山艾府认为一定程度上它们就是“选或不选”思想的代表。</p><p>本片博客主要关注完全背包。</p><h1>1. 完全背包</h1><h2 id="1-1-问题描述">1.1 问题描述</h2><p><code>完全背包</code>：有n种物品，第i种物品的体积为 w[i]，价值为 v[i]，每种物品<code>无限次重复选</code>，求体积和不超过 capacity时的最大价值和。</p><p>递归做法的回溯三问为：</p><ul><li>当前操作?枚举<code>第</code>i种物品选一个或不选:<ul><li>不选，剩余容量不变;</li><li>选一个，剩余容量减少 w[i]</li></ul></li><li>子问题?在剩余容量为c时，从<code>前</code>i种物品中得到的最大价值和</li><li>下一个子问题?分类讨论：<ul><li>不选：在剩余容量为c时，从<code>前</code>i-1 种物品中得到的最大价值和:</li><li>选一个，在剩余容量为c-w[i]时，从<code>前</code>i种物品中得到的最大价值和</li></ul></li></ul><p>这里和0-1背包的回溯<code>区别</code>为，在选了一个物品之后，i是不变的，表示可以继续选第i中物品。因此不是递归到i-1，而是递归到i。</p><p>很容易得到其实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">unbounded_knapsack</span><span class="params">(<span class="type">int</span> c, vector&lt;<span class="type">int</span>&gt;&amp; w, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i, c), <span class="built_in">dfs</span>(i, c-w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2. 零钱兑换</h1><p>看一道Leetcode题<a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a>。</p><h2 id="2-1-问题描述">2.1 问题描述</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的<code>最少的硬币个数</code>。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><h2 id="2-2-基本思路">2.2 基本思路</h2><p>背包问题的常见变形：</p><ol><li>至多装capacity，求方案数/最大价值和</li><li>恰好装capacity，求方案数/最大/最小价值和</li><li>至少装capacity，求方案数/最小价值和</li></ol><p>这道Leetcode题也是完全背包的一种变形，把物品价值看成是1，把求最大改成求最小，可以得到状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(i, c) = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, c), <span class="built_in">dfs</span>(i, c - w[i]) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>dfs(i, c)表示前i种硬币组合金额恰好为c的所需的硬币个数。由于要求恰好组成amount，所以当c=0时才能返回0表示前i个物品组成金额c（金额0）需要0枚硬币，否则返回无穷大表示方案不合法。这样后面取min时自然就取到了不是无穷大的方案。</p><p>最后还需要判断一下，如果ans小于无穷大表示这是一个合法方案，否则无合法方案。</p><h2 id="2-3-具体实现">2.3 具体实现</h2><h3 id="2-3-1-递归">2.3.1 递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> c) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : INT_MAX / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][c];</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; coins[i]) </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dfs</span>(i - <span class="number">1</span>, c);</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>, c), <span class="built_in">dfs</span>(i, c - coins[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">dfs</span>(n - <span class="number">1</span>, amount);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; INT_MAX / <span class="number">2</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] coins;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="built_in">this</span>.coins = coins;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dfs(n - <span class="number">1</span>, amount);</span><br><span class="line">        <span class="keyword">return</span> res &lt; Integer.MAX_VALUE / <span class="number">2</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> memo[i][c];</span><br><span class="line">        <span class="keyword">if</span> (res != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; coins[i]) </span><br><span class="line">            <span class="keyword">return</span> dfs(i - <span class="number">1</span>, c);</span><br><span class="line">        <span class="type">return</span> <span class="variable">res</span> <span class="operator">=</span> Math.min(dfs(i - <span class="number">1</span>, c), dfs(i, c - coins[i]) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-优化为递推">2.3.2 优化为递推</h3><p>依然是使用f数组，根据递归边界条件当<code>i &lt; 0 &amp;&amp; c == 0</code>时才是0，其他都是无穷大，所以f数组可以初始化为无穷大，f[0][0]初始化为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度 O(n * amount) </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                f[i + <span class="number">1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i])</span><br><span class="line">                    f[i + <span class="number">1</span>][j] = <span class="built_in">min</span>(f[i][j], f[i + <span class="number">1</span>][j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = f[n][amount];</span><br><span class="line">        <span class="keyword">return</span> res &lt; INT_MAX / <span class="number">2</span> ? res : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(n * amount)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            Arrays.fill(f[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                f[i + <span class="number">1</span>][j] = f[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i])</span><br><span class="line">                    f[i + <span class="number">1</span>][j] = Math.min(f[i][j], f[i+<span class="number">1</span>][j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> f[n][amount];</span><br><span class="line">        <span class="keyword">return</span> res &lt; Integer.MAX_VALUE / <span class="number">2</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-空间优化-两个数组">2.3.3 空间优化 两个数组</h3><p>同0-1背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度 O(amount) 两个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                f[(i + <span class="number">1</span>) % <span class="number">2</span>][j] = f[i % <span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i])</span><br><span class="line">                    f[(i + <span class="number">1</span>) % <span class="number">2</span>][j] = <span class="built_in">min</span>(f[i % <span class="number">2</span>][j], f[(i + <span class="number">1</span>) % <span class="number">2</span>][j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = f[n % <span class="number">2</span>][amount];</span><br><span class="line">        <span class="keyword">return</span> res &lt; INT_MAX / <span class="number">2</span> ? res : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(amount)  两个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            Arrays.fill(f[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                f[(i + <span class="number">1</span>) % <span class="number">2</span>][j] = f[i % <span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i])</span><br><span class="line">                    f[(i + <span class="number">1</span>) % <span class="number">2</span>][j] = Math.min(f[i % <span class="number">2</span>][j], f[(i+<span class="number">1</span>) % <span class="number">2</span>][j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> f[n % <span class="number">2</span>][amount];</span><br><span class="line">        <span class="keyword">return</span> res &lt; Integer.MAX_VALUE / <span class="number">2</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-空间优化-一个数组">2.3.4 空间优化 一个数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度 O(amount) 一个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(amount + <span class="number">1</span>, INT_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i])</span><br><span class="line">                    f[j] = <span class="built_in">min</span>(f[j], f[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = f[amount];</span><br><span class="line">        <span class="keyword">return</span> res &lt; INT_MAX / <span class="number">2</span> ? res : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推 空间复杂度O(amount)  一个数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i])</span><br><span class="line">                    f[j] = Math.min(f[j], f[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> f[amount];</span><br><span class="line">        <span class="keyword">return</span> res &lt; Integer.MAX_VALUE / <span class="number">2</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;今日继续学习B站Up主出品的基础算法精讲系列，&lt;a href=&quot;https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=a0f19e79b7da02f4fa318d91be5bc86a&quot;&gt;0-1背</summary>
      
    
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://malone-ai.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
